<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Gestion Emploi du Temps 2.9</title>
	<script src="lib/jszip.min.js"></script>
	<script src="lib/xlsx.full.min.js"></script>
	<script src="lib/jspdf.umd.min.js"></script>
	<script src="lib/jspdf.plugin.autotable.min.js"></script>
	<script src="lib/tailwindcss.js"></script>

    <style>
        /* Styles CSS (Ajust√© pour la nouvelle interface) */
        body { font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; background-color: #f4f4f4; color: #333; }
        h1, h2 { color: #004d99; border-bottom: 2px solid #e6f2ff; padding-bottom: 5px; }
        
        /* En-t√™te de page */
        #page-header {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            background-color: #004d99;
            color: white;
            padding: 15px;
            border-radius: 8px;
            margin-bottom: 20px;
            align-items: end; /* Aligne les √©l√©ments en bas */
        }
        #page-header div { display: flex; flex-direction: column; }
        #page-header label { font-weight: bold; margin-bottom: 5px; font-size: 0.9em; }
        #page-header input, #page-header select { padding: 8px; border-radius: 4px; border: 1px solid #ccc; background-color: #e6f2ff; color: #333; }
        #header-actions .controls { display: flex; gap: 10px; flex-wrap: wrap; }
        #header-actions .controls button {
            padding: 8px 10px;
            flex-grow: 1;
            font-size: 0.9em;
        }

        /* --- Syst√®me d'onglets --- */
        .tabs-container {
            display: flex;
            gap: 5px;
            margin-bottom: -1px; /* Pour que la bordure se superpose */
            flex-wrap: wrap;
        }
        .tab-btn {
            padding: 10px 20px;
            cursor: pointer;
            border: 1px solid #ccc;
            border-bottom: none;
            background-color: #f1f1f1;
            border-radius: 8px 8px 0 0;
            font-weight: bold;
            color: #555;
            transition: all 0.3s ease;
        }
        .tab-btn.active {
            background-color: #0073e6;
            color: white;
            border-color: #0073e6;
        }
        .tab-pane {
            display: none;
            padding: 25px;
            border: 1px solid #ccc;
            border-radius: 0 8px 8px 8px;
            background-color: white;
            box-shadow: 0 4px 8px rgba(0,0,0,0.05);
        }
        .tab-pane.active {
            display: block;
        }
        /* --- Fin du syst√®me d'onglets --- */
        
        /* Layout pour l'onglet de Planification */
        .planning-grid {
            display: grid;
            grid-template-columns: 400px 1fr; /* Colonne de gauche fixe, droite flexible */
            gap: 25px;
        }
        .planning-grid-left {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        /* Conteneurs et Panneaux */
        .grid-container { display: flex; flex-direction: column; gap: 20px; margin-top: 20px; }
        .bottom-panels-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(400px, 1fr)); gap: 20px; }
        .controls { display: flex; gap: 10px; margin-bottom: 20px; flex-wrap: wrap; }
        #adminControls, #deleteControls, #creneauxControls { 
            display: grid; 
            gap: 15px; 
            padding: 15px; 
            background-color: #e6f2ff; 
            border-radius: 8px; 
            margin-bottom: 20px; 
        }
        #adminControls, #deleteControls {
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); 
        }

        #deleteControls { background-color: #ffe6e6; }
        #adminControls > div, #deleteControls > div { display: flex; flex-direction: column; gap: 5px; }
        #matiereGroupManagement { background-color: #f0f8ff; border: 1px solid #cceeff; padding: 15px; border-radius: 8px; }
        .management-metrics-grid { display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px; margin-top: 15px; padding-top: 15px; border-top: 1px solid #cceeff; }
        #matiereGroupControl { display: flex; flex-direction: column; gap: 10px; padding-right: 10px; }
        #volumeMetricsDisplay h4 { margin-top: 0; border-bottom: 2px solid #e6f2ff; padding-bottom: 5px; color: #333; }
        #volumeMetricsDisplay p { margin: 5px 0; padding: 5px 0; border-bottom: 1px dotted #ddd; font-size: 0.95em; }
        #volumeMetricsDisplay small { font-size: 0.85em; display: block; margin-top: 10px; color: #cc0000; }
        #souhaits-container, #volume-supplementaire-container, #enseignantSouhaitsDisplayContainer { 
            padding: 20px; 
            background-color: #ffffff; 
            border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #enseignant-edt-container {
            margin-top: 25px;
            padding: 20px; 
            background-color: #ffffff; 
            border-radius: 8px; 
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        #souhaits-container h2 { color: #cc6600; border-bottom: 2px solid #ffe6cc; }
        #enseignantSouhaitsDisplayContainer h2 { color: #cc6600; border-bottom: 2px solid #ffe6cc; }
        #enseignantSouhaitsDisplay p, #enseignantSouhaitsDisplay li { margin: 5px 0; line-height: 1.4; }
        #volume-supplementaire-container h2 { color: #009999; border-bottom: 2px solid #ccffff; }
        #volume-supplementaire-form { display: flex; flex-direction: column; gap: 10px; }
        #volume-supplementaire-form label { font-weight: bold; margin-top: 5px; }
        #volume-supplementaire-form input, #volume-supplementaire-form select, #volume-supplementaire-form button { padding: 8px; border-radius: 4px; border: 1px solid #ccc; }
        #volume-supplementaire-form button { background-color: #009999; color: white; cursor: pointer; }
        #volumeSupplementaireList { margin-top: 15px; border-top: 1px solid #eee; padding-top: 15px; }
        .volume-supplementaire-item { display: flex; justify-content: space-between; align-items: center; padding: 5px; background-color: #f2f2f2; border-radius: 4px; margin-bottom: 5px; font-size: 0.9em; }
        .delete-volume-supplementaire-btn { background: #d9534f; color: white; border: none; padding: 2px 5px; cursor: pointer; border-radius: 3px; }
        #volumeSupplementaireTotal { margin-top: 10px; font-weight: bold; text-align: right; }
        #enseignant-edt-container h2 { color: #5c0099; border-bottom-color: #e6ccff; }

        /* Formulaire & Boutons */
        #attributionForm { 
            background-color: white; padding: 20px; border-radius: 8px; box-shadow: 0 4px 8px rgba(0,0,0,0.1);
            display: grid; 
            grid-template-columns: 1fr 1fr;
            gap: 15px; 
        }
        #attributionForm label { font-weight: bold; display: block; margin-bottom: 5px; color: #004d99; }
        #attributionForm select, #attributionForm button, .controls button, #adminControls input, #adminControls select, #matiereGroupManagement input, #matiereGroupManagement select, #deleteControls select, #deleteControls button, #deleteControls input, #creneauxControls button { padding: 10px; border-radius: 5px; border: 1px solid #ccc; width: 100%; box-sizing: border-box; }
        #attributionForm button { background-color: #0073e6; color: white; cursor: pointer; font-weight: bold; transition: background-color: 0.3s; grid-column: 1 / -1; }
        #attributionForm button:hover { background-color: #005bb5; }
        .form-full-width { grid-column: 1 / -1; }
        .form-group-flex { display: flex; flex-direction: column; justify-content: flex-end; }
        .creneau-info { font-size: 0.8em; color: #555; margin-top: 5px; text-align: right; font-style: italic; }
        .volume-info-enseignant { font-size: 0.85em; font-weight: bold; margin-top: 5px; text-align: right; padding: 2px 5px; border-radius: 4px; }
        .volume-red { color: white; background-color: #d9534f; }
        .volume-green { color: white; background-color: #5cb85c; }
        .volume-orange { color: white; background-color: #f0ad4e; }
        .admin-flex-group { display: grid; grid-template-columns: 2fr 1fr 1fr; gap: 10px; }
        .inline-input-group { display: flex; gap: 5px; align-items: center; }
        .inline-input-group label { width: 45%; font-size: 0.9em; margin-bottom: 0; white-space: nowrap; }
        .inline-input-group input, .inline-input-group select { width: 55%; flex-grow: 1; padding: 5px 10px; }

        .controls button { color: white; border: none; cursor: pointer; }
        .controls button:hover { opacity: 0.9; }
        .save-btn { background-color: #5cb85c !important; }
        .export-enseignant-btn { background-color: #f0ad4e !important; }
        .export-multisheet-btn { background-color: #990099 !important; } 

        /* MODIFI√â: Animation pour les boutons dans les onglets de configuration */
        #tab-config button, #tab-matieres button {
            transition: transform 0.1s ease-out, box-shadow 0.2s ease, background-color 0.3s;
        }
        #tab-config button:hover, #tab-matieres button:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 8px rgba(0,0,0,0.15);
        }
        #tab-config button:active, #tab-matieres button:active {
            transform: translateY(0px) scale(0.98);
            animation: click-confirm-animation 0.4s ease-out;
        }
        
        /* NOUVEAU: Keyframes pour l'animation de confirmation de clic */
        @keyframes click-confirm-animation {
            0% {
                transform: translateY(0px) scale(0.98);
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            }
            50% {
                transform: translateY(0px) scale(0.97);
                box-shadow: 0 1px 10px rgba(0,0,0,0.2), 0 0 0 4px rgba(0, 115, 230, 0.3);
            }
            100% {
                transform: translateY(0px) scale(0.98);
                box-shadow: 0 1px 2px rgba(0,0,0,0.1);
            }
        }

        /* Tableau EDT */
        table { width: 100%; border-collapse: collapse; background-color: white; box-shadow: 0 0 10px rgba(0,0,0,0.1); }
        th, td { border: 1px solid #ddd; padding: 5px; text-align: center; vertical-align: top; height: 80px; position: relative; }
        th { background-color: #0073e6; color: white; font-weight: bold; }
        .jour-header { background-color: #e6f2ff; font-weight: bold; width: 10%; } 
        .seance { font-size: 0.85em; margin-bottom: 5px; padding: 5px; border-radius: 4px; line-height: 1.3; text-align: left; position: relative; min-height: 50px; }
        .seance .seance-data {
            cursor: move; /* Changed from pointer for drag-and-drop */
            transition: transform 0.2s ease, box-shadow 0.2s ease;
        }
        .seance .seance-data:hover {
            transform: scale(1.03);
            box-shadow: 0 2px 8px rgba(0,0,0,0.15);
        }
        .Cours { background-color: #ffdddd; border-left: 5px solid #cc0000; }
        .TD { background-color: #ddffdd; border-left: 5px solid #009900; }
        .TP { background-color: #ddddff; border-left: 5px solid #0000cc; }
        .delete-btn { position: absolute; top: 2px; right: 2px; background: #d9534f; color: white; border: none; padding: 2px 5px; font-size: 0.7em; cursor: pointer; border-radius: 3px; line-height: 1; }
        
       /* MODIFI√â: Style pour les s√©ances non attribu√©es */
        .seance-non-attribuee {
            /* La couleur de fond (Cours/TD/TP) est maintenant conserv√©e */
            
            /* Nous utilisons une bordure continue rouge et fine */
            border: 1px solid #dc3545 !important; 
            
            /* Nous ajoutons un "contour" int√©rieur pour plus de visibilit√© */
            /*outline: 2px solid #dc3545;
            /*outline-offset: -4px; /* Place le contour √† l'int√©rieur */

            /* Optionnel: une l√©g√®re opacit√© pour la distinguer */
            /* opacity: 0.9; */
        }
        /* Fin du style modifi√© */
        
        /* MODIFI√â: Style pour les enseignants int√©ress√©s, maintenant en gras et couleur th√®me */
        .enseignant-interesse {
            border: 2px dashed #dc3545 !important; /* Bordure rouge pointill√©e */
            /* background-color: #fff0f1 !important; */ /* Ligne supprim√©e pour garder la couleur de base */
            border-left: 5px solid #dc3545 !important; /* Bordure gauche rouge aussi */
        }
        
        /* NOUVEAU: Style pour la mise en √©vidence des r√©sultats de recherche */
        .highlight-search {
            /* box-shadow: 0 0 0 3px #f0ad4e; /* Jaune/Orange - Supprim√© */
            border-radius: 6px;
        }

        /* NOUVEAU: Style pour les champs de formulaire invalides */
        .input-error {
            border: 2px solid #dc3545 !important;
            box-shadow: 0 0 5px rgba(220, 53, 69, 0.5) !important;
        }

        /* NOUVEAU: Style pour la s√©ance s√©lectionn√©e individuellement */
        .seance-selectionnee {
            box-shadow: 0 0 0 3px #dc3545 !important; /* Bordure rouge pour indiquer la s√©lection */
            border-color: #dc3545 !important;
        }
		/* NOUVEAU: Styles pour le tableau de gestion des salles */
        .salles-edt-table {
            width: 100%;
            border-collapse: collapse;
            background-color: white;
            box-shadow: 0 0 10px rgba(0,0,0,0.1);
            table-layout: fixed; /* Important pour des colonnes √©gales */
            min-width: 1200px; /* Assure que le tableau ne soit pas trop √©cras√© */
        }
        .salles-edt-table th, .salles-edt-table td {
            border: 1px solid #ddd;
            padding: 6px;
            text-align: left;
            vertical-align: top;
            height: 120px; /* Hauteur de cellule */
            font-size: 0.8em;
            position: relative;
        }
        .salles-edt-table th {
            background-color: #0073e6;
            color: white;
            font-weight: bold;
            text-align: center;
        }
        .salles-edt-table .jour-header {
            background-color: #e6f2ff;
            font-weight: bold;
            width: 10%; /* Largeur colonne Jour */
            text-align: center;
            vertical-align: middle;
        }
        .salles-list {
            margin-bottom: 5px;
            padding: 4px;
            border-radius: 4px;
            max-height: 100px; /* Limite la hauteur si trop de salles */
            overflow-y: auto;
        }
        .salles-list strong {
            display: block;
            margin-bottom: 3px;
            border-bottom: 1px solid;
            padding-bottom: 2px;
        }
        .salles-list ul {
            margin: 0;
            padding-left: 5px;
            list-style-type: none; /* Pas de puces pour gain de place */
        }
        .salles-list li {
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        .salles-occupees {
            background-color: #fff0f1; /* Fond rose */
            border-left: 3px solid #dc3545; /* Bordure rouge */
        }
        .salles-occupees strong {
            color: #721c24; /* Texte rouge fonc√© */
            border-bottom-color: #f5c6cb;
        }
        .salles-libres {
            background-color: #f0fff4; /* Fond vert */
            border-left: 3px solid #28a745; /* Bordure verte */
        }
        .salles-libres strong {
            color: #155724; /* Texte vert fonc√© */
            border-bottom-color: #c3e6cb;
        }
        /* Fin NOUVEAU */

        /* Cellules vides et s√©lectionn√©es */
        .cellule-selectionnee {
            box-shadow: inset 0 0 0 3px #dc3545; /* Bordure rouge */
            background-color: #ffe6e6 !important; /* Fond ros√© */
        }
        
        .cellule-conflit {
            background-color: #f8d7da !important; /* Fond rouge clair, tr√®s visible */
            cursor: not-allowed;
            box-shadow: inset 0 0 0 3px #b21f2d; /* Bordure rouge fonc√©e */
        }
        
        .add-seance-in-cell-btn {
            position: absolute;
            top: 2px;
            left: 2px;
            background-color: #28a745;
            color: white;
            border: none;
            width: 20px;
            height: 20px;
            font-size: 1em;
            line-height: 20px;
            text-align: center;
            border-radius: 50%;
            cursor: pointer;
            opacity: 0.2;
            transition: opacity 0.2s ease;
            z-index: 10;
        }
        td:hover .add-seance-in-cell-btn {
            opacity: 1;
        }
        .drop-target-active {
            background-color: #e6ffe6 !important;
            box-shadow: inset 0 0 0 3px #28a745;
        }
        
        .separator-column {
            width: 15px;
            background-color: #e9ecef;
            border-left: 1px solid #ced4da;
            border-right: 1px solid #ced4da;
            padding: 0 !important;
        }

        #groupeAttributionStatus, #htp-volume-container, #log-container { padding: 15px; background-color: #f7f7f7; border-radius: 8px; border: 1px solid #eee; }
        #groupeAttributionStatus h3, #htp-volume-container h2, #log-container h3 { margin-top: 0; }
        .bottom-panels-grid table td, .bottom-panels-grid table th { padding: 4px; font-size: 0.9em; height: auto; }

        .teacher-tooltip {
            display: none;
            position: absolute;
            top: 100%;
            left: 0;
            width: auto;
            min-width: 250px;
            max-width: 100%;
            background-color: white;
            border: 1px solid #ccc;
            box-shadow: 0 6px 12px rgba(0,0,0,0.175);
            border-radius: 6px;
            padding: 1rem;
            z-index: 1050;
            font-size: 0.9em;
        }
        .teacher-tooltip h4 {
            margin-top: 0;
            margin-bottom: 0.5rem;
            font-weight: bold;
            color: #004d99;
            border-bottom: 1px solid #eee;
            padding-bottom: 0.5rem;
        }
        .teacher-tooltip ul {
            margin: 0;
            padding-left: 1.2rem;
        }

        .toast {
            padding: 1rem 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            color: white;
            font-weight: bold;
            display: flex;
            align-items: center;
            gap: 10px;
            opacity: 0;
            transform: translateX(100%);
            transition: all 0.5s cubic-bezier(0.68, -0.55, 0.27, 1.55);
            max-width: 350px;
            word-break: break-word;
        }
        .toast.show {
            opacity: 1;
            transform: translateX(0);
        }
        .toast.hide {
            opacity: 0;
            transform: translateX(100%);
        }
        .toast-success { background-color: #28a745; }
        .toast-error { background-color: #dc3545; }
        .toast-initial { background-color: #007bff; }
        .toast-warning { background-color: #ffc107; color: #333; }

        .toast::before {
            font-size: 1.5em;
            line-height: 1;
        }
        .toast-success::before { content: '‚úì'; }
        .toast-error::before { content: '‚úó'; }
        .toast-initial::before { content: '‚ÑπÔ∏è'; }
        .toast-warning::before { content: '‚ö†Ô∏è'; }

        #messages p {
            padding: 8px;
            margin-bottom: 5px;
            border-radius: 4px;
            border-left: 4px solid;
            font-size: 0.9em;
        }
        #messages .success {
            background-color: #e9f7ef;
            border-color: #28a745;
            color: #155724;
        }
        #messages .error {
            background-color: #fbe9e9;
            border-color: #dc3545;
            color: #721c24;
        }
        #messages .initial {
            background-color: #e7f3ff;
            border-color: #007bff;
            color: #004085;
        }
        #messages .warning {
            background-color: #fff8e1;
            border-color: #ffc107;
            color: #856404;
        }

        /* MODIFI√â: Styles pour le panneau Souhaits et Contraintes redessin√© */
        #enseignantSouhaitsDisplay {
            padding: 12px; /* R√©duit */
            background-color: #fffaf0; /* Fond jaune clair */
            border-left: 5px solid #ff9800; /* Bordure orange */
            border-radius: 0 4px 4px 0;
            min-height: 50px;
        }
        .souhaits-table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 8px; /* R√©duit */
            font-size: 0.8em; /* R√©duit */
        }
        .souhaits-table th, .souhaits-table td {
            border: 1px solid #ffe0b2; /* Bordure orange clair */
            padding: 3px 5px; /* R√©duit */
            text-align: left;
        }
        .souhaits-table th {
            background-color: #ffe0b2; /* Fond en-t√™te orange clair */
            font-weight: bold;
            color: #a15200; /* Texte en-t√™te plus fonc√© */
        }
        .souhaits-table td:nth-child(3),
        .souhaits-table td:nth-child(4),
        .souhaits-table td:nth-child(5),
        .souhaits-table th:nth-child(3),
        .souhaits-table th:nth-child(4),
        .souhaits-table th:nth-child(5) {
            text-align: center;
        }
        .contraintes-section {
            margin-top: 8px; /* R√©duit */
            border-top: 1px solid #ffe0b2; /* Bordure orange clair */
            padding-top: 8px; /* R√©duit */
        }
        .contraintes-section p:first-child {
            margin-top: 0;
            margin-bottom: 5px;
        }
        .contraintes-section p:last-child {
            font-style: italic;
            white-space: pre-wrap;
            background-color: #fff;
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #e9ecef;
            margin-bottom: 0;
        }

        /* NOUVEAU: Styles pour la barre de progression */
        .progress-bar-container {
            width: 100%;
            background-color: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            height: 20px;
            position: relative;
        }
        .progress-bar {
            height: 100%;
            color: white;
            text-align: center;
            line-height: 20px;
            font-size: 0.8em;
            white-space: nowrap;
            transition: width 0.5s ease-in-out;
        }
        .progress-bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 20px;
            color: #333;
            font-weight: bold;
            font-size: 0.8em;
        }


        /* NOUVEAU: Styles pour l'indicateur de chargement (spinner) */
        #loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.6);
            z-index: 2000; /* Doit √™tre au-dessus de tout le reste */
            display: flex;
            justify-content: center;
            align-items: center;
        }
        .spinner {
            border: 8px solid #f3f3f3; /* Gris clair */
            border-top: 8px solid #0073e6; /* Bleu */
            border-radius: 50%;
            width: 60px;
            height: 60px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    
    <!-- NOUVEAU: √âl√©ment HTML pour le spinner -->
    <div id="loading-overlay" style="display: none;">
        <div class="spinner"></div>
    </div>

    <div id="page-header">
        <div>
            <label for="inputAnneeUniversitaire">Ann√©e Universitaire :</label>
            <input type="text" id="inputAnneeUniversitaire" placeholder="ex: 2024/2025">
        </div>
        <div>
            <label for="selectSession">Session :</label>
            <select id="selectSession">
                <option value="Session d'automne">Session d'automne</option>
                <option value="Session de printemps">Session de printemps</option>
            </select>
        </div>
        <div>
            <label for="selectDepartement">D√©partement :</label>
            <select id="selectDepartement">
                <option>D√©partement de physique</option>
                <option>D√©partement de chimie</option>
                <option>D√©partement de Biologie</option>
                <option>D√©partement de math√©matiques</option>
                <option>D√©partement d'informatique</option>
                <option>D√©partement de G√©ologie</option>
                <option>D√©partement Modules Transversaux</option>
                <option>Administration</option>
            </select>
        </div>
        <div id="header-actions">
            <label>Actions :</label>
            <div class="controls">
                <button id="saveBtn" class="save-btn">üíæ Enregistrer</button>
            </div>
        </div>
    </div>

    <h1>üß† Gestion Emploi du Temps 2.9</h1>
    
    <!-- Navigation par Onglets -->
    <div class="tabs-container">
        <button class="tab-btn active" data-tab="planning">üìÖ Planification</button>
        <button class="tab-btn" data-tab="config">üîß Configuration</button>
        <button class="tab-btn" data-tab="matieres">üìö Mati√®res & Souhaits</button>
        <button class="tab-btn" data-tab="rapports">üìä Rapports & Logs</button>
		<button class="tab-btn" data-tab="salles">üèõÔ∏è Gestion des Salles</button>
    </div>

    <!-- Contenu des Onglets -->
    <div id="tab-planning" class="tab-pane active">
        <div class="planning-grid">
            <div class="planning-grid-left">
                <!-- Formulaire d'attribution -->
                <form id="attributionForm">
                    <div class="form-full-width">
                         <h2 style="margin-top: 0;">üìù Configurer & Attribuer une S√©ance</h2>
                    </div>
                    <div>
                        <label for="inputJour">Jour :</label>
                        <select id="inputJour" required></select>
                    </div>
                    <div class="form-group-flex">
                        <label for="inputCreneau">Cr√©neau (Heure de d√©but) :</label>
                        <select id="inputCreneau" required></select>
                        <div class="creneau-info" id="creneauFin">Fin : --:--</div>
                    </div>
                    <div>
                        <label for="inputType">Type :</label>
                        <select id="inputType" required></select>
                    </div>
                    <div>
                        <label for="inputFiliere">Fili√®re :</label>
                        <select id="inputFiliere" required></select>
                    </div>
                     <div class="form-full-width" style="position: relative;">
                        <label for="inputMatiere">Mati√®re :</label>
                        <select id="inputMatiere" required></select>
                        <div id="teacherInterestTooltip" class="teacher-tooltip"></div>
                    </div>
                    <div id="sectionDiv">
                        <label for="inputSection">Section :</label>
                        <select id="inputSection" required></select>
                    </div>
                    <div id="groupeDiv" style="display: none;">
                        <label for="inputGroupeTDTP">Groupe (TD/TP) :</label>
                        <select id="inputGroupeTDTP"></select>
                    </div>
                    <div>
                        <label for="inputEnseignant1">Enseignant 1 :</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <select id="inputEnseignant1" style="flex-grow: 1;"></select>
                            <button type="button" id="btnSuggestTeacher" class="bg-indigo-500 hover:bg-indigo-600 text-white" style="padding: 10px; width: auto; height: 38px; flex-shrink: 0;" title="Sugg√©rer un enseignant disponible et int√©ress√©">üí°</button>
                        </div>
                        <div class="volume-info-enseignant" id="volumeInfoEnseignant1"></div>
                    </div>
                    <div id="enseignant2SelectDiv" style="display: none;">
                        <label for="inputEnseignant2">Enseignant 2 :</label>
                        <div style="display: flex; align-items: center; gap: 5px;">
                            <select id="inputEnseignant2" style="flex-grow: 1;"></select>
                            <button type="button" id="btnSuggestTeacher2" class="bg-indigo-500 hover:bg-indigo-600 text-white" style="padding: 10px; width: auto; height: 38px; flex-shrink: 0; display: none;" title="Sugg√©rer un deuxi√®me enseignant pour le TP">üí°</button>
                        </div>
                        <div class="volume-info-enseignant" id="volumeInfoEnseignant2"></div>
                    </div>
                    <div>
                        <label for="inputSalle">Salle :</label>
                        <select id="inputSalle"></select>
                         <div class="creneau-info" id="salleTypeInfo">Type: --</div>
                    </div>
                        <div id="freeRoomsBlock" style="margin-top:8px; display:flex; gap:8px; align-items:center;">
                    <div style="flex:1;">
                     <label for="inputSalleLibre" style="font-weight:bold;">Salles libres pour ce cr√©neau :</label>
                     <select id="inputSalleLibre" style="width:100%; padding:8px; border-radius:4px; border:1px solid #ccc;">
                      <option value="">-- Choisir une salle libre --</option>
                        </select>
                         <div id="inputSalleLibreInfo" style="font-size:0.9em; color:#666; margin-top:6px;">S√©lectionnez jour/cr√©neau/type pour voir les salles libres.</div>
                        </div>
                        <div style="display:flex; flex-direction:column; gap:6px;">
                         <button type="button" id="btnUseFreeSalle" class="bg-blue-600 hover:bg-blue-700 text-white p-2 rounded" style="white-space:nowrap;">Utiliser</button>
                         <button type="button" id="btnRefreshFreeSalle" class="bg-gray-300 hover:bg-gray-400 text-black p-2 rounded" style="white-space:nowrap;">Rafra√Æchir</button>
                        </div>
                    </div>
                
                    <div id="enseignant2NoteDiv" class="form-group-flex" style="display: none;"> 
                         <div class="creneau-info" id="enseignant2-note">Co-ens. possible</div>
                    </div>
                    <!-- SECTION BOUTONS CORRIG√âE ET AM√âLIOR√âE -->
                    <div class="form-full-width" style="display: grid; grid-template-columns: 1fr; gap: 10px;">
                        <!-- MODIFI√â: Ce bouton est maintenant pour la MODIFICATION, et cach√© par d√©faut -->
                        <button type="submit" id="btnSubmitForm" style="display: none;">‚úÖ Appliquer les Modifications</button>
                        
                        <!-- NOUVEAU: Bouton pour le mode cr√©ation, visible par d√©faut -->
                        <button type="button" id="btnInfoModeCreation" class="bg-green-600 hover:bg-green-700 text-white" title="Configurez la s√©ance ci-dessus, puis cliquez sur une case vide de l'emploi du temps pour la placer.">
                            Mode Cr√©ation (Configurer & Cliquer case)
                        </button>
                        
                        <!-- MODIFI√â: Le conteneur d'√©dition inclut maintenant le bouton de soumission -->
                        <div id="edit-buttons-container" style="display: none; grid-template-columns: 1fr 1fr; gap: 10px;">
                             <button type="button" id="btnCancelEdit" class="bg-yellow-500 hover:bg-yellow-600 text-white">Annuler la Modification</button>
                             <button type="button" id="btnDeleteSelected" class="bg-red-600 hover:bg-red-700 text-white">Supprimer la S√©ance</button>
                        </div>
                    </div>
                </form>
                
                <!-- Panneaux de d√©tails de l'enseignant -->
                <div id="enseignantSouhaitsDisplayContainer">
                     <h2>üìù Souhaits et Contraintes</h2>
                     <div id="enseignantSouhaitsDisplay">
                        <p>S√©lectionnez un enseignant dans le formulaire pour voir ses souhaits.</p>
                    </div>
                </div>
                
                <div id="volume-supplementaire-container">
                    <h2>üí∞ Volume Horaire Suppl√©mentaire</h2>
                    <div id="volume-supplementaire-form">
                         <p>Enseignant s√©lectionn√©: <strong id="volume-supplementaire-enseignant-nom">-- Aucun --</strong></p>
                         <label for="volumeSupplementaireType">Type de service :</label>
                         <select id="volumeSupplementaireType">
                             <option value="Master">Master</option>
                             <option value="Coll√®ge">Coll√®ge</option>
                             <option value="Chef de d√©partement">Chef de d√©partement</option>
                             <option value="Coordination de fili√®re">Coordination de fili√®re</option>
                             <option value="PFE">PFE</option>
                             <option value="All√®gement">All√®gement</option>
                             <option value="Autre">Autre</option>
                         </select>
                         <input type="text" id="volumeSupplementaireDescriptionAutre" placeholder="Description si 'Autre'" style="display:none; margin-top:5px;">
                         <label for="volumeSupplementaireVolume">Volume hTP :</label>
                         <input type="number" id="volumeSupplementaireVolume" min="0">
                         <button id="btnAddVolumeSupplementaire">‚ûï Ajouter Volume</button>
                    </div>
                    <div id="volumeSupplementaireList"></div>
                    <div id="volumeSupplementaireTotal"></div>
                </div>
                
            </div>
            
            <div class="planning-grid-right">
                <!-- Emploi du temps principal -->
				<button onclick="planificationAutomatiqueDesCreneaux()" class="bg-blue-500 text-white p-2 rounded-md mb-2">
                üìÖ G√©n√©rer les cr√©neaux automatiquement
            </button>
                <div id="edt-container">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                        <h2 style="margin: 0;">Emploi du Temps Hebdomadaire</h2>
                        <!-- MODIFI√â: Ajout d'un conteneur et du nouveau bouton -->
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <label for="selectEDTView" style="font-weight: bold;">Afficher l'emploi du temps de :</label>
                            <select id="selectEDTView" style="padding: 5px; border-radius: 4px;"></select>
                            <!-- NOUVEAU: Bouton d'exportation PDF de la vue actuelle -->
                            <button id="exportCurrentViewPdfBtn" class="bg-red-600 hover:bg-red-700 text-white p-2 rounded-md" style="font-size: 0.9em;">Exporter Vue (PDF)</button>
                        </div>
                    </div>
                    
                    <!-- NOUVELLE SECTION DE FILTRE -->
                    <div id="search-filters" class="grid grid-cols-1 md:grid-cols-5 gap-4 mb-4 p-4 bg-gray-100 rounded-lg">
                        <input type="text" id="searchMatiere" placeholder="Filtrer par mati√®re..." class="p-2 border rounded-md">
                        <input type="text" id="searchEnseignant" placeholder="Filtrer par enseignant..." class="p-2 border rounded-md">
                        <input type="text" id="searchSalle" placeholder="Filtrer par salle..." class="p-2 border rounded-md">
                        <!-- NOUVEAU CHAMP DE FILTRE -->
                        <input type="text" id="searchSectionGroupe" placeholder="Filtrer par section/groupe..." class="p-2 border rounded-md">
                        <button id="btnClearFilters" class="bg-gray-500 text-white p-2 rounded-md hover:bg-gray-600">Effacer les filtres</button>
                    </div>

                    <!-- NOUVEAU: Panneau d'attribution automatique -->
        <div id="auto-assign-panel" class="mb-4 p-4 bg-indigo-50 rounded-lg border border-indigo-200">
                <h3 class="text-lg font-semibold text-indigo-800">Actions Automatis√©es</h3>
                <p class="text-sm text-indigo-600 mb-2">Attribue automatiquement les enseignants aux s√©ances non pourvues en respectant les souhaits et la charge horaire.</p>
                <button id="btnAutoAssign" class="bg-indigo-600 text-white p-2 rounded-md hover:bg-indigo-700 w-full md:w-auto">ü§ñ Attribuer Enseignants (Auto)</button>
                <div id="auto-assign-status" class="text-sm mt-2 text-gray-600 font-medium"></div>
            <div id="auto-assign-rooms-panel" style="margin-top:10px; display:flex; gap:8px; flex-wrap:wrap; align-items:flex-start;">
                <div style="min-width:360px; background:#fff; padding:10px; border-radius:6px; border:1px solid #e6e6e6;">
             <div style="font-weight:bold; margin-bottom:6px;">Salles pour g√©n√©ration automatique (configuration par fili√®re)</div>
            <div style="display:flex; gap:10px; align-items:flex-start; flex-wrap:wrap;">
                <div style="display:flex; flex-direction:column; gap:6px;">
                    <label style="font-size:0.9em;">Cours (multi)</label>
                    <select id="autoSalleCours" multiple size="5" style="min-width:240px; padding:6px; border-radius:4px;"></select>
                </div>
                <div style="display:flex; flex-direction:column; gap:6px;">
                    <label style="font-size:0.9em;">TD (multi)</label>
                    <select id="autoSalleTD" multiple size="5" style="min-width:240px; padding:6px; border-radius:4px;"></select>
                </div>
               
            </div>
                <div style="display:flex; gap:8px; margin-top:8px; align-items:center;">
                    <button id="btnSaveAutoSalleForFiliere" class="bg-indigo-500 text-white p-2 rounded-md">üíæ Enregistrer pour la fili√®re</button>
                    <button id="btnClearAutoSalleForFiliere" class="bg-gray-400 text-white p-2 rounded-md">Effacer</button>
                    <small style="color:#555;">S√©lection multiple : Ctrl/Cmd+click</small>
                </div>
                <div style="margin-top:8px;font-size:0.85em;color:#666;">
      Les choix sont sauvegard√©s par fili√®re. Lors de la g√©n√©ration automatique, les salles seront r√©parties (round-robin).
                </div>
                </div>
            </div>
        </div>

                    <div id="edt-notification-area" class="mb-4"></div>
                    <table id="edtTable"></table>
                </div>
            </div>
        </div>

        <div id="enseignant-edt-container">
            <h2>üìÖ Emploi du Temps de l'Enseignant</h2>
            <button id="btnAfficherEdtEnseignant">Afficher/Masquer</button>
            <div id="enseignantEdtDisplay" style="margin-top: 15px; display: none;"></div>
        </div>
    </div>

    <div id="tab-config" class="tab-pane">
        <h2>üïí G√©rer les Cr√©neaux Horaires</h2>
        <div id="creneauxControls">
            <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end; margin-bottom: 15px;">
                <div>
                    <label for="inputNewCreneauStart">Heure D√©but (HH:MM)</label>
                    <input type="time" id="inputNewCreneauStart" class="w-full" style="padding: 8px;">
                </div>
                <div>
                    <label for="inputNewCreneauEnd">Heure Fin (HH:MM)</label>
                    <input type="time" id="inputNewCreneauEnd" class="w-full" style="padding: 8px;">
                </div>
                 <div>
                    <button id="btnAddCreneau">Ajouter Cr√©neau</button>
                </div>
            </div>
            <div id="creneauxListContainer">
                <h4 style="margin-top: 10px; border-top: 1px solid #ccc; padding-top: 10px;">Liste des Cr√©neaux Actuels</h4>
                <div id="creneauxList"></div>
            </div>
        </div>

        <h2>üîß Ajout de Ressources</h2>
        <div id="adminControls">
            <div>
                <label for="inputNewEnseignant">Enseignant :</label>
                <input type="text" id="inputNewEnseignant" placeholder="Ex: AIT ZIANE" />
                <button id="btnAddEnseignant">Ajouter</button>
            </div>
            <div>
                <label for="inputNewSalleName">Salle :</label>
                <div class="admin-flex-group">
                    <input type="text" id="inputNewSalleName" placeholder="Nom de la salle" style="grid-column: 1 / span 2;"/>
                    <select id="inputNewSalleType">
                        <option value="Standard">Standard</option>
                        <option value="Amphi">Amphi</option>
                        <option value="STP">STP</option>
                    </select>
                    <button id="btnAddSalle">Ajouter</button>
                </div>
            </div>
            <div>
                <label for="inputNewFiliere">Fili√®re :</label>
                <input type="text" id="inputNewFiliere" placeholder="Ex: S5 P" />
                <button id="btnAddFiliere">Ajouter</button>
            </div>
        </div>
        <!-- NOUVEAU VOLET POUR L'ASSOCIATION FILI√àRE/SESSION -->
        <h2>üîó Associer Fili√®res aux Sessions</h2>
        <div id="filiereSessionControls" style="padding: 15px; background-color: #f0f8ff; border-radius: 8px; margin-bottom: 20px;">
            <p style="font-size: 0.9em; margin-top: 0; margin-bottom: 15px; color: #555;">D√©finissez ici si une fili√®re appartient √† la session d'Automne ou de Printemps. Seules les fili√®res de la session active seront affich√©es dans l'application.</p>
            <div id="filiereSessionList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(300px, 1fr)); gap: 10px;">
                <!-- La liste sera g√©n√©r√©e par JavaScript -->
            </div>
            <!-- NOUVEAU BOUTON -->
            <button id="btnApplyFiliereSessionChanges" style="margin-top: 15px; background-color: #28a745; color: white; width: 100%;">Appliquer les Changements</button>
        </div>
        <h2>‚ùå Suppression de Ressources</h2>
        <div id="deleteControls">
            <div>
                <label for="selectEnseignantToDelete">Enseignant :</label>
                <select id="selectEnseignantToDelete"></select>
                <button id="btnDeleteEnseignant" style="background-color: #d9534f; color: white;">Supprimer</button>
            </div>
            <div>
                <label for="selectSalleToDelete">Salle :</label>
                <select id="selectSalleToDelete"></select>
                <button id="btnDeleteSalle" style="background-color: #d9534f; color: white;">Supprimer</button>
            </div>
            <div>
                <label for="selectFiliereToDelete">Fili√®re :</label>
                <select id="selectFiliereToDelete"></select>
                <button id="btnDeleteFiliere" style="background-color: #d9534f; color: white;">Supprimer</button>
            </div>
        </div>
        <!-- NOUVELLE SECTION DE R√âINITIALISATION -->
        <h2>‚ö†Ô∏è Zone de Danger - R√©initialisation</h2>
        <div id="resetControls" style="background-color: #fff0f0; border: 1px solid #d9534f; grid-template-columns: 1fr 1fr; display: grid; gap: 15px; padding: 15px; border-radius: 8px;">
            <div>
                <label>R√©initialiser l'Emploi du Temps</label>
                <p style="font-size: 0.8em; margin: 5px 0;">Supprime toutes les s√©ances planifi√©es pour la session actuelle mais conserve la configuration (enseignants, salles, etc.).</p>
                <button id="btnResetEDT" style="background-color: #f0ad4e; color: white; width: 100%;">Vider l'Emploi du Temps</button>
            </div>
            <div>
                <label>R√©initialiser le Projet Complet</label>
                <p style="font-size: 0.8em; margin: 5px 0;">Supprime <strong>TOUT</strong> : s√©ances (des 2 sessions), enseignants, salles, mati√®res. Restaure les valeurs par d√©faut.</p>
                <button id="btnResetProject" style="background-color: #d9534f; color: white; width: 100%;">R√©initialisation Totale du Projet</button>
            </div>
        </div>
    </div>
    
    <div id="tab-matieres" class="tab-pane">
        <div class="souhaits-forfait-grid" style="grid-template-columns: 1fr 2fr; align-items: start;">
            <div id="souhaits-container">
                <h2>üì• Importer Souhaits (Excel)</h2>
                <div style="display: flex; flex-direction: column; gap: 10px;">
                    <input type="file" id="inputSouhaitsFile" accept=".xlsx, .xls"/>
                    <button id="btnLoadSouhaits" style="background-color: #009900; color: white;">Charger les Souhaits</button>
                    <div id="importStatus" style="font-weight: bold; color: #555;"></div>
                </div>
            </div>
            <div id="matiereGroupManagement">
                <h2>‚öôÔ∏è G√©rer Mati√®res, Groupes et Volumes</h2>
                <div style="margin-bottom: 15px; padding: 10px; border: 1px dashed #004d99; border-radius: 5px;">
                    <label for="inputNewMatiere" style="font-weight: bold; color: #cc6600;">Ajouter une Nouvelle Mati√®re :</label>
                    <input type="text" id="inputNewMatiere" placeholder="Ex: Optique Quantique" style="margin-bottom: 5px;"/>
                    <button id="btnAddMatiere" style="background-color: #cc6600;">‚ûï Ajouter Mati√®re</button>
                </div>
                <div class="management-metrics-grid">
                    <div id="matiereGroupControl">
                        <label for="selectMatiereToManage" style="font-weight: bold; color: #004d99; font-size: 1.1em;">S√©lectionner la Mati√®re :</label>
                        <select id="selectMatiereToManage"></select>
                        <!-- NOUVEAU CHAMP POUR LA FILI√àRE -->
                        <div style="margin-top: 10px;">
                            <label for="selectMatiereFiliere" style="font-weight: bold; color: #004d99;">Fili√®re Attach√©e :</label>
                            <select id="selectMatiereFiliere"></select>
                        </div>
                        <div id="enseignantsInteressesContainer" style="margin-top: 15px;">
                            <h4 style="margin: 0 0 5px 0; color: #333; border-bottom: 1px solid #ccc;">Enseignants int√©ress√©s</h4>
                            <div id="enseignantsInteressesList" style="font-size: 0.9em; max-height: 150px; overflow-y: auto; background-color: #fff; padding: 5px; border: 1px solid #ddd; border-radius: 4px;">
                                <p style="font-style: italic; color: #777;">S√©lectionnez une mati√®re.</p>
                            </div>
                        </div>
                        <h4 style="margin-top: 15px; color: #333; border-bottom: 1px solid #ccc;">Groupes/Sections (Total)</h4>
                        <div class="inline-input-group"><label for="inputManageSections">Sections Cours :</label><input type="number" id="inputManageSections" min="0"/></div>
                        <div class="inline-input-group"><label for="inputManageTdGroups">Groupes TD :</label><input type="number" id="inputManageTdGroups" min="0"/></div>
                        <div class="inline-input-group"><label for="inputManageTpGroups">Groupes TP :</label><input type="number" id="inputManageTpGroups" min="0"/></div>
                        
                        <!-- NOUVEAU: Option pour le nombre d'enseignants TP -->
                        <div class="inline-input-group" style="margin-top: 5px;">
                            <label for="selectManageNbEnseignantsTP">Ens. par TP :</label>
                            <select id="selectManageNbEnseignantsTP">
                                <option value="1">1 Enseignant</option>
                                <option value="2">2 Enseignants</option>
                            </select>
                        </div>
                        
                        <h4 style="margin-top: 15px; color: #333; border-bottom: 1px solid #ccc;">Volumes Horaires pour cette Mati√®re (hTP)</h4>
                        <div class="inline-input-group"><label for="inputManageVolumeCours">Volume Cours :</label><input type="number" id="inputManageVolumeCours" min="0"/></div>
                        <div class="inline-input-group"><label for="inputManageVolumeTD">Volume TD :</label><input type="number" id="inputManageVolumeTD" min="0"/></div>
                        <div class="inline-input-group"><label for="inputManageVolumeTP">Volume TP :</label><input type="number" id="inputManageVolumeTP" min="0"/></div>
                        <button id="btnUpdateMatiereSettings" style="margin-top: 10px; background-color: #0073e6; color: white;">Mettre √† jour</button>
                        <button id="btnDeleteMatiere" style="margin-top: 5px; background-color: #d9534f;">‚ùå Supprimer Mati√®re</button>
                    </div>
                    <div id="volumeMetricsDisplay">
                        <h4>üìä Projections de Volume (hTP)</h4>
                        <div style="background-color:#fff9e6; padding:10px; border-left: 3px solid #ffcc00; border-radius:4px; margin-bottom:15px;">
                            <p style="font-size: 1.1em; font-weight: bold; color: #cc6600;">üìö VOLUME MATI√àRE (<span id="displaySelectedMatiereName">--</span>)</p>
                            <p>VHT: <span id="displayVHT">--</span> h</p>
                            <p>Nb. Enseignants Attribu√©s: <span id="displayNbEnseignants">--</span></p>
                            <p style="font-weight: bold; color: #004d99;">VHM [/<span id="displayTotalRegisteredTeachersMatter">--</span> Ens.]: <span id="displayVHM">--</span> h/ens</p>
                        </div>
                        <div style="background-color:#e6f2ff; padding:10px; border-left: 3px solid #004d99; border-radius:4px;">
                             <p style="font-size: 1.1em; font-weight: bold; color: #004d99;">üåé VOLUME GLOBAL (Toutes Mati√®res)</p>
                            <p>Global VHT: <span id="displayGlobalVHT">--</span> h</p>
                            <p>Nb. Enseignants Attribu√©s: <span id="displayTotalUniqueTeachers">--</span></p>
                            <p style="font-weight: bold; color: #004d99;">Global VHM [/<span id="displayTotalRegisteredTeachersGlobal">--</span> Ens.]: <span id="displayGlobalVHM">--</span> h/ens</p>
                        </div>
                        <small>‚ö†Ô∏è Le VHM est calcul√© sur le nombre total d'enseignants enregistr√©s.</small>
                    </div>
                </div> 
                <button id="btnInitMatieres" style="margin-top: 10px; background-color: #0073e6; width: 100%;">R√©initialiser Mati√®res D√©faut (Vide)</button>
            </div>
        </div>
    </div>
    
    <div id="tab-rapports" class="tab-pane">
         <h2>üíæ Sauvegarde & Exportation</h2>
        <div class="controls" style="background-color: #e6f2ff; padding: 15px; border-radius: 8px; display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 10px;">
            <button id="exportProjetBtn" class="bg-blue-600 hover:bg-blue-700">üì§ Exporter Projet (.json)</button>
            <button id="importProjetBtn" class="bg-purple-600 hover:bg-purple-700">üì• Importer Projet (.json)</button>
            <input type="file" id="importProjetInput" style="display: none;" accept=".json">
            <button id="exportMultiSheetBtn" class="export-multisheet-btn">üì¶ Exporter EDT (Excel)</button>
            <button id="exportEnseignantBtn" class="export-enseignant-btn">üìÑ Exporter Rapports (PDF/Imprimer)</button>
            <button id="exportGlobalPdfBtn" class="bg-red-600 hover:bg-red-700">üìï Exporter EDT Global (PDF)</button>
        </div>
        <div class="bottom-panels-grid" style="margin-top: 25px;">
            <div id="htp-volume-container">
                <h2>üìä Volume Horaire (hTP) par Enseignant</h2>
                <table id="hTPTable">
                    <thead><tr><th>Enseignant</th><th>Volume hTP</th><th>Progression / VHM</th></tr></thead>
                    <tbody id="hTPBody"></tbody>
                </table>
            </div>
             <div id="groupeAttributionStatus">
                <h3>üìù Statut des Groupes Attribu√©s</h3>
                <div id="groupeAttributionBody"></div>
            </div>
            <div id="log-container">
                <h3>Journal des Op√©rations <button id="btnClearLog" style="float: right; padding: 5px 10px; background-color: #d9534f; color: white; border: none; border-radius: 4px; cursor: pointer;">Vider</button></h3>
                <div id="messages"></div>
            </div>
        </div>
    </div>
	<div id="tab-salles" class="tab-pane">
        <h2>Disponibilit√© des Salles par Cr√©neau</h2>
        <p class="mb-4 text-gray-600" style="max-width: 800px; margin-bottom: 1rem;">
            Vue d'ensemble de l'occupation des salles pour la session actuelle. Les salles occup√©es par un TP de 3h sont marqu√©es sur les deux cr√©neaux (celui de d√©but et celui de fin).
        </p>
        
        <!-- Ce conteneur sera rempli par JavaScript -->
        <div id="salles-edt-container" class="overflow-x-auto" style="overflow-x: auto;">
            <p>G√©n√©ration du tableau des salles...</p>
        </div>
    </div>
    <!-- Modale de dialogue (inchang√©e) -->
    <div id="dialogModal" class="fixed inset-0 bg-black bg-opacity-50 flex items-center justify-center p-4" style="display: none; z-index: 1000;">
        <div class="bg-white rounded-lg shadow-xl p-6 w-full max-w-md">
            <div class="flex justify-between items-center border-b pb-3 mb-4">
                <h3 id="dialogTitle" class="text-xl font-bold">Notification</h3>
                <button id="closeDialogBtn" class="text-gray-500 hover:text-gray-800 text-2xl leading-none">&times;</button>
            </div>
            <div id="dialogBody" class="text-gray-700 mb-6"></div>
            <div class="flex justify-end gap-4">
                 <button id="dialogCancelBtn" class="px-4 py-2 bg-gray-200 rounded hover:bg-gray-300">Annuler</button>
                 <button id="dialogConfirmBtn" class="px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700">Confirmer</button>
            </div>
        </div>
    </div>


    <footer id="page-footer" style="text-align: center; margin-top: 30px; padding-top: 20px; border-top: 1px solid #ccc; font-style: italic; color: #666;">
        Pr. Ibrahim Mrani - UCD
    </footer>

    <script>
        // --- SCRIPT ---
        
        // --- 1. D√©finition des Constantes & Variables Globales ---
        const LISTE_JOURS = ['Lundi', 'Mardi', 'Mercredi', 'Jeudi', 'Vendredi', 'Samedi'];
        const DEFAULT_CRENEAUX = {
            '8h30': { fin: '10h00', duree: 1.5 }, 
            '10h15': { fin: '11h45', duree: 1.5 }, 
            '14h00': { fin: '15h30', duree: 1.5 }, 
            '15h45': { fin: '17h15', duree: 1.5 }, 
            '17h30': { fin: '19h00', duree: 1.5 }
        };
        let LISTE_CRENEAUX = {};
        const LISTE_TYPES_SEANCE = ['Cours', 'TD', 'TP'];
        // MODIFI√â: La structure des fili√®res est maintenant un tableau d'objets pour inclure la session
        const DEFAULT_FILIERES = [
            { nom: 'S3 PC', session: 'Automne' }, { nom: 'S3 P', session: 'Automne' }, 
            { nom: 'S4 SMP', session: 'Printemps' }, { nom: 'S4 SMC', session: 'Printemps' }, 
            { nom: 'S5 P', session: 'Automne' }, { nom: 'S6 P', session: 'Printemps' }, 
            { nom: 'Master P', session: 'Automne' }, { nom: 'Master PC', session: 'Printemps' }
        ];
        const CRENEAUX_COUPLES_SUIVANT = { '8h30': '10h15', '14h00': '15h45' };
        const DEFAULT_ENSEIGNANTS = [];
        const DEFAULT_MATIERE_GROUPES_INFO = {};
        const DEFAULT_SALLES_INFO = {
            'Amphi F': 'Amphi', 'Amphi B': 'Amphi', 'Amphi Y': 'Amphi', 'Amphi N': 'Amphi', 'Amphi H': 'Amphi',
            'STP 15': 'STP', 'STP14': 'STP', 'STP17': 'STP', 
            'S1': 'Standard', 'S2': 'Standard', 'S3': 'Standard', 'S4': 'Standard', 'S5': 'Standard', 'S6': 'Standard', 
            'S7': 'Standard', 'S8': 'Standard', 'S9': 'Standard', 'S10': 'Standard', 'S11': 'Standard', 'S12': 'Standard', 
            'S13': 'Standard', 'S14': 'Standard', 'S15': 'Standard', 'S16': 'Standard', 'S17': 'Standard', 'S18': 'Standard', 
            'S19': 'Standard', 'S20': 'Standard', 'S21': 'Standard', 'S22': 'Standard', 'S23': 'Standard', 'S24': 'Standard', 
            'S25': 'Standard', 'S26': 'Standard', 'S27': 'Standard', 'S28': 'Standard', 'S29': 'Standard', 'S30': 'Standard', 
            'S31': 'Standard', 'S32': 'Standard', 'S33': 'Standard', 'S34': 'Standard', 'S35': 'Standard', 'S36': 'Standard', 
            'S37': 'Standard', 'S38': 'Standard', 'S39': 'Standard', 'S40': 'Standard', 'S41': 'Standard', 'S42': 'Standard', 
            'S43': 'Standard', 'S44': 'Standard', 'S45': 'Standard', 'S46': 'Standard', 'S47': 'Standard', 'S48': 'Standard', 
            'S49': 'Standard', 'S50': 'Standard', 'S51': 'Standard', 'S52': 'Standard'
        };
        let LISTE_ENSEIGNANTS = [];
        let LISTE_MATIERES = [];
        let LISTE_FILIERES = []; 
        let SALLES_INFO = {};
        let MATIERE_GROUPES_INFO = {};
        const DEFAULT_VOLUME_HTP = { 'Cours': 48, 'TD': 32, 'TP': 36 };
        let nextSessionId = 1;
        let seances = [];
        let ENSEIGNANT_SOUHAITS = {}; 
        let ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES = {};
        let VOLUMES_AUTOMNE = {};
        let currentlyEditingSessionId = null;
        let currentlySelectedCell = null;
        let currentlySelectedSeance = null; // NOUVEAU: Pour suivre la s√©ance s√©lectionn√©e
        let activeFiliereConstraint = null;
        let draggedSessionId = null;
        let tempFiliereSessionChanges = {}; // NOUVEAU: Pour stocker les changements de session de fili√®re
        
        // --- 2. Fonctions Utilitaires et de Logique ---
        
        // NOUVEAU: Fonction pour obtenir les noms des fili√®res de la session en cours
        function getFiliereNomsForCurrentSession() {
            const sessionValue = document.getElementById('selectSession').value;
            const currentSession = sessionValue.toLowerCase().includes('automne') ? 'Automne' : 'Printemps';
            
            return LISTE_FILIERES
                .filter(f => f.session === currentSession)
                .map(f => f.nom)
                .sort();
        }

        // NOUVEAU: Fonction pour obtenir le volume hTP d'une mati√®re sp√©cifique
        function getHtpForMatiere(matiere, type) {
            const info = MATIERE_GROUPES_INFO[matiere];
            if (info && info.volumeHTP && info.volumeHTP[type] !== undefined) {
                return info.volumeHTP[type];
            }
            // Fallback aux valeurs par d√©faut si non d√©fini pour la mati√®re
            return DEFAULT_VOLUME_HTP[type] || 0;
        }

        // NOUVEAU: Fonction pour obtenir les mati√®res de la session en cours
       function getMatieresForCurrentSession() {
    const sessionValue = document.getElementById('selectSession').value;
    const currentSession = sessionValue.toLowerCase().includes('automne') ? 'Automne' : 'Printemps';
    
    const filieresDeSession = new Set(
        LISTE_FILIERES
            .filter(f => f.session === currentSession)
            .map(f => f.nom)
    );

    // Inclure :
    // - les mati√®res li√©es √† une fili√®re de la session,
    // - ET les mati√®res sans fili√®re assign√©e (filiere === '' ou undefined) ‚Äî utiles apr√®s import.
    return Object.keys(MATIERE_GROUPES_INFO).filter(matiere => {
        const info = MATIERE_GROUPES_INFO[matiere];
        if (!info) return true; // si pas d'info, on l'inclut par s√©curit√©
        if (!info.filiere) return true; // inclut les mati√®res non assign√©es
        return filieresDeSession.has(info.filiere);
    }).sort();
}

        // MODIFI√â: Fonction d'attribution automatique des enseignants
        // ---------- NOUVEAU: Helper pour d√©tecter le refus explicite d'un type par un enseignant ----------
function teacherRefusesType(enseignant, matiere, type) {
    if (!enseignant || !matiere) return false;
    const wishes = ENSEIGNANT_SOUHAITS[enseignant];
    if (!wishes) return false;

    const normalize = s => {
        if (s === undefined || s === null) return '';
        return String(s).trim().toLowerCase().normalize('NFD').replace(/[\u0300-\u036f]/g, '').replace(/\s+/g, ' ');
    };

    const target = normalize(matiere);

    // Cherche la position du choix (1/2/3) correspondant √† la mati√®re
    let choiceIndex = null;
    for (let i = 1; i <= 3; i++) {
        const key = 'choix' + i;
        if (wishes[key] && normalize(wishes[key]) === target) {
            choiceIndex = i;
            break;
        }
    }
    if (!choiceIndex) return false; // la mati√®re n'est pas dans ses choix -> pas de refus explicite

    const typeKey = (type === 'Cours') ? 'c' : type.toLowerCase(); // 'c' ou 'td' ou 'tp'
    const specificKey = typeKey + choiceIndex; // ex: c1, td2, tp3

    if (wishes.hasOwnProperty(specificKey)) {
        const v = wishes[specificKey];
        if (v === 0 || String(v).trim() === '0' || String(v).trim() === '0.0') return true;
    }
    return false;
}

// Nouvelle version de assignTeachersAutomatically() qui prend en compte teacherRefusesType()
function assignTeachersAutomatically() {
    showSpinner();
    setTimeout(() => {
        const selectedFiliere = document.getElementById('selectEDTView').value;
        let unassignedSessions = seances.filter(s => s.enseignantsArray.length === 0);

        if (selectedFiliere && selectedFiliere !== 'global' && selectedFiliere !== 'enseignant_selectionne') {
            unassignedSessions = unassignedSessions.filter(s => s.filiere === selectedFiliere);
            logMessage(`ü§ñ Lancement de l'attribution auto pour la fili√®re : <strong>${selectedFiliere}</strong>.`, 'initial');
        } else {
            logMessage("ü§ñ Lancement de l'attribution auto pour <strong>toutes les fili√®res</strong>.", 'initial');
        }

        // Prioriser les Cours
        unassignedSessions.sort((a, b) => {
            if (a.type === 'Cours' && b.type !== 'Cours') return -1;
            if (a.type !== 'Cours' && b.type === 'Cours') return 1;
            return 0;
        });
        logMessage("‚ÑπÔ∏è Priorisation des Cours pour l'attribution.", 'initial');

        if (unassignedSessions.length === 0) {
            const message = (selectedFiliere && selectedFiliere !== 'global' && selectedFiliere !== 'enseignant_selectionne')
                ? `Aucune s√©ance non attribu√©e √† traiter pour la fili√®re ${selectedFiliere}.`
                : "Aucune s√©ance non attribu√©e √† traiter.";
            logMessage(`‚ÑπÔ∏è ${message}`, "initial");
            document.getElementById('auto-assign-status').textContent = message;
            hideSpinner();
            return;
        }

        // Pr√©traitement : compte des attributions d√©j√† faites (utile pour c1/td1/tp1)
        const teacherAssignedCounts = {};
        LISTE_ENSEIGNANTS.forEach(ens => {
            teacherAssignedCounts[ens] = {};
            const wishes = ENSEIGNANT_SOUHAITS[ens];
            if (wishes) {
                if (wishes.choix1) teacherAssignedCounts[ens][wishes.choix1] = { Cours: 0, TD: 0, TP: 0 };
                if (wishes.choix2) teacherAssignedCounts[ens][wishes.choix2] = { Cours: 0, TD: 0, TP: 0 };
                if (wishes.choix3) teacherAssignedCounts[ens][wishes.choix3] = { Cours: 0, TD: 0, TP: 0 };
            }
        });
        seances.forEach(s => {
            if (s.enseignantsArray && s.enseignantsArray.length > 0) {
                s.enseignantsArray.forEach(ens => {
                    if (teacherAssignedCounts[ens] && teacherAssignedCounts[ens][s.matiere] && teacherAssignedCounts[ens][s.matiere][s.type] !== undefined) {
                        teacherAssignedCounts[ens][s.matiere][s.type]++;
                    }
                });
            }
        });

        const allVolumes = calculerVolumeHoraire();
        const globalMetrics = calculateGlobalVolumeMetrics();
        const globalVHM = globalMetrics.globalVHM;
        const tolerance = 16;
        const currentSession = document.getElementById('selectSession').value;
        let vhmSession = globalVHM;
        if (currentSession === "Session d'automne") vhmSession = Math.round(globalVHM / 2);
        const maxWorkload = vhmSession + tolerance;

        const sortedCreneauxKeys = getSortedCreneauxKeys();
        let processedSessions = new Set();
        let stopProcessing = false;
        let stopReason = "";
        const failureDetails = [];

        for (const session of unassignedSessions) {
            if (processedSessions.has(session.id) || stopProcessing) continue;

            const htpCredit = getHtpForMatiere(session.matiere, session.type);

            // Si la mati√®re a des candidats potentiels, v√©rifier s'ils sont tous surcharg√©s
            const potentialTeachers = LISTE_ENSEIGNANTS.filter(t => {
                const w = ENSEIGNANT_SOUHAITS[t];
                return w && (w.choix1 === session.matiere || w.choix2 === session.matiere || w.choix3 === session.matiere);
            });
            if (potentialTeachers.length > 0) {
                const allOver = potentialTeachers.every(t => (allVolumes[t] || 0) > vhmSession);
                if (allOver) {
                    stopProcessing = true;
                    stopReason = `Arr√™t car tous les enseignants potentiels pour "${session.matiere}" ont d√©pass√© le VHM (${vhmSession}h).`;
                    break;
                }
            }

            const candidates = [];
            for (const teacher of LISTE_ENSEIGNANTS) {
                if (!isTeacherAvailable(teacher, session.jour, session.creneau, session.type)) continue;

                // Exclure si l'enseignant a explicitement refus√© ce type pour la mati√®re
                if (typeof teacherRefusesType === 'function' && teacherRefusesType(teacher, session.matiere, session.type)) {
                    continue;
                }

                const currentWorkload = allVolumes[teacher] || 0;
                if ((currentWorkload + htpCredit) > maxWorkload) continue;

                const wishes = ENSEIGNANT_SOUHAITS[teacher];
                if (!wishes || (wishes.choix1 !== session.matiere && wishes.choix2 !== session.matiere && wishes.choix3 !== session.matiere)) continue;

                let wishScore = 0;
                let wishFulfillmentScore = 1;
                let choiceKey = null;
                if (wishes.choix1 === session.matiere) { wishScore = 100; choiceKey = '1'; }
                else if (wishes.choix2 === session.matiere) { wishScore = 50; choiceKey = '2'; }
                else if (wishes.choix3 === session.matiere) { wishScore = 25; choiceKey = '3'; }

                const typeKey = session.type === 'Cours' ? 'c' : session.type.toLowerCase();
                const requestedCountKey = typeKey + choiceKey;
                if (wishes.hasOwnProperty(requestedCountKey) && (wishes[requestedCountKey] === 0 || wishes[requestedCountKey] === '0')) {
                    continue;
                }

                const requestedCount = wishes[requestedCountKey] || 0;
                const assignedCount = (teacherAssignedCounts[teacher]?.[session.matiere]?.[session.type]) || 0;
                if (requestedCount > 0 && assignedCount < requestedCount) wishFulfillmentScore = 10;
                else if (requestedCount > 0 && assignedCount >= requestedCount) wishFulfillmentScore = 0.1;

                let consecutiveTdBonus = 0;
                if (session.type === 'TD') {
                    const teacherTdsOnDay = seances.filter(s => s.jour === session.jour && s.enseignantsArray.includes(teacher) && s.type === 'TD' && s.matiere === session.matiere);
                    if (teacherTdsOnDay.length > 0) {
                        const idx = sortedCreneauxKeys.indexOf(session.creneau);
                        if (idx > -1) {
                            const prev = sortedCreneauxKeys[idx - 1], next = sortedCreneauxKeys[idx + 1];
                            const isAdj = (c1, c2) => {
                                if (!c1 || !c2) return false;
                                const i1 = sortedCreneauxKeys.indexOf(c1), i2 = sortedCreneauxKeys.indexOf(c2);
                                return ((i1 <= 1 && i2 <= 1) || (i1 > 1 && i2 > 1));
                            };
                            const prevAdj = teacherTdsOnDay.some(s => s.creneau === prev) && isAdj(session.creneau, prev);
                            const nextAdj = teacherTdsOnDay.some(s => s.creneau === next) && isAdj(session.creneau, next);
                            if (prevAdj || nextAdj) consecutiveTdBonus = 40;
                        }
                    }
                }

                const workloadAvailabilityScore = maxWorkload - currentWorkload;
                const finalScore = (wishScore * wishFulfillmentScore) + workloadAvailabilityScore + consecutiveTdBonus;
                if (finalScore > 0) candidates.push({ name: teacher, score: finalScore });
            }

            candidates.sort((a, b) => b.score - a.score);

            let numTeachersToAssign = 1;
            if (session.type === 'TP') {
                const matiereInfo = MATIERE_GROUPES_INFO[session.matiere];
                numTeachersToAssign = (matiereInfo && matiereInfo.nbEnseignantsTP === 2) ? 2 : 1;
            }

            const assignedTeachers = candidates.slice(0, numTeachersToAssign).map(c => c.name);
            if (assignedTeachers.length === numTeachersToAssign) {
                session.enseignantsArray = assignedTeachers;
                session.enseignant = assignedTeachers.join(' / ');
                processedSessions.add(session.id);
                assignedTeachers.forEach(ens => {
                    if (teacherAssignedCounts[ens] && teacherAssignedCounts[ens][session.matiere] && teacherAssignedCounts[ens][session.matiere][session.type] !== undefined) {
                        teacherAssignedCounts[ens][session.matiere][session.type]++;
                    }
                });
                const htpPourCetteSeance = getHtpForMatiere(session.matiere, session.type);
                if (htpPourCetteSeance > 0) {
                    assignedTeachers.forEach(ens => {
                        let htpCredit = (session.type === 'TP') ? htpPourCetteSeance : (htpPourCetteSeance / assignedTeachers.length);
                        allVolumes[ens] = (allVolumes[ens] || 0) + htpCredit;
                    });
                }
                if (session.type === 'TP' && session.hTP_Affecte > 0) {
                    const nextCreneau = CRENEAUX_COUPLES_SUIVANT[session.creneau];
                    const coupledSession = seances.find(s => s.jour === session.jour && s.creneau === nextCreneau && s.uniqueStudentEntity === session.uniqueStudentEntity && s.type === 'TP' && !processedSessions.has(s.id));
                    if (coupledSession) {
                        coupledSession.enseignantsArray = assignedTeachers;
                        coupledSession.enseignant = assignedTeachers.join(' / ');
                        processedSessions.add(coupledSession.id);
                    }
                }
            } else {
                let reasonHtml = `<ul class='list-disc list-inside ml-4 text-sm'>`;
                const interestedTeachers = [];
                const reasons = { unavailable: [], overloaded: [], typeRejected: [] };
                for (const teacher of LISTE_ENSEIGNANTS) {
                    const wishes = ENSEIGNANT_SOUHAITS[teacher];
                    if (wishes && (wishes.choix1 === session.matiere || wishes.choix2 === session.matiere || wishes.choix3 === session.matiere)) {
                        interestedTeachers.push(teacher);
                        if (!isTeacherAvailable(teacher, session.jour, session.creneau, session.type)) { reasons.unavailable.push(teacher); continue; }
                        const currentWorkload = allVolumes[teacher] || 0;
                        if (currentWorkload >= maxWorkload) { reasons.overloaded.push(`${teacher} (${currentWorkload}h)`); continue; }
                        if (typeof teacherRefusesType === 'function' && teacherRefusesType(teacher, session.matiere, session.type)) { reasons.typeRejected.push(teacher); continue; }
                        let choiceKey = (wishes.choix1 === session.matiere) ? '1' : (wishes.choix2 === session.matiere) ? '2' : '3';
                        const typeKey = session.type === 'Cours' ? 'c' : session.type.toLowerCase();
                        const specificWishKey = typeKey + choiceKey;
                        if (wishes.hasOwnProperty(specificWishKey) && (wishes[specificWishKey] === 0 || wishes[specificWishKey] === '0')) reasons.typeRejected.push(teacher);
                    }
                }
                if (interestedTeachers.length === 0) reasonHtml += "<li>Aucun enseignant n'a cette mati√®re dans ses souhaits.</li>";
                else {
                    if (reasons.unavailable.length > 0) reasonHtml += `<li><strong>Indisponibles sur ce cr√©neau :</strong> ${reasons.unavailable.join(', ')}</li>`;
                    if (reasons.overloaded.length > 0) reasonHtml += `<li><strong>En surcharge horaire (> ${maxWorkload}h) :</strong> ${reasons.overloaded.join(', ')}</li>`;
                    if (reasons.typeRejected.length > 0) reasonHtml += `<li><strong>Ne souhaitent pas ce type de s√©ance :</strong> ${reasons.typeRejected.join(', ')}</li>`;
                    if (session.type === 'TP' && numTeachersToAssign > assignedTeachers.length) reasonHtml += `<li>Nombre insuffisant de candidats trouv√©s pour le TP (requis: ${numTeachersToAssign}, trouv√©: ${assignedTeachers.length}).</li>`;
                    else if (reasons.unavailable.length + reasons.overloaded.length + reasons.typeRejected.length === 0) reasonHtml += `<li>Aucun candidat n'a pu √™tre s√©lectionn√© (potentiellement tous les souhaits sont d√©j√† remplis).</li>`;
                }
                reasonHtml += "</ul>";
                failureDetails.push({ session, reason: reasonHtml });
            }
        }

        hideSpinner();
        failureDetails.forEach(fail => {
            const { session, reason } = fail;
            const logHtml = `‚ùå √âchec d'attribution pour **${session.matiere}** (${session.type}) - ${session.filiere} ${session.groupe} [${session.jour} ${session.creneau}]:${reason}`;
            logMessage(logHtml, 'error');
        });

        const successfullyProcessedCount = processedSessions.size;
        const assignmentsFailed = unassignedSessions.length - successfullyProcessedCount;
        let resultMessage;
        if (stopProcessing) {
            resultMessage = `Arr√™t: ${successfullyProcessedCount} s√©ance(s) pourvue(s), ${assignmentsFailed} √©chec(s).`;
            logMessage(`ü§ñ ${stopReason}`, 'warning');
            logMessage(`ü§ñ ${resultMessage}`, 'initial');
        } else {
            resultMessage = `Termin√©: ${successfullyProcessedCount} s√©ance(s) pourvue(s), ${assignmentsFailed} √©chec(s).`;
            logMessage(`ü§ñ Attribution auto termin√©e. ${resultMessage}`, 'success');
        }
        document.getElementById('auto-assign-status').textContent = resultMessage + " (D√©tails dans les logs)";
        actualiserAffichage();
    }, 50);
}

        // MODIFI√â: Fonction de v√©rification de disponibilit√© (plus robuste)
        function isTeacherAvailable(teacher, jour, creneau, type, seancesAExclureIds = []) {
    if (!teacher) return true; // Pas de nom => pas de contrainte
    // Construit une liste d'IDs √† exclure (√©dition en cours)
    const exclusionSet = new Set(seancesAExclureIds);
    if (currentlyEditingSessionId !== null) {
        exclusionSet.add(currentlyEditingSessionId);
    }
    const seancesAComparer = seances.filter(s => !exclusionSet.has(s.id));

    for (const s of seancesAComparer) {
        if (s.jour !== jour) continue;
        if (!Array.isArray(s.enseignantsArray) || s.enseignantsArray.length === 0) continue;
        if (!s.enseignantsArray.includes(teacher)) continue;

        // Conflit direct: m√™me cr√©neau de d√©part
        if (s.creneau === creneau) return false;

        // Conflits li√©s aux TP coupl√©s (v√©rifier dans les deux sens)
        // Si une s√©ance EXISTANTE est TP et son deuxi√®me cr√©neau co√Øncide avec le cr√©neau de la nouvelle s√©ance
        if (s.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[s.creneau] === creneau) return false;
        // Si la s√©ance √† tester est TP et son deuxi√®me cr√©neau co√Øncide avec le cr√©neau de l'existante
        if (type === 'TP' && CRENEAUX_COUPLES_SUIVANT[creneau] === s.creneau) return false;
    }
    return true;
}

        function suggestTeacher() {
            const matiere = document.getElementById('inputMatiere').value;
            const type = document.getElementById('inputType').value;
            const jour = document.getElementById('inputJour').value;
            const creneau = document.getElementById('inputCreneau').value;

            if (!matiere) {
                logMessage("‚ö†Ô∏è Veuillez d'abord s√©lectionner une mati√®re pour obtenir une suggestion.", 'warning');
                return;
            }

            const allVolumes = calculerVolumeHoraire();
            const globalMetrics = calculateGlobalVolumeMetrics();
            let VHM = globalMetrics.globalVHM;
            const currentSession = document.getElementById('selectSession').value;
            if (currentSession === "Session d'automne") {
                VHM = Math.round(VHM / 2);
            }

            const candidates = [];
            for (const teacher of LISTE_ENSEIGNANTS) {
                // 1. V√©rifier la disponibilit√© de l'enseignant
                if (!isTeacherAvailable(teacher, jour, creneau, type)) {
                    continue;
                }

                const wishes = ENSEIGNANT_SOUHAITS[teacher];
                if (!wishes) {
                    continue;
                }
                
                let wishScore = 0;
                let choiceKey = null; // '1', '2', or '3'

                // 2. V√©rifier si la mati√®re est dans les souhaits et attribuer un score de priorit√©
                if (wishes.choix1 === matiere) { 
                    wishScore = 1000; // Priorit√© maximale pour le choix 1
                    choiceKey = '1';
                } else if (wishes.choix2 === matiere) { 
                    wishScore = 500;  // Priorit√© moyenne pour le choix 2
                    choiceKey = '2';
                } else if (wishes.choix3 === matiere) { 
                    wishScore = 250;  // Priorit√© plus faible pour le choix 3
                    choiceKey = '3';
                } else {
                    // Si la mati√®re n'est dans aucun choix, ignorer cet enseignant
                    continue;
                }

                // 3. V√©rifier la pr√©f√©rence pour le type de s√©ance (Cours, TD, TP)
                const typeKey = type === 'Cours' ? 'c' : type.toLowerCase(); // 'c', 'td', 'tp'
                const specificWishKey = typeKey + choiceKey; // ex: 'c1', 'td2', 'tp3'
                
                // Si l'enseignant a explicitement mis "0" pour ce type de s√©ance, il ne le souhaite pas. On l'exclut.
                if (wishes.hasOwnProperty(specificWishKey) && (wishes[specificWishKey] === 0 || wishes[specificWishKey] === '0')) {
                    continue;
                }
                
                // Bonus si l'enseignant a demand√© au moins une s√©ance de ce type
                let typePreferenceBonus = 0;
                if (wishes.hasOwnProperty(specificWishKey) && wishes[specificWishKey] > 0) {
                    typePreferenceBonus = 200; // Bonus significatif pour la pr√©f√©rence de type
                }

                // 4. Calculer le score final en incluant la charge de travail
                const currentWorkload = allVolumes[teacher] || 0;
                // Ce score favorise les enseignants qui sont en dessous du VHM
                const workloadScore = Math.max(0, VHM - currentWorkload); 

                const finalScore = wishScore + typePreferenceBonus + workloadScore;
                
                if (finalScore > 0) {
                    candidates.push({ name: teacher, score: finalScore });
                }
            }
            
            candidates.sort((a, b) => b.score - a.score);

            const enseignant1Select = document.getElementById('inputEnseignant1');
            const enseignant2Select = document.getElementById('inputEnseignant2');
            const currentEnseignant1 = enseignant1Select.value;
            const currentEnseignant2 = enseignant2Select.value;

            // Filtrer les candidats qui ne sont pas d√©j√† dans la case "Enseignant 2"
            const eligibleCandidates = candidates.filter(c => !currentEnseignant2 || c.name !== currentEnseignant2);

            if (eligibleCandidates.length === 0) {
                logMessage("‚ÑπÔ∏è Aucun autre enseignant int√©ress√© et disponible n'a √©t√© trouv√©.", 'initial');
                return;
            }

            let nextCandidate = null;

            if (!currentEnseignant1) {
                // Si la case Enseignant 1 est vide, on prend le meilleur candidat √©ligible.
                nextCandidate = eligibleCandidates[0];
            } else {
                // Sinon, on cherche le candidat actuel dans la liste des √©ligibles pour trouver le suivant.
                const currentIndex = eligibleCandidates.findIndex(c => c.name === currentEnseignant1);

                if (currentIndex === -1) {
                    // Si l'enseignant actuel n'est plus √©ligible, on repart du d√©but de la liste.
                    nextCandidate = eligibleCandidates[0];
                } else {
                    // On prend le prochain dans la liste, en bouclant si on arrive √† la fin.
                    const nextIndex = (currentIndex + 1) % eligibleCandidates.length;
                    nextCandidate = eligibleCandidates[nextIndex];
                }
            }

            if (nextCandidate) {
                enseignant1Select.value = nextCandidate.name;
                logMessage(`üí° Suggestion: **${nextCandidate.name}** a √©t√© s√©lectionn√©(e) (Score: ${Math.round(nextCandidate.score)}).`, 'success');
                // D√©clencher l'√©v√©nement de changement pour mettre √† jour l'interface (volumes, etc.)
                enseignant1Select.dispatchEvent(new Event('change'));
            }
        }

        // NOUVEAU: Suggestion pour l'enseignant 2 (pour les TP)
        function suggestTeacher2() {
            const matiere = document.getElementById('inputMatiere').value;
            const type = document.getElementById('inputType').value;
            const jour = document.getElementById('inputJour').value;
            const creneau = document.getElementById('inputCreneau').value;

            if (!matiere) {
                logMessage("‚ö†Ô∏è Veuillez d'abord s√©lectionner une mati√®re.", 'warning');
                return;
            }

            const allVolumes = calculerVolumeHoraire();
            const globalMetrics = calculateGlobalVolumeMetrics();
            let VHM = globalMetrics.globalVHM;
            const currentSession = document.getElementById('selectSession').value;
            if (currentSession === "Session d'automne") {
                VHM = Math.round(VHM / 2);
            }

            const candidates = [];
            for (const teacher of LISTE_ENSEIGNANTS) {
                if (!isTeacherAvailable(teacher, jour, creneau, type)) continue;

                const wishes = ENSEIGNANT_SOUHAITS[teacher];
                if (!wishes) continue;
                
                let wishScore = 0;
                let choiceKey = null;

                if (wishes.choix1 === matiere) { wishScore = 1000; choiceKey = '1'; }
                else if (wishes.choix2 === matiere) { wishScore = 500; choiceKey = '2'; }
                else if (wishes.choix3 === matiere) { wishScore = 250; choiceKey = '3'; }
                else { continue; }

                const typeKey = type.toLowerCase();
                const specificWishKey = typeKey + choiceKey;
                if (wishes.hasOwnProperty(specificWishKey) && (wishes[specificWishKey] === 0 || wishes[specificWishKey] === '0')) {
                    continue;
                }
                
                let typePreferenceBonus = 0;
                if (wishes.hasOwnProperty(specificWishKey) && wishes[specificWishKey] > 0) {
                    typePreferenceBonus = 200;
                }

                const currentWorkload = allVolumes[teacher] || 0;
                const workloadScore = Math.max(0, VHM - currentWorkload);
                const finalScore = wishScore + typePreferenceBonus + workloadScore;
                
                if (finalScore > 0) {
                    candidates.push({ name: teacher, score: finalScore });
                }
            }
            
            candidates.sort((a, b) => b.score - a.score);

            const enseignant1Select = document.getElementById('inputEnseignant1');
            const enseignant2Select = document.getElementById('inputEnseignant2');
            const currentEnseignant1 = enseignant1Select.value;
            const currentEnseignant2 = enseignant2Select.value;

            // Filtrer le candidat qui est d√©j√† dans la case "Enseignant 1"
            const eligibleCandidates = candidates.filter(c => !currentEnseignant1 || c.name !== currentEnseignant1);

            if (eligibleCandidates.length === 0) {
                logMessage("‚ÑπÔ∏è Aucun autre enseignant int√©ress√© et disponible n'a √©t√© trouv√©.", 'initial');
                return;
            }

            let nextCandidate = null;

            if (!currentEnseignant2) {
                nextCandidate = eligibleCandidates[0];
            } else {
                const currentIndex = eligibleCandidates.findIndex(c => c.name === currentEnseignant2);
                if (currentIndex === -1) {
                    nextCandidate = eligibleCandidates[0];
                } else {
                    const nextIndex = (currentIndex + 1) % eligibleCandidates.length;
                    nextCandidate = eligibleCandidates[nextIndex];
                }
            }

            if (nextCandidate) {
                enseignant2Select.value = nextCandidate.name;
                logMessage(`üí° Suggestion (Ens. 2): **${nextCandidate.name}** a √©t√© s√©lectionn√©(e) (Score: ${Math.round(nextCandidate.score)}).`, 'success');
                enseignant2Select.dispatchEvent(new Event('change'));
            }
        }

        // NOUVEAU: Met en surbrillance les enseignants int√©ress√©s dans les listes d√©roulantes
        function updateEnseignantSelects() {
            const matiere = document.getElementById('inputMatiere').value;
            const interestedTeachers = new Set();

            if (matiere) {
                for (const enseignant in ENSEIGNANT_SOUHAITS) {
                    const wishes = ENSEIGNANT_SOUHAITS[enseignant];
                    if (wishes.choix1 === matiere || wishes.choix2 === matiere || wishes.choix3 === matiere) {
                        interestedTeachers.add(enseignant);
                    }
                }
            }

            const selects = [document.getElementById('inputEnseignant1'), document.getElementById('inputEnseignant2')];
            selects.forEach(select => {
                for (const option of select.options) {
                    // R√©initialiser le style et le texte
                    option.classList.remove('enseignant-interesse');
                    if (option.value) {
                        option.textContent = option.value; // R√©initialise au nom de base
                    }

                    // Appliquer le style et le pr√©fixe si int√©ress√©
                    if (option.value && interestedTeachers.has(option.value)) {
                        option.classList.add('enseignant-interesse');
                        option.textContent = `‚òÖ ${option.value}`; // Ajoute un indicateur visuel
                    }
                }
            });
        }
        
        // NOUVEAU: Fonctions pour g√©rer la validation et l'affichage des erreurs du formulaire
        function clearFormErrors() {
            const form = document.getElementById('attributionForm');
            form.querySelectorAll('.input-error').forEach(el => el.classList.remove('input-error'));
        }

        function highlightFormErrors(fieldIds) {
            fieldIds.forEach(id => {
                const element = document.getElementById(id);
                if (element) {
                    element.classList.add('input-error');
                }
            });
        }

        function validerFormulaire() {
            clearFormErrors();

            const data = {
                filiere: { value: document.getElementById('inputFiliere').value, id: 'inputFiliere' },
                matiere: { value: document.getElementById('inputMatiere').value, id: 'inputMatiere' },
                type: { value: document.getElementById('inputType').value, id: 'inputType' },
                salle: { value: document.getElementById('inputSalle').value, id: 'inputSalle' },
                section: { value: document.getElementById('inputSection').value, id: 'inputSection' },
                groupeTDTP: { value: document.getElementById('inputGroupeTDTP').value, id: 'inputGroupeTDTP' }
            };

            const requiredFields = {
                'Fili√®re': data.filiere,
                'Mati√®re': data.matiere,
                'Type': data.type,
                // 'Salle': data.salle, // <- Retir√© de la d√©finition initiale
                'Section': data.section
            };
            
            // CORRECTION: N'exiger la salle que si le type N'EST PAS 'TP'
            if (data.type.value !== 'TP') {
                requiredFields['Salle'] = data.salle;
            }

            if (data.type.value === 'TD' || data.type.value === 'TP') {
                requiredFields['Groupe (TD/TP)'] = data.groupeTDTP;
            }

            const missingFields = Object.entries(requiredFields)
                .filter(([key, field]) => !field.value)
                .map(([key, field]) => ({ name: key, id: field.id }));

            if (missingFields.length > 0) {
                const missingFieldIds = missingFields.map(f => f.id);
                const missingFieldNames = missingFields.map(f => f.name);
                
                highlightFormErrors(missingFieldIds);
                
                showCustomDialog({
                    title: 'Informations Manquantes',
                    htmlMessage: `Veuillez remplir les champs en surbrillance rouge : <strong>${missingFieldNames.join(', ')}</strong>.`
                });
                return { isValid: false };
            }

            return { isValid: true };
        }

        // NOUVEAU: Fonctions pour g√©rer le spinner
        function showSpinner() {
            document.getElementById('loading-overlay').style.display = 'flex';
        }

        function hideSpinner() {
            document.getElementById('loading-overlay').style.display = 'none';
        }

        function getSessionSpecificKey(baseKey) {
            const session = document.getElementById('selectSession').value.replace(/\s+/g, '_');
            if (!session) return baseKey;
            return `${baseKey}_${session}`;
        }

        // NOUVEAU: Helper pour trouver l'index de la colonne s√©paratrice
        function getSeparatorColumnIndex() {
            const sortedCreneaux = getSortedCreneauxKeys();
            const separatorAfter = '10h15';
            const index = sortedCreneaux.indexOf(separatorAfter);
            // +1 car les cr√©neaux commencent √† la colonne 1 (colonne 0 = Jour)
            // +1 pour la colonne s√©paratrice elle-m√™me
            return index !== -1 ? index + 2 : -1;
        }

        function getSortedCreneauxKeys() {
            return Object.keys(LISTE_CRENEAUX).sort((a, b) => {
                const timeA = a.replace('h', ':');
                const timeB = b.replace('h', ':');
                return new Date('1970/01/01 ' + timeA) - new Date('1970/01/01 ' + timeB);
            });
        }

        function sauvegarderTravail() {
            const seancesToSave = seances.map(s => {
                if (!s.filiere) s.filiere = 'Fili√®re Inconnue'; 
                if (!s.uniqueStudentEntity) {
                    const type = s.type;
                    const filiere = s.filiere;
                    const section = s.section || 'N/A';
                    const groupeTDTP = s.groupe.split(' - ').length > 1 ? s.groupe.split(' - ')[1] : '';
                    s.uniqueStudentEntity = (type === 'TD' || type === 'TP') 
                        ? `${filiere} - ${section} - ${groupeTDTP}` 
                        : `${filiere} - ${section}`;
                }
                return s;
            });
            
            localStorage.setItem(getSessionSpecificKey('edt_physique_seances'), JSON.stringify(seancesToSave));
            localStorage.setItem(getSessionSpecificKey('edt_physique_nextId'), nextSessionId);
            
            localStorage.setItem('edt_physique_enseignants', JSON.stringify(LISTE_ENSEIGNANTS));
            localStorage.setItem('edt_physique_salles_info', JSON.stringify(SALLES_INFO));
            localStorage.setItem('edt_physique_enseignant_souhaits', JSON.stringify(ENSEIGNANT_SOUHAITS));
            localStorage.setItem('edt_physique_matiere_groupes_info', JSON.stringify(MATIERE_GROUPES_INFO));
            localStorage.setItem('edt_physique_filieres', JSON.stringify(LISTE_FILIERES)); 
            localStorage.setItem('edt_physique_volumes_supplementaires', JSON.stringify(ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES));
            localStorage.setItem('edt_physique_creneaux', JSON.stringify(LISTE_CRENEAUX));
            localStorage.setItem('edt_physique_volumes_automne', JSON.stringify(VOLUMES_AUTOMNE));
            
            localStorage.setItem('edt_header_annee', document.getElementById('inputAnneeUniversitaire').value);
            localStorage.setItem('edt_header_session', document.getElementById('selectSession').value);
            localStorage.setItem('edt_header_departement', document.getElementById('selectDepartement').value);

            logMessage(`‚úÖ Travail pour la session en cours enregistr√©.`, 'success');
        }

        function chargerTravail() {
            const anneeSauvee = localStorage.getItem('edt_header_annee');
            const sessionSauvee = localStorage.getItem('edt_header_session');
            const deptSauve = localStorage.getItem('edt_header_departement');
            
            const currentYear = new Date().getFullYear();

            const currentMonth = new Date().getMonth();
            let sessionParDefaut;
            if (currentMonth >= 8 || currentMonth === 0) {
                sessionParDefaut = "Session d'automne";
            } 
            else if (currentMonth >= 1 && currentMonth <= 5) {
                sessionParDefaut = "Session de printemps";
            } 
            else {
                sessionParDefaut = "Session d'automne";
            }

            document.getElementById('inputAnneeUniversitaire').value = anneeSauvee || `${currentYear}/${currentYear + 1}`;
            document.getElementById('selectSession').value = sessionSauvee || sessionParDefaut;
            document.getElementById('selectDepartement').value = deptSauve || "D√©partement de physique";

            const savedCreneaux = localStorage.getItem('edt_physique_creneaux');
            LISTE_CRENEAUX = savedCreneaux ? JSON.parse(savedCreneaux) : JSON.parse(JSON.stringify(DEFAULT_CRENEAUX));

            const savedEnseignants = localStorage.getItem('edt_physique_enseignants');
            const savedSallesInfo = localStorage.getItem('edt_physique_salles_info');
            const savedSouhaits = localStorage.getItem('edt_physique_enseignant_souhaits');
            const savedMatiereGroupes = localStorage.getItem('edt_physique_matiere_groupes_info');
            const savedFiliere = localStorage.getItem('edt_physique_filieres');
            const savedVolumesSup = localStorage.getItem('edt_physique_volumes_supplementaires');
            const savedVolumesAutomne = localStorage.getItem('edt_physique_volumes_automne');
            
            LISTE_ENSEIGNANTS = savedEnseignants ? JSON.parse(savedEnseignants) : [...DEFAULT_ENSEIGNANTS].sort();
            SALLES_INFO = savedSallesInfo ? JSON.parse(savedSallesInfo) : {...DEFAULT_SALLES_INFO};
            ENSEIGNANT_SOUHAITS = savedSouhaits ? JSON.parse(savedSouhaits) : {};
            // MODIFI√â: Logique de chargement des fili√®res avec migration pour l'ancien format
            if (savedFiliere) {
                let parsedFiliere = JSON.parse(savedFiliere);
                // V√©rifie si c'est l'ancien format (un tableau de cha√Ænes)
                if (parsedFiliere.length > 0 && typeof parsedFiliere[0] === 'string') {
                    // Migre vers le nouveau format d'objet, en assignant 'Automne' par d√©faut
                    LISTE_FILIERES = parsedFiliere.map(f => ({ nom: f, session: 'Automne' }));
                    logMessage("üîß Les donn√©es des fili√®res ont √©t√© migr√©es vers le nouveau format.", 'initial');
                } else {
                    LISTE_FILIERES = parsedFiliere;
                }
            } else {
                LISTE_FILIERES = [...DEFAULT_FILIERES];
            }
            ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES = savedVolumesSup ? JSON.parse(savedVolumesSup) : {};
            VOLUMES_AUTOMNE = savedVolumesAutomne ? JSON.parse(savedVolumesAutomne) : {};

            if (savedMatiereGroupes) {
                 MATIERE_GROUPES_INFO = JSON.parse(savedMatiereGroupes);
                 for(const matiere in MATIERE_GROUPES_INFO) {
                     if (MATIERE_GROUPES_INFO[matiere].sections_cours === undefined) {
                         MATIERE_GROUPES_INFO[matiere] = { filiere: '', sections_cours: 0, td_groups: 0, tp_groups: 0 };
                     }
                     if (MATIERE_GROUPES_INFO[matiere].filiere === undefined) {
                         MATIERE_GROUPES_INFO[matiere].filiere = '';
                     }
                      // NOUVEAU: Logique de migration pour ajouter les volumes hTP s'ils manquent
                     if (MATIERE_GROUPES_INFO[matiere].volumeHTP === undefined) {
                         MATIERE_GROUPES_INFO[matiere].volumeHTP = { ...DEFAULT_VOLUME_HTP };
                     }
                     // NOUVEAU: Logique de migration pour ajouter nbEnseignantsTP s'il manque
                     if (MATIERE_GROUPES_INFO[matiere].nbEnseignantsTP === undefined) {
                         MATIERE_GROUPES_INFO[matiere].nbEnseignantsTP = 1; // Default to 1 teacher
                     }
                 }
            } else {
                MATIERE_GROUPES_INFO = {...DEFAULT_MATIERE_GROUPES_INFO};
            }
            LISTE_MATIERES = Object.keys(MATIERE_GROUPES_INFO).sort();

            seances = [];
            nextSessionId = 1;
            const savedSeances = localStorage.getItem(getSessionSpecificKey('edt_physique_seances'));
            const nextIdSaved = localStorage.getItem(getSessionSpecificKey('edt_physique_nextId'));
            
            if (savedSeances) {
                seances = JSON.parse(savedSeances).map(s => {
                    return s;
                });
                const maxId = seances.reduce((max, s) => Math.max(max, s.id || 0), 0);
                nextSessionId = maxId + 1;
                logMessage(`‚úÖ ${seances.length} s√©ances charg√©es pour la session en cours.`, 'success');
            } else {
                logMessage("Aucune sauvegarde trouv√©e pour cette session. D√©marrage vierge.", 'initial');
            }
            if (nextIdSaved) {
                nextSessionId = parseInt(nextIdSaved, 10);
            }
        }
        
        function supprimerSeance(id) {
            const seanceToDelete = seances.find(s => s.id === id);
            if (!seanceToDelete) return;

            const initialLength = seances.length;
            let sessionsToDelete = [id];

            // Check if it's the FIRST part of a TP
            if (seanceToDelete.type === 'TP' && seanceToDelete.hTP_Affecte > 0 && CRENEAUX_COUPLES_SUIVANT.hasOwnProperty(seanceToDelete.creneau)) {
                const nextCreneau = CRENEAUX_COUPLES_SUIVANT[seanceToDelete.creneau];
                // RELAXED COUPLING CHECK: Only check type, student entity, day, and next creneau
                const coupledSession = seances.find(s =>
                    s.jour === seanceToDelete.jour &&
                    s.creneau === nextCreneau &&
                    s.uniqueStudentEntity === seanceToDelete.uniqueStudentEntity &&
                    // s.enseignantsArray.every((ens, i) => ens === seanceToDelete.enseignantsArray[i]) && // Removed strict teacher check
                    // s.salle === seanceToDelete.salle && // Removed strict salle check
                    s.type === seanceToDelete.type
                );
                if (coupledSession) {
                    sessionsToDelete.push(coupledSession.id);
                    logMessage(`‚ÑπÔ∏è Suppression du cr√©neau TP coupl√© de ${nextCreneau} (trouv√© par jour/cr√©neau/groupe/type).`, 'initial');
                } else {
                     logMessage(`‚ö†Ô∏è Impossible de trouver le cr√©neau TP coupl√© pour ${seanceToDelete.jour} ${nextCreneau} / ${seanceToDelete.uniqueStudentEntity}. Suppression simple effectu√©e.`, 'warning');
                }
            }
            // Check if it's the SECOND part of a TP
            else if (seanceToDelete.type === 'TP' && seanceToDelete.hTP_Affecte === 0) {
                const prevCreneau = Object.keys(CRENEAUX_COUPLES_SUIVANT).find(k => CRENEAUX_COUPLES_SUIVANT[k] === seanceToDelete.creneau);
                if (prevCreneau) {
                     // RELAXED COUPLING CHECK
                     const firstPartSession = seances.find(s =>
                        s.jour === seanceToDelete.jour &&
                        s.creneau === prevCreneau &&
                        s.uniqueStudentEntity === seanceToDelete.uniqueStudentEntity &&
                        s.type === seanceToDelete.type
                    );
                    if (firstPartSession) {
                        sessionsToDelete.push(firstPartSession.id);
                        logMessage(`‚ÑπÔ∏è Suppression de la premi√®re partie TP (${prevCreneau}) d√©tect√©e (trouv√© par jour/cr√©neau/groupe/type).`, 'initial');
                    } else {
                        logMessage(`‚ö†Ô∏è Impossible de trouver la premi√®re partie TP pour ${seanceToDelete.jour} ${prevCreneau} / ${seanceToDelete.uniqueStudentEntity}. Suppression simple effectu√©e.`, 'warning');
                    }
                }
            }


            seances = seances.filter(s => !sessionsToDelete.includes(s.id));

            if (seances.length < initialLength) {
                logMessage(`üóëÔ∏è ${sessionsToDelete.length} s√©ance(s) supprim√©e(s).`, 'success');
                actualiserAffichage(); // Refresh needed after deletion
            }
        }
        
        function calculerDetailsVolume(enseignant, seancesList, volumesSupplementairesData) {
            let volumeEnseignement = 0;
            seancesList.forEach(seance => {
                if (seance.hTP_Affecte > 0 && seance.enseignantsArray.includes(enseignant)) { 
                    const teachers = seance.enseignantsArray || [seance.enseignant];
                    const hTP_base = seance.hTP_Affecte; 
                    let hTP_credit_per_teacher = (seance.type === 'TP') ? hTP_base : (hTP_base / teachers.length);
                    volumeEnseignement += hTP_credit_per_teacher;
                }
            });

            let volumeSupplementaire = 0;
            if (volumesSupplementairesData[enseignant]) {
                volumesSupplementairesData[enseignant].forEach(item => {
                    volumeSupplementaire += item.volume;
                });
            }

            return {
                enseignement: parseFloat(volumeEnseignement.toFixed(0)),
                forfait: parseFloat(volumeSupplementaire.toFixed(0)),
                total: parseFloat((volumeEnseignement + volumeSupplementaire).toFixed(0))
            };
        }

        function calculerVolumeHoraire() {
            const volumehTP = {};
            const currentSession = document.getElementById('selectSession').value;

            LISTE_ENSEIGNANTS.forEach(ens => {
                // On calcule d'abord les d√©tails pour la session courante
                const details = calculerDetailsVolume(ens, seances, ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES);
                let volumeTotalPourSession = details.enseignement; // On commence avec les heures d'enseignement

                // Le volume suppl√©mentaire n'est ajout√© QUE pour la session d'automne
                if (currentSession === "Session d'automne") {
                    volumeTotalPourSession += details.forfait;
                }

                // Si on est au printemps, on ajoute le volume total (enseignement + forfait) de l'automne
                if (currentSession === "Session de printemps") {
                    if (VOLUMES_AUTOMNE[ens]) {
                        volumeTotalPourSession += VOLUMES_AUTOMNE[ens];
                    }
                }
                volumehTP[ens] = volumeTotalPourSession;
            });

            return volumehTP;
        }

        function getEnseignantsCountForMatiere(matiere) {
            const teachers = new Set();
            seances.forEach(s => {
                if (s.matiere === matiere) {
                    s.enseignantsArray.forEach(ens => teachers.add(ens));
                }
            });
            return teachers.size;
        }

        function calculatePerMatiereVolumeMetrics(matiere) {
            const H_SECTION_COURS = getHtpForMatiere(matiere, 'Cours');
            const H_GROUPE_TD = getHtpForMatiere(matiere, 'TD');
            const H_GROUPE_TP = getHtpForMatiere(matiere, 'TP'); // Base hTP pour 1 groupe TP (1h30)
            
            const info = MATIERE_GROUPES_INFO[matiere];
            
            if (!info) {
                 // Si pas d'info, retourner 0
                 return { total: 0, nombreEnseignants: 0, nombreEnseignantsTotal: LISTE_ENSEIGNANTS.length, moyen: 0 };
            }
            
            const sections = info.sections_cours || 0;
            const groupesTD = info.td_groups || 0;
            const groupesTP = info.tp_groups || 0;
            // NOUVEAU: Utiliser le nombre d'enseignants configur√© pour les TP (d√©faut 1 si non d√©fini)
            const nbEnseignantsParTP = info.nbEnseignantsTP || 1; 
            
            // MODIFI√â: Calcul du volume TP (retrait du * 2)
            // Volume Cours = Nb Sections * hTP Cours
            const volumeCours = sections * H_SECTION_COURS;
            // Volume TD = Nb Sections * Nb Groupes TD * hTP TD
            const volumeTD = sections * groupesTD * H_GROUPE_TD;
            // Volume TP = Nb Sections * Nb Groupes TP * hTP TP (pour 1h30) * Nb Enseignants par TP
            const volumeTP = sections * groupesTP * H_GROUPE_TP * nbEnseignantsParTP; // Retrait de '* 2'
            
            // Calcul du VHT total pour la mati√®re
            const volumeHoraireTotal = volumeCours + volumeTD + volumeTP;

            const nombreEnseignantsAttribues = getEnseignantsCountForMatiere(matiere); 

            const nombreEnseignantsTotal = LISTE_ENSEIGNANTS.length;
            
            let volumeHoraireMoyen = 0;
            if (nombreEnseignantsTotal > 0) {
                // Le VHM reste calcul√© sur le VHT total divis√© par TOUS les enseignants enregistr√©s
                volumeHoraireMoyen = Math.round(volumeHoraireTotal / nombreEnseignantsTotal);
            }
            
            return {
                total: volumeHoraireTotal,
                nombreEnseignants: nombreEnseignantsAttribues,
                nombreEnseignantsTotal: nombreEnseignantsTotal,
                moyen: volumeHoraireMoyen
            };
        }

        function calculateGlobalVolumeMetrics() {
            let globalVHT = 0;
            const allAttributedTeachers = new Set();
            
            for (const matiere in MATIERE_GROUPES_INFO) {
                const info = MATIERE_GROUPES_INFO[matiere];
                
                const H_SECTION_COURS = getHtpForMatiere(matiere, 'Cours');
                const H_GROUPE_TD = getHtpForMatiere(matiere, 'TD');
                const H_GROUPE_TP = getHtpForMatiere(matiere, 'TP'); // Base hTP pour 1 groupe TP (1h30)
                
                const sections = info.sections_cours || 0;
                const groupesTD = info.td_groups || 0;
                const groupesTP = info.tp_groups || 0;
                // NOUVEAU: Utiliser le nombre d'enseignants configur√© pour les TP (d√©faut 1 si non d√©fini)
                const nbEnseignantsParTP = info.nbEnseignantsTP || 1; 

                // MODIFI√â: Calcul du VHT de la mati√®re en incluant le nb d'enseignants TP (retrait du * 2)
                const matterVHT = sections * (
                    H_SECTION_COURS + 
                    (groupesTD * H_GROUPE_TD) + 
                    (groupesTP * H_GROUPE_TP * nbEnseignantsParTP) // hTP * nb Ens par TP. Retrait de '* 2'
                );

                globalVHT += matterVHT;
            }

            // Le volume suppl√©mentaire (forfaitaire) est ajout√© au VHT global
            for (const enseignant in ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES) {
                ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignant].forEach(item => {
                    globalVHT += item.volume;
                });
            }

            seances.forEach(s => {
                s.enseignantsArray.forEach(ens => allAttributedTeachers.add(ens));
            });
            
            const totalUniqueTeachers = allAttributedTeachers.size;

            const totalRegisteredTeachers = LISTE_ENSEIGNANTS.length;

            let globalVHM = 0;
            if (totalRegisteredTeachers > 0) {
                 // Le VHM global reste calcul√© sur le VHT total divis√© par TOUS les enseignants enregistr√©s
                globalVHM = Math.round(globalVHT / totalRegisteredTeachers);
            }
            
            return {
                globalVHT: globalVHT,
                totalUniqueTeachers: totalUniqueTeachers,
                totalRegisteredTeachers: totalRegisteredTeachers,
                globalVHM: globalVHM
            };
        }

        function calculerGroupesPlanifi√©s(seancesList) {
            const plannedGroups = {};

            seancesList.forEach(seance => {
                // On compte une s√©ance si elle est planifi√©e, peu importe si un enseignant est attribu√©
                if (seance.type === 'Cours' || seance.type === 'TD' || seance.type === 'TP') {
                    const matiere = seance.matiere;
                    const type = seance.type;
                    const uniqueGroup = seance.uniqueStudentEntity;

                    if (!plannedGroups[matiere]) {
                        plannedGroups[matiere] = { Cours: new Set(), TD: new Set(), TP: new Set() };
                    }

                    if (plannedGroups[matiere][type]) {
                        plannedGroups[matiere][type].add(uniqueGroup);
                    }
                }
            });

            const result = {};
            for (const matiere in plannedGroups) {
                // MODIFI√â: Renvoie les Sets directement au lieu de leur taille
                result[matiere] = {
                    Cours: plannedGroups[matiere].Cours, // Renvoie le Set
                    TD: plannedGroups[matiere].TD,    // Renvoie le Set
                    TP: plannedGroups[matiere].TP     // Renvoie le Set
                };
            }
            return result;
        }

        function calculerGroupesAttribu√©s(seancesList) {
            const attributedGroups = {};

            // MODIFI√â: Seules les s√©ances avec au moins un enseignant attribu√© sont comptabilis√©es.
            seancesList.forEach(seance => {
                if ((seance.enseignantsArray && seance.enseignantsArray.length > 0) && (seance.type === 'Cours' || seance.type === 'TD' || seance.type === 'TP')) {
                    const matiere = seance.matiere;
                    const type = seance.type;
                    const uniqueGroup = seance.uniqueStudentEntity;

                    if (!attributedGroups[matiere]) {
                        attributedGroups[matiere] = { Cours: new Set(), TD: new Set(), TP: new Set(), TP_Enseignants: 0 };
                    }

                    if (attributedGroups[matiere][type]) {
                        attributedGroups[matiere][type].add(uniqueGroup);
                        if (type === 'TP') {
                            if (seance.hTP_Affecte > 0 && seance.enseignantsArray) { // V√©rification ajout√©e pour la s√©curit√©
                                attributedGroups[matiere].TP_Enseignants += seance.enseignantsArray.length;
                            }
                        }
                    }
                }
            });

            const result = {};
            for (const matiere in attributedGroups) {
                result[matiere] = {
                    Cours: attributedGroups[matiere].Cours.size,
                    TD: attributedGroups[matiere].TD.size,
                    TP: attributedGroups[matiere].TP.size,
                    TP_Enseignants: attributedGroups[matiere].TP_Enseignants
                };
            }
            return result;
        }

        function updateGroupesAttribu√©sDisplay(attributedGroups) {
            const displayDiv = document.getElementById('groupeAttributionBody');
            displayDiv.innerHTML = ''; 

            // NOUVEAU: Filtrer les mati√®res pour ne montrer que celles de la session actuelle
            const sessionValue = document.getElementById('selectSession').value;
            const currentSession = sessionValue.toLowerCase().includes('automne') ? 'Automne' : 'Printemps';
            const filieresDeSession = new Set(
                LISTE_FILIERES
                    .filter(f => f.session === currentSession)
                    .map(f => f.nom)
            );

            const matieresDeLaSession = LISTE_MATIERES.filter(matiere => {
                const info = MATIERE_GROUPES_INFO[matiere];
                // Afficher si la mati√®re est li√©e √† une fili√®re de la session, ou si elle n'est li√©e √† aucune fili√®re
                return !info.filiere || filieresDeSession.has(info.filiere);
            }).sort();

            let html = `
                <table style="width: 100%; font-size: 0.9em; border-collapse: collapse;">
                    <thead>
                        <tr style="background-color: #e6f2ff;">
                            <th style="padding: 5px; border: 1px solid #ccc; text-align: left;">Mati√®re</th>
                            <th style="padding: 5px; border: 1px solid #ccc;">Statut Cours</th>
                            <th style="padding: 5px; border: 1px solid #ccc;">Statut TD</th>
                            <th style="padding: 5px; border: 1px solid #ccc;">Statut TP (Ens.)</th>
                        </tr>
                    </thead>
                    <tbody>
            `;

            // MODIFI√â: It√©ration sur la liste filtr√©e des mati√®res
            matieresDeLaSession.forEach(matiere => {
                const info = MATIERE_GROUPES_INFO[matiere] || { sections_cours: 0, td_groups: 0, tp_groups: 0 };
                
                const totalCours = info.sections_cours; 
                const totalTD = info.td_groups * totalCours; 
                const totalTP = info.tp_groups * totalCours; 
                
                const attributed = attributedGroups[matiere] || { Cours: 0, TD: 0, TP: 0, TP_Enseignants: 0 };
                const currentCours = attributed.Cours;
                const currentTD = attributed.TD;
                const currentTP = attributed.TP;
                const currentTPE = attributed.TP_Enseignants;

                const getStatusStyle = (current, total) => {
                    if (total === 0) return 'color: #999;'; 
                    if (current > total) return 'color: red; font-weight: bold; background-color: #ffe6e6;'; 
                    if (current > 0 && current === total) return 'color: green; font-weight: bold; background-color: #e6ffe6;'; 
                    if (current > 0 && current < total) return 'color: orange;'; 
                    return 'color: #777;'; 
                };

                const tpText = `${currentTP} / ${totalTP} (${currentTPE})`;

                html += `
                    <tr>
                        <td style="padding: 5px; border: 1px solid #ccc; text-align: left;">${matiere}</td>
                        <td style="padding: 5px; border: 1px solid #ccc; text-align: center; ${getStatusStyle(currentCours, totalCours)}">${currentCours} / ${totalCours}</td>
                        <td style="padding: 5px; border: 1px solid #ccc; text-align: center; ${getStatusStyle(currentTD, totalTD)}">${currentTD} / ${totalTD}</td>
                        <td style="padding: 5px; border: 1px solid #ccc; text-align: center; ${getStatusStyle(currentTP, totalTP)}">${tpText}</td>
                    </tr>
                `;
            });

            html += '</tbody></table>';
            displayDiv.innerHTML = html;
        }
function chargerSouhaitsExcel(event) {
    const file = event.target.files && event.target.files[0];
    if (!file) return;

    if (typeof XLSX === 'undefined') {
        logMessage("‚ùå ERREUR: La librairie SheetJS (xlsx.full.min.js) n'est pas charg√©e.", 'error');
        document.getElementById('importStatus').textContent = "Librairie XLSX manquante.";
        event.target.value = '';
        return;
    }

    showSpinner();
    document.getElementById('importStatus').textContent = "Lecture du fichier...";

    const reader = new FileReader();

    reader.onload = function(e) {
        try {
            const data = new Uint8Array(e.target.result);
            const workbook = XLSX.read(data, { type: 'array' });
            const sheetName = workbook.SheetNames[0];
            if (!sheetName) throw new Error("Aucune feuille trouv√©e dans le fichier.");

            const worksheet = workbook.Sheets[sheetName];

            // Premi√®re tentative : lire en objets via sheet_to_json (cas standard)
            let rows = XLSX.utils.sheet_to_json(worksheet, { defval: '' });

            // Si la lecture renvoie [] ou les cl√©s ne ressemblent pas √† des en-t√™tes, essayer detection d'en-t√™te dans les premi√®res lignes
            if (!rows || rows.length === 0 || (rows[0] && Object.keys(rows[0]).length === 0)) {
                // Lire en mode array-of-arrays pour d√©tecter la ligne d'en-t√™te r√©elle
                const aoa = XLSX.utils.sheet_to_json(worksheet, { header: 1, defval: '' });
                if (!aoa || aoa.length === 0) throw new Error("Feuille vide ou illisible.");

                // Chercher la ligne contenant des mots-cl√©s probables (nom, enseignant, matiere)
                const headerIndex = aoa.findIndex(r => r && r.some(c => {
                    if (c === null || c === undefined) return false;
                    const s = String(c).toLowerCase();
                    return /nom|enseignant|matiere|choix|pr√©nom|prenom/.test(s);
                }));

                const headerRowIndex = headerIndex === -1 ? 0 : headerIndex;
                const headers = (aoa[headerRowIndex] || []).map((h, i) => (h === undefined || h === null || String(h).trim() === '') ? `col${i}` : String(h));

                // Construire les objets lignes √† partir des lignes suivantes
                const dataRows = aoa.slice(headerRowIndex + 1);
                rows = dataRows.map(r => {
                    const obj = {};
                    headers.forEach((h, i) => { obj[h] = r && r[i] !== undefined ? r[i] : ''; });
                    return obj;
                }).filter(r => Object.values(r).some(v => v !== '' && v !== null));
            }

            if (!rows || rows.length === 0) {
                throw new Error("Aucune ligne de donn√©es d√©tect√©e apr√®s analyse.");
            }

            // Normalisation utilitaire
            const normalize = (s) => {
                if (s === undefined || s === null) return '';
                return String(s).trim().toLowerCase()
                    .normalize('NFD').replace(/[\u0300-\u036f]/g, '')
                    .replace(/\s+/g, '')
                    .replace(/[^a-z0-9]/g, '');
            };

            // D√©finitions mots-cl√©s (non exhaustif)
            const KEYWORDS = {
                name: ['nom', 'enseignant', 'nomprenom', 'enseignantnom'],
                prenom: ['prenom', 'pr√©nom'],
                contraintes: ['contraintes', 'remarques', 'note', 'commentaire'],
                choix1: ['choix1','matiere1','mati√®re1','choixdelamatiere1','choixdelamatiere','matiere','mati√®re','choix'],
                choix2: ['choix2','matiere2','mati√®re2','choixdelamatiere2'],
                choix3: ['choix3','matiere3','mati√®re3','choixdelamatiere3'],
                c1: ['c1','crs1','cours1'],
                td1: ['td1'],
                tp1: ['tp1'],
                c2: ['c2','crs2','cours2'],
                td2: ['td2'],
                tp2: ['tp2'],
                c3: ['c3','crs3','cours3'],
                td3: ['td3'],
                tp3: ['tp3']
            };

            // Construire headerMap (internalKey -> original header)
            const headerMap = {};
            const sampleRow = rows[0] || {};
            Object.keys(sampleRow).forEach(origHeader => {
                const hnorm = normalize(origHeader);
                for (const internalKey in KEYWORDS) {
                    if (KEYWORDS[internalKey].some(k => hnorm.includes(normalize(k)))) {
                        if (!headerMap[internalKey]) headerMap[internalKey] = origHeader;
                    }
                }
            });

            // heuristique si pas de colonne 'nom'
            if (!headerMap.name) {
                const firstCol = Object.keys(sampleRow)[0];
                if (firstCol) {
                    headerMap.name = firstCol;
                    logMessage("‚ö†Ô∏è Colonne 'Nom' non d√©tect√©e ‚Äî utilisation heuristique de la premi√®re colonne.", 'warning');
                } else {
                    throw new Error("Colonne 'Nom' introuvable.");
                }
            }

            // Construire map des mati√®res existantes (normalis√©es)
            const existingMatiereMap = {};
            Object.keys(MATIERE_GROUPES_INFO || {}).forEach(k => {
                const nk = normalize(k);
                if (nk) existingMatiereMap[nk] = k;
            });
            const findMatiereKey = (raw) => {
                if (!raw && raw !== 0) return '';
                const n = normalize(raw);
                if (!n) return String(raw).trim();
                if (existingMatiereMap[n]) return existingMatiereMap[n];
                for (const nk in existingMatiereMap) {
                    if (nk.includes(n) || n.includes(nk)) return existingMatiereMap[nk];
                }
                return String(raw).trim();
            };

            const parseIntSafe = v => {
                if (v === undefined || v === null) return 0;
                const s = String(v).trim().replace(',', '.');
                const n = parseInt(s, 10);
                return isNaN(n) ? 0 : n;
            };

            const newSouhaits = {};

            rows.forEach(row => {
                const rawName = headerMap.name ? row[headerMap.name] : '';
                let name = rawName ? String(rawName).trim() : '';
                if (!name) return;

                if (headerMap.prenom) {
                    const prenom = (row[headerMap.prenom] || '').toString().trim();
                    if (prenom) name = `${name.toUpperCase()} ${prenom}`;
                }

                const rawChoix1 = headerMap.choix1 ? (row[headerMap.choix1] || '').toString().trim() : '';
                const rawChoix2 = headerMap.choix2 ? (row[headerMap.choix2] || '').toString().trim() : '';
                const rawChoix3 = headerMap.choix3 ? (row[headerMap.choix3] || '').toString().trim() : '';

                const choix1 = rawChoix1 ? findMatiereKey(rawChoix1) : '';
                const choix2 = rawChoix2 ? findMatiereKey(rawChoix2) : '';
                const choix3 = rawChoix3 ? findMatiereKey(rawChoix3) : '';

                const contraintes = headerMap.contraintes ? (row[headerMap.contraintes] || '').toString().trim() : 'Aucune remarque.';

                const c1 = headerMap.c1 ? parseIntSafe(row[headerMap.c1]) : 0;
                const td1 = headerMap.td1 ? parseIntSafe(row[headerMap.td1]) : 0;
                const tp1 = headerMap.tp1 ? parseIntSafe(row[headerMap.tp1]) : 0;

                const c2 = headerMap.c2 ? parseIntSafe(row[headerMap.c2]) : 0;
                const td2 = headerMap.td2 ? parseIntSafe(row[headerMap.td2]) : 0;
                const tp2 = headerMap.tp2 ? parseIntSafe(row[headerMap.tp2]) : 0;

                const c3 = headerMap.c3 ? parseIntSafe(row[headerMap.c3]) : 0;
                const td3 = headerMap.td3 ? parseIntSafe(row[headerMap.td3]) : 0;
                const tp3 = headerMap.tp3 ? parseIntSafe(row[headerMap.tp3]) : 0;

                newSouhaits[name] = {
                    choix1: choix1 || '',
                    c1: c1, td1: td1, tp1: tp1,
                    choix2: choix2 || '',
                    c2: c2, td2: td2, tp2: tp2,
                    choix3: choix3 || '',
                    c3: c3, td3: td3, tp3: tp3,
                    contraintes: contraintes || 'Aucune remarque.'
                };
            });

            if (Object.keys(newSouhaits).length === 0) {
                throw new Error("Aucune fiche d'enseignant valide trouv√©e dans le fichier.");
            }

            // r√©sum√© et confirmation (comme avant)
            const importSummary = {
                nouveauxEnseignants: [],
                enseignantsMisAJour: [],
                nouvellesMatieres: new Set(),
                totalEnseignants: Object.keys(newSouhaits).length
            };
            const lowerCaseExistingTeachers = LISTE_ENSEIGNANTS.map(name => name.toLowerCase());

            for (const enseignant in newSouhaits) {
                if (!lowerCaseExistingTeachers.includes(enseignant.toLowerCase())) importSummary.nouveauxEnseignants.push(enseignant);
                else importSummary.enseignantsMisAJour.push(enseignant);

                const wishes = newSouhaits[enseignant];
                [wishes.choix1, wishes.choix2, wishes.choix3]
                    .filter(m => m && m.trim() !== '')
                    .forEach(m => {
                        const mapped = existingMatiereMap[normalize(m)] || Object.keys(MATIERE_GROUPES_INFO).find(k => normalize(k) === normalize(m));
                        if (!mapped && m.trim()) importSummary.nouvellesMatieres.add(m.trim());
                    });
            }

            let summaryHtml = `<p><strong>Analyse termin√©e.</strong> ${importSummary.totalEnseignants} fiches d√©tect√©es.</p>`;
            if (importSummary.nouvellesMatieres.size > 0) summaryHtml += `<p>Nouvelles mati√®res d√©tect√©es: ${[...importSummary.nouvellesMatieres].join(', ')}</p>`;

            showCustomDialog({
                title: "Confirmation Import Souhaits",
                htmlMessage: summaryHtml,
                confirmText: "Confirmer & Appliquer",
                onConfirm: () => {
                    appliquerImportSouhaits(newSouhaits);
                    document.getElementById('importStatus').textContent = `‚úÖ ${Object.keys(newSouhaits).length} souhait(s) import√©(s).`;
                },
                onCancel: () => {
                    document.getElementById('importStatus').textContent = "Import annul√©.";
                }
            });

        } catch (err) {
            console.error("Erreur import souhaits:", err);
            logMessage(`‚ùå Erreur import souhaits: ${err.message}`, 'error');
            document.getElementById('importStatus').textContent = `Erreur: ${err.message}`;
        } finally {
            hideSpinner();
            try { event.target.value = ''; } catch (_) {}
        }
    };

    reader.onerror = function(err) {
        hideSpinner();
        logMessage("‚ùå √âchec de la lecture du fichier.", 'error');
        document.getElementById('importStatus').textContent = "√âchec de la lecture du fichier.";
        try { event.target.value = ''; } catch (_) {}
    };

    reader.readAsArrayBuffer(file);
}
        
        function updateEnseignantDetailPanels() {
            const enseignant1 = document.getElementById('inputEnseignant1').value;
            const enseignant2 = document.getElementById('inputEnseignant2').value;
            let teacherToDisplay = enseignant2 && enseignant2 !== '' ? enseignant2 : enseignant1;
            
            const enseignant2SelectDiv = document.getElementById('enseignant2SelectDiv');
            const enseignant2NoteDiv = document.getElementById('enseignant2NoteDiv');
            if (enseignant1 === '') {
                enseignant2SelectDiv.style.display = 'none';
                enseignant2NoteDiv.style.display = 'none';
                document.getElementById('inputEnseignant2').value = '';
            } else {
                enseignant2SelectDiv.style.display = 'block';
                enseignant2NoteDiv.style.display = 'flex';
            }
            
            afficherSouhaitsEnseignant(teacherToDisplay);
            afficherVolumesSupplementairesEnseignant(teacherToDisplay);
            updateVolumeInfoForSelectedEnseignants();

            const displayDiv = document.getElementById('enseignantEdtDisplay');
            displayDiv.style.display = 'none';
            displayDiv.innerHTML = '';

            if (document.getElementById('selectEDTView').value === 'enseignant_selectionne') {
                actualiserAffichage();
            }
        }


        function afficherSouhaitsEnseignant(enseignantName) {
            const displayDiv = document.getElementById('enseignantSouhaitsDisplay');
            const wishes = ENSEIGNANT_SOUHAITS[enseignantName];

            if (!enseignantName || enseignantName === '') {
                displayDiv.innerHTML = '<p>S√©lectionnez un enseignant (Enseignant 1 ou 2) pour voir ses souhaits et contraintes.</p>';
                return;
            }
            
            if (wishes) {
                const choices = [
                    { label: 'Choix 1', value: wishes.choix1, c: wishes.c1, td: wishes.td1, tp: wishes.tp1 },
                    { label: 'Choix 2', value: wishes.choix2, c: wishes.c2, td: wishes.td2, tp: wishes.tp2 },
                    { label: 'Choix 3', value: wishes.choix3, c: wishes.c3, td: wishes.td3, tp: wishes.tp3 }
                ];
                
                let tableHtml = `
                    <p style="margin-top:0; margin-bottom: 5px;"><strong>Enseignant :</strong> ${enseignantName}</p>
                    <table class="souhaits-table">
                        <thead>
                            <tr>
                                <th>Choix</th>
                                <th>Mati√®re</th>
                                <th>C</th>
                                <th>TD</th>
                                <th>TP</th>
                            </tr>
                        </thead>
                        <tbody>
                `;
                
                const hasWishes = choices.some(c => c.value && c.value !== '');

                if (hasWishes) {
                    choices.forEach(c => {
                        if (c.value && c.value.trim() !== '') {
                             tableHtml += `
                                <tr>
                                    <td><strong>${c.label}</strong></td>
                                    <td>${c.value}</td>
                                    <td>${c.c || 0}</td>
                                    <td>${c.td || 0}</td>
                                    <td>${c.tp || 0}</td>
                                </tr>
                            `;
                        }
                    });
                } else {
                    tableHtml += `<tr><td colspan="5" style="text-align:center; font-style:italic;">Aucun choix de mati√®re enregistr√©.</td></tr>`;
                }

                tableHtml += `
                        </tbody>
                    </table>
                    <div class="contraintes-section">
                        <p><strong>Contraintes (Remarques) :</strong></p>
                        <p>${wishes.contraintes || 'Aucune remarque.'}</p>
                    </div>
                `;
                    
                displayDiv.innerHTML = tableHtml;

            } else {
                displayDiv.innerHTML = `<p><strong>${enseignantName} :</strong> Aucune donn√©e de souhait/contrainte trouv√©e.</p>`;
            }
        }
        
        function updateVolumeInfoForSelectedEnseignants() {
            const enseignant1 = document.getElementById('inputEnseignant1').value;
            const enseignant2 = document.getElementById('inputEnseignant2').value;
            const infoDiv1 = document.getElementById('volumeInfoEnseignant1');
            const infoDiv2 = document.getElementById('volumeInfoEnseignant2');

            const allVolumes = calculerVolumeHoraire();
            const globalMetrics = calculateGlobalVolumeMetrics();
            let VHM = globalMetrics.globalVHM;
            const tolerance = 20;

            // Pour la session d'automne, le VHM de r√©f√©rence pour l'affichage est divis√© par 2
            const currentSession = document.getElementById('selectSession').value;
            if (currentSession === "Session d'automne") {
                VHM = Math.round(VHM / 2);
            }

            const updateDiv = (div, enseignant) => {
                if (!enseignant) {
                    div.innerHTML = '';
                    div.className = 'volume-info-enseignant';
                    return;
                }
                const volume = allVolumes[enseignant] || 0;
                div.innerHTML = `Vol: ${volume} hTP / VHM: ${VHM} hTP`;

                div.className = 'volume-info-enseignant';
                if (volume > VHM + tolerance) {
                    div.classList.add('volume-red');
                } else if (volume >= VHM - tolerance) {
                    div.classList.add('volume-green');
                } else {
                    div.classList.add('volume-orange');
                }
            };

            updateDiv(infoDiv1, enseignant1);
            updateDiv(infoDiv2, enseignant2);
        }

        function afficherVolumesSupplementairesEnseignant(enseignantName) {
            const nomDisplay = document.getElementById('volume-supplementaire-enseignant-nom');
            const listDiv = document.getElementById('volumeSupplementaireList');
            const totalDiv = document.getElementById('volumeSupplementaireTotal');
            listDiv.innerHTML = '';
            totalDiv.innerHTML = '';

            if (!enseignantName || enseignantName === '') {
                nomDisplay.textContent = '-- Aucun --';
                return;
            }
            
            nomDisplay.textContent = enseignantName;
            const volumesSupplementaires = ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignantName] || [];
            let totalSupplementaire = 0;

            volumesSupplementaires.forEach((item, index) => {
                let description = item.type;
                if (item.type === 'Autre' && item.description) {
                    description = `${item.type}: ${item.description}`;
                }
                
                const itemDiv = document.createElement('div');
                itemDiv.className = 'volume-supplementaire-item';
                itemDiv.innerHTML = `
                    <span>${description}</span>
                    <span><strong>${item.volume} hTP</strong> <button class="delete-volume-supplementaire-btn" onclick="supprimerVolumeSupplementaire('${enseignantName}', ${index})">x</button></span>
                `;
                listDiv.appendChild(itemDiv);
                totalSupplementaire += item.volume;
            });

            if (totalSupplementaire > 0) {
                totalDiv.innerHTML = `Total Suppl√©mentaire: <strong>${totalSupplementaire} hTP</strong>`;
            }
        }

        function ajouterVolumeSupplementaire() {
            const enseignant1 = document.getElementById('inputEnseignant1').value;
            const enseignant2 = document.getElementById('inputEnseignant2').value;
            const enseignant = enseignant2 && enseignant2 !== '' ? enseignant2 : enseignant1;
            
            if (!enseignant) {
                logMessage('‚ö†Ô∏è Veuillez s√©lectionner un enseignant dans le formulaire principal avant d\'ajouter un volume suppl√©mentaire.', 'error');
                return;
            }

            const type = document.getElementById('volumeSupplementaireType').value;
            const volume = parseInt(document.getElementById('volumeSupplementaireVolume').value, 10);
            const description = document.getElementById('volumeSupplementaireDescriptionAutre').value.trim();

            if (isNaN(volume) || volume <= 0) {
                logMessage('‚ö†Ô∏è Le volume horaire doit √™tre un nombre positif.', 'error');
                return;
            }

            if (type === 'Autre' && !description) {
                 logMessage('‚ö†Ô∏è Veuillez fournir une description pour le type "Autre".', 'error');
                 return;
            }

            if (!ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignant]) {
                ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignant] = [];
            }

            ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignant].push({
                type: type,
                volume: volume,
                description: description
            });
            
            logMessage(`üí∞ Volume suppl√©mentaire de ${volume} hTP (${type}) ajout√© pour **${enseignant}**.`, 'success');
            
            document.getElementById('volumeSupplementaireVolume').value = '';
            document.getElementById('volumeSupplementaireDescriptionAutre').value = '';
            
            afficherVolumesSupplementairesEnseignant(enseignant);
            actualiserAffichage();
        }

        function supprimerVolumeSupplementaire(enseignantName, index) {
            if (ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignantName] && ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignantName][index]) {
                const item = ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignantName][index];
                ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[enseignantName].splice(index, 1);
                
                logMessage(`üóëÔ∏è Volume suppl√©mentaire de ${item.volume} hTP (${item.type}) supprim√© pour **${enseignantName}**.`, 'success');
                
                afficherVolumesSupplementairesEnseignant(enseignantName);
                actualiserAffichage();
            }
        }

        function afficherEDTEnseignantSelectionne() {
            const enseignant1 = document.getElementById('inputEnseignant1').value;
            const enseignant2 = document.getElementById('inputEnseignant2').value;
            const teacher = enseignant2 && enseignant2 !== '' ? enseignant2 : enseignant1;
            const displayDiv = document.getElementById('enseignantEdtDisplay');

            if (displayDiv.style.display === 'block') {
                displayDiv.style.display = 'none';
                displayDiv.innerHTML = '';
                return;
            }

            if (!teacher) {
                logMessage("‚ö†Ô∏è Veuillez s√©lectionner un enseignant pour afficher son emploi du temps.", 'error');
                displayDiv.style.display = 'none';
                return;
            }

            const sessionsEnseignant = seances.filter(s => s.enseignantsArray.includes(teacher));

            if (sessionsEnseignant.length === 0) {
                displayDiv.innerHTML = `<p style="font-style: italic;">Aucune s√©ance n'est attribu√©e √† ${teacher}.</p>`;
            } else {
                displayDiv.innerHTML = genererTableauHTML(sessionsEnseignant);
            }
            displayDiv.style.display = 'block';
        }

        function afficherEnseignantsInteresses(matiere) {
            const listDiv = document.getElementById('enseignantsInteressesList');
            if (!matiere) {
                listDiv.innerHTML = '<p style="font-style: italic; color: #777;">S√©lectionnez une mati√®re pour voir la liste.</p>';
                return;
            }

            const interestedTeachers = [];
            for (const enseignant in ENSEIGNANT_SOUHAITS) {
                const wishes = ENSEIGNANT_SOUHAITS[enseignant];
                if (wishes.choix1 === matiere || wishes.choix2 === matiere || wishes.choix3 === matiere) {
                    interestedTeachers.push(enseignant);
                }
            }

            if (interestedTeachers.length > 0) {
                let html = '<ul style="margin: 0; padding-left: 20px;">';
                interestedTeachers.sort().forEach(name => {
                    html += `<li>${name}</li>`;
                });
                html += '</ul>';
                listDiv.innerHTML = html;
            } else {
                listDiv.innerHTML = '<p style="font-style: italic; color: #777;">Aucun enseignant n\'a choisi cette mati√®re.</p>';
            }
        }

        function sanitizeHTML(str) {
            const temp = document.createElement('div');
            temp.textContent = str;
            return temp.innerHTML;
        }

        function addEnseignantHandler() {
            const nameInput = document.getElementById('inputNewEnseignant');
            const name = sanitizeHTML(nameInput.value.trim());
            if (name && !LISTE_ENSEIGNANTS.includes(name)) {
                LISTE_ENSEIGNANTS.push(name);
                LISTE_ENSEIGNANTS.sort(); 
                nameInput.value = '';
                logMessage(`üë§ Enseignant **${name}** ajout√© avec succ√®s.`, 'success');
                initialiserFormulaire(); 
                initialiserDeletionForms();
            } else if (name) {
                logMessage(`‚ö†Ô∏è L'enseignant **${name}** existe d√©j√† ou le nom est vide.`, 'error');
            }
        }
        
        function addFiliereHandler() {
            const nameInput = document.getElementById('inputNewFiliere');
            const name = sanitizeHTML(nameInput.value.trim());
            
            // MODIFI√â: V√©rifie si une fili√®re avec le m√™me nom existe d√©j√†
            if (name && !LISTE_FILIERES.some(f => f.nom === name)) {
                // NOUVEAU: La nouvelle fili√®re est assign√©e √† la session actuellement s√©lectionn√©e
                const sessionValue = document.getElementById('selectSession').value;
                const currentSession = sessionValue.toLowerCase().includes('automne') ? 'Automne' : 'Printemps';
                
                LISTE_FILIERES.push({ nom: name, session: currentSession });
                LISTE_FILIERES.sort((a, b) => a.nom.localeCompare(b.nom));
                nameInput.value = '';
                logMessage(`üìö Fili√®re **${name}** ajout√©e avec succ√®s √† la session de <strong>${currentSession}</strong>.`, 'success');
                initialiserFormulaire();
                initialiserDeletionForms();
                initialiserMatiereManagementForm();
                initialiserVueEDT();
                initialiserFiliereSessionManagement(); // Met √† jour le nouveau panneau
            } else if (name) {
                logMessage(`‚ö†Ô∏è La fili√®re **${name}** existe d√©j√† ou le nom est vide.`, 'error');
            }
        }

        function addSalleHandler() {
            const nameInput = document.getElementById('inputNewSalleName');
            const name = sanitizeHTML(nameInput.value.trim());
            const type = document.getElementById('inputNewSalleType').value;
            
            if (name && !SALLES_INFO.hasOwnProperty(name)) {
                SALLES_INFO[name] = type;
                nameInput.value = '';
                logMessage(`üìç Salle **${name}** (Type: ${type}) ajout√©e avec succ√®s.`, 'success');
                initialiserFormulaire();
                initialiserDeletionForms();
                populateAutoSalleSelects();
            } else if (name) {
                logMessage(`‚ö†Ô∏è La salle **${name}** existe d√©j√† ou le nom est vide.`, 'error');
            }
        }
        
        function addMatiereHandler() {
            const nameInput = document.getElementById('inputNewMatiere');
            const name = sanitizeHTML(nameInput.value.trim());
            if (!name) {
                logMessage(`‚ö†Ô∏è Le nom de la mati√®re est vide.`, 'error');
                return;
            }
            if (name && MATIERE_GROUPES_INFO.hasOwnProperty(name)) {
                logMessage(`‚ö†Ô∏è La mati√®re **${name}** existe d√©j√†.`, 'error');
                return;
            }
            
            // MODIFI√â: Ajout de nbEnseignantsTP par d√©faut
            MATIERE_GROUPES_INFO[name] = { 
                filiere: '', 
                sections_cours: 0, 
                td_groups: 0, 
                tp_groups: 0, 
                volumeHTP: { ...DEFAULT_VOLUME_HTP },
                nbEnseignantsTP: 1 // Default to 1 teacher
            };
            
            LISTE_MATIERES = Object.keys(MATIERE_GROUPES_INFO).sort();
            
            nameInput.value = '';
            logMessage(`üìö Mati√®re **${name}** ajout√©e avec les param√®tres par d√©faut (**0/0/0**).`, 'success');
            
            initialiserFormulaire();
            initialiserMatiereManagementForm(); 
            
            document.getElementById('selectMatiereToManage').value = name;
            updateMatiereManagementFields();
        }


        function logMessage(message, type = 'success') {
            const messagesDiv = document.getElementById('messages');
            if (!messagesDiv) return;
            const p = document.createElement('p');
            p.className = type;
            p.innerHTML = message;
            messagesDiv.prepend(p);
        }
        function updateMatiereOptions(selectedFiliere) {
    const selectMatiere = document.getElementById('inputMatiere');
    const currentMatiere = selectMatiere.value;
    selectMatiere.innerHTML = '';

    // Construire liste tri√©e
    const allMatieres = LISTE_MATIERES.slice().sort((a, b) => a.localeCompare(b));

    // Si une fili√®re est s√©lectionn√©e, montrer :
    //  - d'abord les mati√®res attach√©es √† cette fili√®re,
    //  - puis les mati√®res sans fili√®re (non assign√©es) (important apr√®s import)
    // Sinon, montrer toutes les mati√®res.
    let matieresToShow;
    if (selectedFiliere) {
        const assigned = allMatieres.filter(m => (MATIERE_GROUPES_INFO[m] && MATIERE_GROUPES_INFO[m].filiere === selectedFiliere));
        const unassigned = allMatieres.filter(m => !MATIERE_GROUPES_INFO[m] || !MATIERE_GROUPES_INFO[m].filiere);
        matieresToShow = [...assigned, ...unassigned];
    } else {
        matieresToShow = allMatieres;
    }

    if (!matieresToShow || matieresToShow.length === 0) {
        selectMatiere.innerHTML = `<option value="">-- Aucune mati√®re pour cette fili√®re --</option>`;
    } else {
        // Construire options : marquer les non-assign√©es
        matieresToShow.forEach(m => {
            const opt = document.createElement('option');
            opt.value = m;
            const fil = MATIERE_GROUPES_INFO[m] && MATIERE_GROUPES_INFO[m].filiere ? MATIERE_GROUPES_INFO[m].filiere : '';
            opt.textContent = fil ? m : `${m} (sans fili√®re)`;
            selectMatiere.appendChild(opt);
        });
    }

    // R√©tablir la s√©lection si possible
    if (currentMatiere && selectMatiere.querySelector(`option[value="${currentMatiere}"]`)) {
        selectMatiere.value = currentMatiere;
    } else {
        selectMatiere.selectedIndex = 0;
    }

    updateSectionsSelect();
    updateGroupesSelect();
}
// ...existing code...

// filepath: /Users/mrani/Documents/codage/EDT_ADMIN/edt_global/edt5.81.html
// ...existing code...
function appliquerImportSouhaits(newSouhaits) {
    let count = Object.keys(newSouhaits).length;
    ENSEIGNANT_SOUHAITS = newSouhaits;

    const newEnseignantsList = Object.keys(ENSEIGNANT_SOUHAITS);
    if (newEnseignantsList.length > 0) {
        let addedTeachersCount = 0;
        newEnseignantsList.forEach(enseignant => {
            const lowerCaseExistingTeachers = LISTE_ENSEIGNANTS.map(name => name.toLowerCase());
            if (!lowerCaseExistingTeachers.includes(enseignant.toLowerCase())) {
                LISTE_ENSEIGNANTS.push(enseignant);
                addedTeachersCount++;
            }
        });

        LISTE_ENSEIGNANTS.sort();

        if (addedTeachersCount > 0) {
            logMessage(`üë§ ${addedTeachersCount} nouvel(s) enseignant(s) ajout√©(s). Total: ${LISTE_ENSEIGNANTS.length}.`, 'success');
        } else {
            logMessage(`üë§ Aucun nouvel enseignant √† ajouter.`, 'initial');
        }

        const allWishedMatieres = new Set();
        Object.values(newSouhaits).forEach(w => {
            [w.choix1, w.choix2, w.choix3].filter(m => m && m !== '').forEach(m => allWishedMatieres.add(m.trim()));
        });

        allWishedMatieres.forEach(matiere => {
            if (!MATIERE_GROUPES_INFO.hasOwnProperty(matiere)) {
                MATIERE_GROUPES_INFO[matiere] = {
                    filiere: '', // garder vide ; updateMatiereOptions affichera ces mati√®res m√™me quand une fili√®re est s√©lectionn√©e
                    sections_cours: 0,
                    td_groups: 0,
                    tp_groups: 0,
                    volumeHTP: { ...DEFAULT_VOLUME_HTP },
                    nbEnseignantsTP: 1
                };
                logMessage(`üìö Mati√®re **${matiere}** ajout√©e par import de souhait (valeurs par d√©faut).`, 'initial');
            }
        });

        LISTE_MATIERES = Object.keys(MATIERE_GROUPES_INFO).sort();

        initialiserTout();
        // Forcer l'actualisation du s√©lecteur mati√®re pour montrer aussi les mati√®res sans fili√®re
        try {
            const currentFiliere = document.getElementById('inputFiliere') ? document.getElementById('inputFiliere').value : null;
            updateMatiereOptions(currentFiliere);
        } catch (e) {
            // silent
        }
    }

    document.getElementById('importStatus').textContent = `‚úÖ ${count} souhaits d'enseignants charg√©s et appliqu√©s.`;
    logMessage(`‚úÖ ${count} souhaits d'enseignants charg√©s et appliqu√©s.`, 'success');

    updateEnseignantDetailPanels();
    updateMatiereManagementFields();
}
        
        function clearLogHandler() {
            document.getElementById('messages').innerHTML = '';
            logMessage(`üóëÔ∏è Journal des op√©rations vid√©.`, 'initial');
        }
        
        function updateSectionsSelect() {
            const inputMatiere = document.getElementById('inputMatiere').value;
            const inputFiliere = document.getElementById('inputFiliere').value;
            const inputSection = document.getElementById('inputSection');

            const assignedCoursSections = new Set(
                seances
                    .filter(s => s.matiere === inputMatiere && s.type === 'Cours' && s.enseignantsArray && s.enseignantsArray.length > 0)
                    .map(s => s.uniqueStudentEntity)
            );
            
            const sectionsWithAssignedGroups = new Set();
            seances
                .filter(s => s.matiere === inputMatiere && (s.type === 'TD' || s.type === 'TP'))
                .forEach(s => {
                    const sectionEntity = s.uniqueStudentEntity.substring(0, s.uniqueStudentEntity.lastIndexOf(' - '));
                    sectionsWithAssignedGroups.add(sectionEntity);
                });


            let numSections = 0;
            const info = MATIERE_GROUPES_INFO[inputMatiere];
            if (info) {
                numSections = info.sections_cours || 0;
            }

            const currentValue = inputSection.value;
            inputSection.innerHTML = ''; 

            for (let i = 0; i < numSections; i++) {
                const sectionChar = String.fromCharCode(65 + i);
                const sectionName = `Section ${sectionChar}`;
                const uniqueEntity = `${inputFiliere} - ${sectionName}`;
                
                const isCoursAssigned = assignedCoursSections.has(uniqueEntity);
                const areGroupsAssigned = sectionsWithAssignedGroups.has(uniqueEntity);


                const option = document.createElement('option');
                option.value = sectionName;
                option.textContent = sectionName;
                
                if (isCoursAssigned) {
                    option.style.backgroundColor = '#d4edda';
                    option.style.fontWeight = 'bold';
                    option.textContent += ' (Cours attribu√©)';
                } else if (areGroupsAssigned) {
                    option.style.backgroundColor = '#fff3cd';
                    option.textContent += ' (Groupes attribu√©s)';
                }
                
                inputSection.appendChild(option);
            }

            if (Array.from(inputSection.options).some(opt => opt.value === currentValue)) {
                inputSection.value = currentValue;
            } else {
                inputSection.selectedIndex = 0;
            }
            updateGroupesSelect(); 
        }

        function updateGroupesSelect() {
            const inputType = document.getElementById('inputType').value;
            const inputMatiere = document.getElementById('inputMatiere').value;
            const inputFiliere = document.getElementById('inputFiliere').value;
            const inputSection = document.getElementById('inputSection').value;
            const inputGroupeTDTP = document.getElementById('inputGroupeTDTP');
            const groupeDiv = document.getElementById('groupeDiv');

            const assignedTDGroups = new Set(
                seances
                    .filter(s => s.matiere === inputMatiere && s.type === 'TD' && s.enseignantsArray && s.enseignantsArray.length > 0)
                    .map(s => s.uniqueStudentEntity)
            );
            const assignedTPGroups = new Set(
                seances
                    .filter(s => s.matiere === inputMatiere && s.type === 'TP' && s.enseignantsArray && s.enseignantsArray.length > 0)
                    .map(s => s.uniqueStudentEntity)
            );

            let numGroups = 0;
            
            // MODIFICATION: La visibilit√© ne d√©pend que du type, plus de la section
            // L'ancienne condition √©tait : if ((inputType === 'TD' || inputType === 'TP') && inputSection)
            if (inputType === 'TD' || inputType === 'TP') {
                groupeDiv.style.display = 'block';
                inputGroupeTDTP.setAttribute('required', 'required');
                
                const info = MATIERE_GROUPES_INFO[inputMatiere];
                if (info) {
                    numGroups = inputType === 'TD' ? info.td_groups : info.tp_groups;
                }
            } else {
                groupeDiv.style.display = 'none';
                inputGroupeTDTP.removeAttribute('required');
            }

            const currentValue = inputGroupeTDTP.value;
            inputGroupeTDTP.innerHTML = '';

            for (let i = 1; i <= numGroups; i++) {
                const groupName = `G${i}`;
                const uniqueEntity = `${inputFiliere} - ${inputSection} - ${groupName}`;
                
                let isAssigned = false;
                let assignedType = '';

                if (inputType === 'TD' && assignedTDGroups.has(uniqueEntity)) {
                    isAssigned = true;
                    assignedType = 'TD';
                } else if (inputType === 'TP' && assignedTPGroups.has(uniqueEntity)) {
                    isAssigned = true;
                    assignedType = 'TP';
                }

                const option = document.createElement('option');
                option.value = groupName;
                option.textContent = groupName;

                if (isAssigned) {
                    option.style.backgroundColor = '#d4edda';
                    option.textContent += ` (${assignedType} attribu√©)`;
                }

                inputGroupeTDTP.appendChild(option);
            }
            
            if (Array.from(inputGroupeTDTP.options).some(opt => opt.value === currentValue)) {
                inputGroupeTDTP.value = currentValue;
            } else {
                inputGroupeTDTP.selectedIndex = 0;
            }
        }
        
        function updateEnseignantVisibility(type) {
            const enseignant2SelectDiv = document.getElementById('enseignant2SelectDiv');
            const enseignant2NoteDiv = document.getElementById('enseignant2NoteDiv');
            const suggestButton2 = document.getElementById('btnSuggestTeacher2');

            // MODIFI√â: L'affichage du 2√®me enseignant d√©pend aussi du r√©glage de la mati√®re pour les TP
            const matiere = document.getElementById('inputMatiere').value;
            const matiereInfo = MATIERE_GROUPES_INFO[matiere];
            const requireTwoTeachersForTP = type === 'TP' && matiereInfo && matiereInfo.nbEnseignantsTP === 2;

            if (requireTwoTeachersForTP) {
                 enseignant2SelectDiv.style.display = 'block';
                 enseignant2NoteDiv.style.display = 'flex';
                 suggestButton2.style.display = 'block';
                 document.getElementById('enseignant2-note').textContent = 'Co-ens. requis';
            } else {
                 enseignant2SelectDiv.style.display = 'block'; // On laisse le champ visible
                 enseignant2NoteDiv.style.display = 'flex';
                 suggestButton2.style.display = type === 'TP' ? 'block' : 'none'; // Le bouton reste si c'est un TP
                 document.getElementById('enseignant2-note').textContent = 'Co-ens. possible'; // Texte par d√©faut
            }
            
            updateEnseignantDetailPanels();
        }

        function updateFormVisibility(type) {
            updateCreneauSelect(type);
            updateSalleSelect(type);
            updateSalleInfo();
            updateSectionsSelect(); 
            updateGroupesSelect(); 
            updateEnseignantVisibility(type);
        }
        
        function updateSalleSelect(typeSeance) {
            const inputSalle = document.getElementById('inputSalle');
            const sallesList = Object.keys(SALLES_INFO).sort();
            const currentValue = inputSalle.value;
            let optionsHTML = '';

            const isTP = typeSeance === 'TP';
            
            sallesList.forEach(salle => {
                let isAvailable = true;
                
                if (isTP) {
                    if (!salle.toUpperCase().startsWith('STP')) {
                        isAvailable = false;
                    }
                }
                
                if (isAvailable) {
                    optionsHTML += `<option value="${salle}">${salle}</option>`;
                }
            });

            inputSalle.innerHTML = optionsHTML;
            
            if (inputSalle.querySelector(`option[value="${currentValue}"]`)) {
                inputSalle.value = currentValue;
            } else {
                inputSalle.selectedIndex = 0; 
            }
            
            updateSalleInfo(); 
        }

        function updateCreneauSelect(typeSeance) {
            const inputCreneau = document.getElementById('inputCreneau');
            
            const selectedCreneau = inputCreneau.value;
            let optionsHTML = '';
            
            const isTP = typeSeance === 'TP';

            getSortedCreneauxKeys().forEach(creneau => {
                const isCouplableDebut = CRENEAUX_COUPLES_SUIVANT.hasOwnProperty(creneau);
                let isAvailable = true;

                if (isTP && !isCouplableDebut) {
                    isAvailable = false; 
                }
                
                if (isAvailable) {
                    optionsHTML += `<option value="${creneau}">${creneau}</option>`;
                }
            });

            inputCreneau.innerHTML = optionsHTML;
            if (inputCreneau.querySelector(`option[value="${selectedCreneau}"]`)) {
                inputCreneau.value = selectedCreneau;
            } else {
                inputCreneau.selectedIndex = 0;
            }
            
            updateCreneauFin(inputCreneau.value, typeSeance);
        }

        function updateCreneauFin(creneau, type) {
             const creneauFinDiv = document.getElementById('creneauFin');
             let heureFin = LISTE_CRENEAUX[creneau]?.fin || '--:--';

             if (type === 'TP' && CRENEAUX_COUPLES_SUIVANT.hasOwnProperty(creneau)) {
                 const nextCreneau = CRENEAUX_COUPLES_SUIVANT[creneau];
                 heureFin = LISTE_CRENEAUX[nextCreneau]?.fin || 'N/A';
             }
             
             creneauFinDiv.textContent = `Fin : ${heureFin}`;
        }
        
        function updateSalleInfo() {
            const salle = document.getElementById('inputSalle').value;
            const salleTypeInfo = document.getElementById('salleTypeInfo');
            salleTypeInfo.textContent = `Type: ${SALLES_INFO[salle] || 'Inconnu'}`;
        }

        function initialiserVueEDT() {
            const select = document.getElementById('selectEDTView');
            const currentValue = select.value;

            select.innerHTML = '';
            select.innerHTML += '<option value="global">Global (Toutes les fili√®res)</option>';
            select.innerHTML += '<option value="enseignant_selectionne">Enseignant S√©lectionn√©</option>';

            const filiereGroup = document.createElement('optgroup');
            filiereGroup.label = 'Fili√®res';
            // MODIFI√â: Utilise la fonction qui filtre les fili√®res par session
            getFiliereNomsForCurrentSession().forEach(filiereNom => {
                const option = document.createElement('option');
                option.value = filiereNom;
                option.textContent = filiereNom;
                filiereGroup.appendChild(option);
            });
            select.appendChild(filiereGroup);

            if (select.querySelector(`option[value="${currentValue}"]`)) {
                select.value = currentValue;
            } else {
                select.value = 'global';
            }
        }
        
        function initialiserFormulaire() {
            const enseignantOptions = LISTE_ENSEIGNANTS.sort();

            // MODIFI√â: La liste des mati√®res est maintenant filtr√©e par la session en cours
            LISTE_MATIERES = getMatieresForCurrentSession();
            
            // MODIFI√â: La liste des fili√®res est maintenant filtr√©e par la session en cours
            const filieresDeSession = getFiliereNomsForCurrentSession();
            
            const selectsCommon = {
                inputJour: LISTE_JOURS, 
                inputCreneau: getSortedCreneauxKeys(), 
                inputFiliere: filieresDeSession, 
                inputType: LISTE_TYPES_SEANCE
            };

            for (const id in selectsCommon) {
                const selectElement = document.getElementById(id);
                const currentValue = selectElement.value;
                selectElement.innerHTML = ''; 
                selectsCommon[id].forEach(item => {
                    const option = document.createElement('option');
                    option.value = item;
                    option.textContent = item;
                    selectElement.appendChild(option);
                });
                if (selectElement.querySelector(`option[value="${currentValue}"]`)) {
                    selectElement.value = currentValue;
                } else {
                    selectElement.selectedIndex = 0;
                }
            }

            const selectEnseignant1 = document.getElementById('inputEnseignant1');
            const currentEnseignant1Value = selectEnseignant1.value;
            selectEnseignant1.innerHTML = '<option value="">-- Aucun --</option>' +
                                      enseignantOptions.map(item => `<option value="${item}">${item}</option>`).join('');
            if (selectEnseignant1.querySelector(`option[value="${currentEnseignant1Value}"]`)) {
                selectEnseignant1.value = currentEnseignant1Value;
            } else {
                selectEnseignant1.selectedIndex = 0;
            }
            
            const inputEnseignant2 = document.getElementById('inputEnseignant2');
            const currentEnseignant2Value = inputEnseignant2.value;
            inputEnseignant2.innerHTML = '<option value="">-- Aucun --</option>' + 
                                         enseignantOptions.map(item => `<option value="${item}">${item}</option>`).join('');
            
            if (inputEnseignant2.querySelector(`option[value="${currentEnseignant2Value}"]`)) {
                inputEnseignant2.value = currentEnseignant2Value;
            } else {
                inputEnseignant2.selectedIndex = 0;
            }
            
            const initialType = document.getElementById('inputType').value;
            updateFormVisibility(initialType);

            updateMatiereOptions(document.getElementById('inputFiliere').value);
            updateEnseignantSelects();
        }
        
        function updateMatiereManagementFields() {
            const selectMatiere = document.getElementById('selectMatiereToManage').value;
            const selectMatiereFiliere = document.getElementById('selectMatiereFiliere');
            const inputManageSections = document.getElementById('inputManageSections');
            const inputManageTdGroups = document.getElementById('inputManageTdGroups');
            const inputManageTpGroups = document.getElementById('inputManageTpGroups');
            const selectManageNbEnseignantsTP = document.getElementById('selectManageNbEnseignantsTP'); // NOUVEAU

            const totalRegisteredTeachers = LISTE_ENSEIGNANTS.length;
            document.getElementById('displayTotalRegisteredTeachersMatter').textContent = totalRegisteredTeachers;
            document.getElementById('displayTotalRegisteredTeachersGlobal').textContent = totalRegisteredTeachers;


            const info = MATIERE_GROUPES_INFO[selectMatiere];
            
            if (info) {
                selectMatiereFiliere.value = info.filiere || '';
                inputManageSections.value = info.sections_cours || 0;
                inputManageTdGroups.value = info.td_groups || 0;
                inputManageTpGroups.value = info.tp_groups || 0;
                selectManageNbEnseignantsTP.value = info.nbEnseignantsTP || 1; // NOUVEAU: Mettre √† jour le select
                
                const volumes = info.volumeHTP || DEFAULT_VOLUME_HTP;
                document.getElementById('inputManageVolumeCours').value = volumes.Cours;
                document.getElementById('inputManageVolumeTD').value = volumes.TD;
                document.getElementById('inputManageVolumeTP').value = volumes.TP;
                
                const metrics = calculatePerMatiereVolumeMetrics(selectMatiere);
                document.getElementById('displaySelectedMatiereName').textContent = selectMatiere;
                document.getElementById('displayVHT').textContent = metrics.total;
                document.getElementById('displayNbEnseignants').textContent = metrics.nombreEnseignants;
                document.getElementById('displayVHM').textContent = metrics.moyen;


            } else {
                 selectMatiereFiliere.value = '';
                 inputManageSections.value = 0;
                 inputManageTdGroups.value = 0;
                 inputManageTpGroups.value = 0;
                 selectManageNbEnseignantsTP.value = 1; // NOUVEAU: Valeur par d√©faut
                 
                 document.getElementById('inputManageVolumeCours').value = DEFAULT_VOLUME_HTP.Cours;
                 document.getElementById('inputManageVolumeTD').value = DEFAULT_VOLUME_HTP.TD;
                 document.getElementById('inputManageVolumeTP').value = DEFAULT_VOLUME_HTP.TP;

                 document.getElementById('displaySelectedMatiereName').textContent = '--';
                 document.getElementById('displayVHT').textContent = '--';
                 document.getElementById('displayNbEnseignants').textContent = '--';
                 document.getElementById('displayVHM').textContent = '--';
            }
            
            const globalMetrics = calculateGlobalVolumeMetrics();

            document.getElementById('displayGlobalVHT').textContent = globalMetrics.globalVHT;
            document.getElementById('displayTotalUniqueTeachers').textContent = globalMetrics.totalUniqueTeachers;
            document.getElementById('displayGlobalVHM').textContent = globalMetrics.globalVHM;

            afficherEnseignantsInteresses(selectMatiere);
        }
        
        function initialiserMatiereManagementForm() {
            const selectElement = document.getElementById('selectMatiereToManage');
            const currentValue = selectElement.value;
            
            // MODIFI√â: La liste des mati√®res est maintenant filtr√©e par la session en cours
            LISTE_MATIERES = getMatieresForCurrentSession();
            
            selectElement.innerHTML = '';
            LISTE_MATIERES.forEach(item => {
                const option = document.createElement('option');
                option.value = item;
                option.textContent = item;
                selectElement.appendChild(option);
            });
            
            if (selectElement.querySelector(`option[value="${currentValue}"]`)) {
                selectElement.value = currentValue;
            } else {
                selectElement.selectedIndex = 0;
            }
            
            const selectFiliere = document.getElementById('selectMatiereFiliere');
            selectFiliere.innerHTML = '<option value="">-- Aucune --</option>';
            // MODIFI√â: Utilise la liste compl√®te des fili√®res ici pour pouvoir les associer
            LISTE_FILIERES.map(f => f.nom).sort().forEach(filiereNom => {
                const option = document.createElement('option');
                option.value = filiereNom;
                option.textContent = filiereNom;
                selectFiliere.appendChild(option);
            });
            
            updateMatiereManagementFields();
        }
        
        function updateMatiereSettingsHandler() {
            const matiere = document.getElementById('selectMatiereToManage').value;
            const filiere = document.getElementById('selectMatiereFiliere').value;
            const sections = parseInt(document.getElementById('inputManageSections').value, 10);
            const tdGroups = parseInt(document.getElementById('inputManageTdGroups').value, 10);
            const tpGroups = parseInt(document.getElementById('inputManageTpGroups').value, 10);
            const nbEnseignantsTP = parseInt(document.getElementById('selectManageNbEnseignantsTP').value, 10); // NOUVEAU

            if (matiere && MATIERE_GROUPES_INFO.hasOwnProperty(matiere)) {
                MATIERE_GROUPES_INFO[matiere].filiere = filiere;
                // MODIFI√â: Inclure nbEnseignantsTP dans la validation et la sauvegarde
                if (![sections, tdGroups, tpGroups, nbEnseignantsTP].some(isNaN) && [sections, tdGroups, tpGroups].every(n => n >= 0) && [1, 2].includes(nbEnseignantsTP)) {
                    MATIERE_GROUPES_INFO[matiere].sections_cours = sections;
                    MATIERE_GROUPES_INFO[matiere].td_groups = tdGroups;
                    MATIERE_GROUPES_INFO[matiere].tp_groups = tpGroups;
                    MATIERE_GROUPES_INFO[matiere].nbEnseignantsTP = nbEnseignantsTP; // NOUVEAU: Sauvegarder
                    logMessage(`‚úÖ Param√®tres de **${matiere}** mis √† jour (Fili√®re: ${filiere || 'Aucune'}, Ens. TP: ${nbEnseignantsTP}).`, 'success');
                } else {
                    logMessage(`‚ö†Ô∏è Valeurs de Groupes/Sections/Nb Ens TP invalides pour **${matiere}**. La mise √† jour de ces champs a √©chou√©.`, 'error'); // Message d'erreur plus pr√©cis
                }

                // --- MODIFICATION : D√©placement du bloc de gestion des volumes ---
                // Le code pour les volumes horaires est maintenant en dehors du 'else' pr√©c√©dent
                const volCours = parseInt(document.getElementById('inputManageVolumeCours').value, 10);
                const volTD = parseInt(document.getElementById('inputManageVolumeTD').value, 10);
                const volTP = parseInt(document.getElementById('inputManageVolumeTP').value, 10);

                if (![volCours, volTD, volTP].some(isNaN) && [volCours, volTD, volTP].every(n => n >= 0)) {
                    // S'assure que l'objet volumeHTP existe
                    if (!MATIERE_GROUPES_INFO[matiere].volumeHTP) {
                        MATIERE_GROUPES_INFO[matiere].volumeHTP = {};
                    }
                    MATIERE_GROUPES_INFO[matiere].volumeHTP = {
                        Cours: volCours,
                        TD: volTD,
                        TP: volTP
                    };
                    logMessage(`üìä Volumes horaires (hTP) pour **${matiere}** mis √† jour.`, 'success');
                } else {
                    logMessage(`‚ö†Ô∏è Les volumes horaires (hTP) sont invalides pour **${matiere}**. La mise √† jour de ces champs a √©chou√©.`, 'error'); // Message d'erreur plus pr√©cis
                }
                // --- FIN DE LA MODIFICATION ---

            } else {
                 logMessage(`‚ö†Ô∏è Aucune mati√®re s√©lectionn√©e pour la mise √† jour des groupes.`, 'initial');
            }
            
            sauvegarderTravail(); 
            initialiserFormulaire(); 
            actualiserAffichage(); 
            updateMatiereManagementFields();
        }
        
        function deleteMatiereHandler() {
            const matiere = document.getElementById('selectMatiereToManage').value;

            if (!matiere || !MATIERE_GROUPES_INFO.hasOwnProperty(matiere)) {
                logMessage(`‚ö†Ô∏è Veuillez s√©lectionner une mati√®re √† supprimer.`, 'error');
                return;
            }

            const isUsed = seances.some(s => s.matiere === matiere);
            
            if (isUsed) {
                 showCustomDialog({
                    title: 'Confirmer la Suppression',
                    htmlMessage: `‚ö†Ô∏è Attention : La mati√®re "${matiere}" est utilis√©e. Voulez-vous supprimer la mati√®re et toutes ses s√©ances associ√©es ?`,
                    confirmText: 'Supprimer Tout',
                    onConfirm: () => {
                        seances = seances.filter(s => s.matiere !== matiere);
                        logMessage(`üóëÔ∏è Les s√©ances associ√©es √† **${matiere}** ont √©t√© supprim√©es.`, 'warning');
                        deleteMatiereConfirmed(matiere);
                    }
                });
            } else {
                 showCustomDialog({
                    title: 'Confirmer la Suppression',
                    htmlMessage: `√ätes-vous s√ªr de vouloir supprimer d√©finitivement la mati√®re "${matiere}" ?`,
                    confirmText: 'Supprimer',
                    onConfirm: () => deleteMatiereConfirmed(matiere)
                });
            }
        }
        
        function deleteMatiereConfirmed(matiere) {
            delete MATIERE_GROUPES_INFO[matiere];
            LISTE_MATIERES = Object.keys(MATIERE_GROUPES_INFO).sort();
            logMessage(`üóëÔ∏è Mati√®re **${matiere}** supprim√©e.`, 'success');
            initialiserFormulaire(); 
            initialiserMatiereManagementForm(); 
            actualiserAffichage();
        }
        
        function initDefaultMatieresHandler() {
            MATIERE_GROUPES_INFO = {...DEFAULT_MATIERE_GROUPES_INFO};
            logMessage(`üîÑ La liste des mati√®res a √©t√© r√©initialis√©e (vide).`, 'initial');
            initialiserFormulaire();
            initialiserMatiereManagementForm();
            actualiserAffichage();
        }

        function updateInfoBar() {
            // Cette fonction n'est plus pertinente car les volumes sont par mati√®re.
        }

        const EXPORT_CSS_STYLES = /* ... existing code ... */ ``;

        function genererTableauHTML(sessionsFiltrees) {
            let tableHTML = '<table>';
            let headerHTML = '<th>Jour/Heure</th>';
            const sortedCreneaux = getSortedCreneauxKeys();
            sortedCreneaux.forEach(c => {
                headerHTML += `<th>${c} - ${LISTE_CRENEAUX[c].fin}</th>`;
                if (c === '10h15') {
                    headerHTML += '<th class="separator-column"></th>';
                }
            });
            tableHTML += `<thead><tr>${headerHTML}</tr></thead><tbody>`;

            LISTE_JOURS.forEach(jour => {
                tableHTML += `<tr><td class="jour-header">${jour}</td>`;

                sortedCreneaux.forEach(creneau => {
                    const seancesCell = sessionsFiltrees.filter(s => s.jour === jour && s.creneau === creneau);
                    let cellContent = '<td>';

                    seancesCell.forEach(seance => {
                        const filiereDisplay = seance.filiere ? `<span class="filiere-section">${seance.filiere}</span>` : '';
                        const groupeDisplay = seance.groupe && seance.groupe !== 'N/A' ? `<span class="groupe-section">${seance.groupe}</span><br>` : '';
                        const enseignantsDisplay = seance.enseignant ? `<span class="enseignants">${seance.enseignant}</span><br>` : '';

                        cellContent += `
                            <div class="seance ${seance.type}">
                                <strong>${seance.matiere} (${seance.type})</strong><br>
                                ${filiereDisplay}
                                ${groupeDisplay}
                                ${enseignantsDisplay}
                                <small>${seance.salle}</small>
                            </div>
                        `;
                    });

                    tableHTML += cellContent + '</td>';
                    if (creneau === '10h15') {
                        tableHTML += '<td class="separator-column"></td>';
                    }
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            return tableHTML;
        }
        
        function exportProjet() {
            showSpinner();
            try {
                sauvegarderTravail();
                const etatProjet = {
                    version: "2.9-dual-session",
                    LISTE_ENSEIGNANTS,
                    SALLES_INFO,
                    ENSEIGNANT_SOUHAITS,
                    MATIERE_GROUPES_INFO,
                    LISTE_FILIERES,
                    ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES,
                    LISTE_CRENEAUX,
                    VOLUMES_AUTOMNE,
                    headerInfo: {
                        annee: document.getElementById('inputAnneeUniversitaire').value,
                        session: document.getElementById('selectSession').value,
                        departement: document.getElementById('selectDepartement').value
                    },
                    sessionData: {
                        "Session_d'automne": {
                            seances: JSON.parse(localStorage.getItem("edt_physique_seances_Session_d'automne") || '[]'),
                            nextSessionId: parseInt(localStorage.getItem("edt_physique_nextId_Session_d'automne") || '1', 10)
                        },
                        "Session_de_printemps": {
                            seances: JSON.parse(localStorage.getItem("edt_physique_seances_Session_de_printemps") || '[]'),
                            nextSessionId: parseInt(localStorage.getItem("edt_physique_nextId_Session_de_printemps") || '1', 10)
                        }
                    }
                };
                const jsonString = JSON.stringify(etatProjet, null, 2);
                telechargerFichier(jsonString, `sauvegarde_edt_complet_${new Date().toISOString().slice(0,10)}.json`, 'application/json');
                logMessage('‚úÖ Projet complet export√© avec succ√®s.', 'success');
            } finally {
                setTimeout(hideSpinner, 500);
            }
        }

        function importProjet(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                showSpinner();
                try {
                    const data = JSON.parse(e.target.result);
                    if (!data.version) {
                        throw new Error("Format de fichier invalide ou corrompu.");
                    }
                    
                    showCustomDialog({
                        title: 'Confirmer l\'Importation',
                        htmlMessage: '√ätes-vous s√ªr de vouloir importer ce projet ? **Attention, tout votre travail actuel sera d√©finitivement √©cras√©.**',
                        confirmText: 'Importer et √âcraser',
                        onConfirm: () => {
                            const globalKeys = ['enseignants', 'salles_info', 'enseignant_souhaits', 'matiere_groupes_info', 'filieres', 'volumes_supplementaires', 'creneaux', 'volumes_automne'];
                            const dataKeys = ['LISTE_ENSEIGNANTS', 'SALLES_INFO', 'ENSEIGNANT_SOUHAITS', 'MATIERE_GROUPES_INFO', 'LISTE_FILIERES', 'ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES', 'LISTE_CRENEAUX', 'VOLUMES_AUTOMNE'];
                            
                            dataKeys.forEach((key, index) => {
                                localStorage.setItem(`edt_physique_${globalKeys[index]}`, JSON.stringify(data[key] || {}));
                            });

                            if (data.sessionData) { 
                                localStorage.setItem("edt_physique_seances_Session_d'automne", JSON.stringify(data.sessionData["Session_d'automne"]?.seances || []));
                                localStorage.setItem("edt_physique_nextId_Session_d'automne", data.sessionData["Session_d'automne"]?.nextSessionId || 1);
                                localStorage.setItem("edt_physique_seances_Session_de_printemps", JSON.stringify(data.sessionData["Session_de_printemps"]?.seances || []));
                                localStorage.setItem("edt_physique_nextId_Session_de_printemps", data.sessionData["Session_de_printemps"]?.nextSessionId || 1);
                            } else if (data.seances) { 
                                const sessionToImport = data.headerInfo?.session || "Session d'automne";
                                const sessionKey = `edt_physique_seances_${sessionToImport.replace(/\s+/g, '_')}`;
                                const nextIdKey = `edt_physique_nextId_${sessionToImport.replace(/\s+/g, '_')}`;
                                localStorage.setItem(sessionKey, JSON.stringify(data.seances || []));
                                localStorage.setItem(nextIdKey, data.nextSessionId || 1);
                            }
                            
                            if(data.headerInfo){
                                localStorage.setItem('edt_header_annee', data.headerInfo.annee);
                                localStorage.setItem('edt_header_session', data.headerInfo.session);
                                localStorage.setItem('edt_header_departement', data.headerInfo.departement);
                            }
                            
                            chargerTravail();
                            initialiserTout();
                            logMessage('‚úÖ Projet import√© avec succ√®s. L\'application a √©t√© recharg√©e.', 'success');
                        }
                    });

                } catch (error) {
                    logMessage(`‚ùå Erreur lors de l'importation: ${error.message}`, 'error');
                } finally {
                    event.target.value = '';
                    hideSpinner();
                }
            };
            reader.readAsText(file);
        }

        function telechargerFichier(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        function exporterEDTGlobalPDF() {
            if (typeof jspdf === 'undefined') {
                logMessage("‚ùå ERREUR: La librairie jsPDF n'est pas charg√©e.", 'error');
                return;
            }
            if (seances.length === 0) {
                logMessage('‚ö†Ô∏è Aucun emploi du temps √† exporter.', 'error');
                return;
            }
            
            showSpinner();
            try {
                logMessage('üîÑ G√©n√©ration du PDF de l\'emploi du temps global en cours...', 'initial');

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'landscape',
                    unit: 'pt',
                    format: 'a3'
                });

                const headerInfo = {
                    annee: document.getElementById('inputAnneeUniversitaire').value,
                    session: document.getElementById('selectSession').value,
                    departement: document.getElementById('selectDepartement').value
                };
                
                doc.setFontSize(16);
                doc.text("Facult√© des Sciences - El Jadida", doc.internal.pageSize.getWidth() / 2, 30, { align: 'center' });
                doc.setFontSize(12);
                doc.text(headerInfo.departement, doc.internal.pageSize.getWidth() / 2, 45, { align: 'center' });
                doc.setFontSize(10);
                const subTitle = `Ann√©e Universitaire: ${headerInfo.annee} | Session: ${headerInfo.session}`;
                doc.text(subTitle, doc.internal.pageSize.getWidth() / 2, 60, { align: 'center' });
                doc.setFontSize(14);
                doc.text("Emploi du Temps Global", doc.internal.pageSize.getWidth() / 2, 80, { align: 'center' });

                const sortedCreneaux = getSortedCreneauxKeys();
                const headContent = [];
                sortedCreneaux.forEach(c => {
                    headContent.push(`${c}\n${LISTE_CRENEAUX[c].fin}`);
                    if (c === '10h15') headContent.push('');
                });
                const head = [['Jour/Heure', ...headContent]];
                
                const body = [];
                LISTE_JOURS.forEach(jour => {
                    const rowContent = [];
                    sortedCreneaux.forEach(creneau => {
                        const seancesCell = seances.filter(s => s.jour === jour && s.creneau === creneau);
                        const cellText = seancesCell.map(s => {
                            return `${s.matiere} (${s.type})\n${s.filiere} - ${s.groupe}\n${s.enseignant}\nSalle: ${s.salle}`;
                        }).join('\n---\n');
                        rowContent.push(cellText);
                        if (creneau === '10h15') rowContent.push('');
                    });
                    body.push([jour, ...rowContent]);
                });

                const separatorIndex = sortedCreneaux.indexOf('10h15');
                const columnStyles = { 
                    0: { fontStyle: 'bold', halign: 'left', fillColor: [230, 242, 255], fontSize: 11 }
                };
                if (separatorIndex !== -1) {
                    columnStyles[separatorIndex + 2] = { cellWidth: 10, fillColor: [233, 236, 239] };
                }

                doc.autoTable({
                    head: head,
                    body: body,
                    startY: 90,
                    theme: 'grid',
                    styles: {
                        font: 'arial',
                        fontSize: 9,
                        fontStyle: 'bold',
                        cellPadding: 4,
                        valign: 'middle',
                        halign: 'center',
                        lineWidth: 1,
                        lineColor: [0, 0, 0],
                        minCellHeight: 70
                    },
                    headStyles: {
                        fillColor: [0, 77, 153],
                        textColor: 255,
                        fontSize: 12,
                        font: 'arial',
                        fontStyle: 'bold'
                    },
                    columnStyles: columnStyles
                });

                doc.save(`EDT_Global_${headerInfo.annee.replace('/', '-')}_${headerInfo.session}.pdf`);
                logMessage('‚úÖ Fichier PDF de l\'emploi du temps global g√©n√©r√© et t√©l√©charg√©.', 'success');
            } finally {
                setTimeout(hideSpinner, 500);
            }
        }

        function exporterEDTParEnseignant() {
            if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                logMessage("‚ùå ERREUR: La librairie jsPDF n'est pas charg√©e.", 'error');
                return;
            }

            showSpinner();
            try {
                logMessage('üñ®Ô∏è Pr√©paration du rapport PDF complet...', 'initial');
                
                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({ orientation: 'landscape', unit: 'pt', format: 'a3' });

                const headerInfo = {
                    annee: document.getElementById('inputAnneeUniversitaire').value,
                    session: document.getElementById('selectSession').value,
                    departement: document.getElementById('selectDepartement').value
                };

                const globalMetrics = calculateGlobalVolumeMetrics();
                // MODIFI√â: Utiliser le VHM global brut comme r√©f√©rence
                const VHM_ref = globalMetrics.globalVHM; 
                // MODIFI√â: Calculer le VHM de r√©f√©rence pour la session en cours (Automne ou Printemps)
                let VHM_session_ref = VHM_ref;
                if (headerInfo.session === "Session d'automne") {
                    VHM_session_ref = Math.round(VHM_ref / 2);
                }


                const creneauxTries = getSortedCreneauxKeys();
                const headContent = [];
                creneauxTries.forEach(c => {
                    headContent.push(`${c}\n${LISTE_CRENEAUX[c].fin}`);
                    if (c === '10h15') headContent.push('');
                });
                const head = [['Jour/Heure', ...headContent]];

                const genererPagePourEDT = (titrePage, seancesFiltrees, volumeDetails = null, intervenantsDetails = null) => {
                    
                    // --- Configuration de l'ent√™te de la page ---
                    const pageWidth = doc.internal.pageSize.getWidth();
                    const pageHeight = doc.internal.pageSize.getHeight();
                    const margin = 40; // Marge d√©finie
                    
                    doc.setFontSize(16);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor('#004d99');
                    doc.text("Facult√© des Sciences - El Jadida", pageWidth / 2, 30, { align: 'center' });
                    
                    doc.setFontSize(12);
                    doc.setFont('helvetica', 'normal');
                    doc.setTextColor('#333');
                    doc.text(headerInfo.departement, pageWidth / 2, 45, { align: 'center' });
                    
                    doc.setFontSize(10);
                    const subTitle = `Ann√©e Universitaire: ${headerInfo.annee} | Session: ${headerInfo.session}`;
                    doc.setTextColor('#666');
                    doc.text(subTitle, pageWidth / 2, 60, { align: 'center' });
                    
                    doc.setFontSize(14);
                    doc.setFont('helvetica', 'bold');
                    doc.setTextColor('#004d99');
                    doc.text(titrePage, pageWidth / 2, 80, { align: 'center' });


                    // --- Pr√©paration des donn√©es pour autoTable ---
                    const body = [];
                    LISTE_JOURS.forEach(jour => {
                        const rowContent = [jour];
                        creneauxTries.forEach(creneau => {
                            const seancesCell = seancesFiltrees.filter(s => s.jour === jour && s.creneau === creneau);
                            const cellText = seancesCell.map(s => {
                                return `${s.matiere} (${s.type})\n${s.filiere} - ${s.groupe}\n${s.enseignant}\nSalle: ${s.salle}`;
                            }).join('\n---\n');
                            rowContent.push(cellText);
                            if (creneau === '10h15') rowContent.push(''); // Colonne vide pour s√©parateur
                        });
                        body.push(rowContent);
                    });
                    
                    const separatorIndex = creneauxTries.indexOf('10h15');
                    const columnStyles = {
                        0: { fontStyle: 'bold', halign: 'center', valign: 'middle', fillColor: [230, 242, 255], fontSize: 11 } // Style pour la colonne Jour
                    };
                    if (separatorIndex !== -1) {
                         // +1 pour index 0 (Jour), +1 car on veut la colonne APRES 10h15
                        columnStyles[separatorIndex + 2] = { cellWidth: 10, fillColor: [233, 236, 239] }; // Style pour colonne s√©paratrice
                    }
                    
                    // --- G√©n√©ration de la table ---
                    doc.autoTable({
                        head: head,
                        body: body,
                        startY: 90,
                        theme: 'grid',
                        styles: {
                            font: 'helvetica',
                            fontSize: 8, // R√©duit pour plus de contenu
                            cellPadding: 3,
                            valign: 'middle',
                            halign: 'center',
                            lineWidth: 0.5,
                            lineColor: [200, 200, 200], // Gris plus clair
                            minCellHeight: 60 // R√©duit un peu
                        },
                        headStyles: {
                            fillColor: [0, 115, 230], // Bleu
                            textColor: 255,
                            fontSize: 10, // Un peu plus petit
                            fontStyle: 'bold',
                            halign: 'center',
                            valign: 'middle'
                        },
                        columnStyles: columnStyles,
                        didDrawPage: function(tableData) {
                            const pageHeight = doc.internal.pageSize.getHeight();
                            const pageWidth = doc.internal.pageSize.getWidth();
                            const margin = 40; // Marge de la page
                            
                            let currentY = tableData.cursor.y + 15; // Y position after the main table
    
                            // 1. Afficher le R√©capitulatif du Volume (si pr√©sent)
                            if (volumeDetails) {
                                const volumeText = `R√©capitulatif (hTP): Enseignement: ${volumeDetails.enseignement} | Heures sup: ${volumeDetails.forfait} | Total Session: ${volumeDetails.total} | VHM Session: ${VHM_session_ref}`;
                                doc.setFontSize(10);
                                doc.setFont('helvetica', 'normal');
                                doc.setTextColor('#333');
                                
                                if (currentY < pageHeight - 30) { // Check if space remains
                                    doc.text(volumeText, margin, currentY);
                                    currentY += 20; // Add space after the text
                                }
                            }
    
                            // 2. Afficher les tables des Intervenants (si pr√©sents)
                            if (intervenantsDetails && Object.keys(intervenantsDetails).length > 0) {
                                doc.setFontSize(11);
                                doc.setFont('helvetica', 'bold');
                                doc.setTextColor('#333');
                                
                                if (currentY < pageHeight - 30) {
                                    doc.text('R√©capitulatif des Intervenants par Mati√®re :', margin, currentY);
                                    currentY += 15;
                                }
    
                                // Boucle sur chaque mati√®re enseign√©e par cet enseignant
                                for (const matiere in intervenantsDetails) {
                                    const data = intervenantsDetails[matiere];
                                    
                                    // V√©rifie s'il y a assez de place pour le titre + au moins une ligne de table
                                    if (currentY > pageHeight - 80) { 
                                        doc.addPage(); // Ajoute une nouvelle page si pas assez de place
                                        // R√©initialise Y au d√©but de la nouvelle page (avec l'en-t√™te de page standard)
                                        // Note: Pour une version compl√®te, il faudrait redessiner l'en-t√™te de page ici.
                                        currentY = margin; 
                                    }
    
                                    // Titre de la mati√®re
                                    doc.setFontSize(10);
                                    doc.setFont('helvetica', 'bold');
                                    doc.setTextColor('#004d99');
                                    doc.text(matiere, margin, currentY);
                                    currentY += 5; // Espace avant la table
    
                                    const tableBody = [];
                                    const coursIntervenants = (data['Cours'] || []).join(', ') || '-';
                                    const tdIntervenants = (data['TD'] || []).join(', ') || '-';
                                    const tpIntervenants = (data['TP'] || []).join(', ') || '-';
    
                                    // N'ajoute la ligne que si elle contient des intervenants (ou '-' si aucun)
                                    // Ceci est plus propre que de masquer les lignes vides
                                    tableBody.push(['Cours', coursIntervenants]);
                                    tableBody.push(['TD', tdIntervenants]);
                                    tableBody.push(['TP', tpIntervenants]);
    
                                    // Dessiner la table pour cette mati√®re
                                    doc.autoTable({
                                        startY: currentY,
                                        head: [['Type', 'Intervenants']],
                                        body: tableBody,
                                        theme: 'grid',
                                        margin: { left: margin, right: margin }, // S'aligne sur la marge de la page
                                        tableWidth: 'auto', // Ajuste la largeur au contenu
                                        styles: { fontSize: 8, cellPadding: 2, overflow: 'linebreak' },
                                        headStyles: { 
                                            fillColor: [230, 242, 255], // Fond bleu clair
                                            textColor: [0, 77, 153], // Texte bleu fonc√©
                                            fontSize: 9, 
                                            fontStyle: 'bold' 
                                        },
                                        columnStyles: {
                                            0: { fontStyle: 'bold', cellWidth: 40 }, // Type (Cours, TD, TP) en gras
                                            1: { cellWidth: 'auto' } // Laisser autoTable g√©rer la largeur de la liste des noms
                                        }
                                    });
                                    
                                    // Mettre √† jour currentY pour la prochaine table
                                    currentY = doc.autoTable.previous.finalY + 10;
                                }
                            }
                            
                            // 3. Ajout du num√©ro de page et date (toujours en bas)
                            const pageCount = doc.internal.getNumberOfPages();
                            doc.setFontSize(8);
                            doc.setTextColor('#888');
                            const date = new Date().toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                            doc.text(`G√©n√©r√© le ${date}`, margin, pageHeight - 15);
                            doc.text(`Page ${pageCount}`, pageWidth - margin, pageHeight - 15, { align: 'right' });
                        }
                    });
                }; // Fin de genererPagePourEDT


                const pagesAgenerer = [];

                if (seances.length > 0) {
                    pagesAgenerer.push({
                        titre: "Emploi du Temps Global",
                        seances: seances
                    });
                }

                // AJOUT√â: Boucle pour g√©n√©rer les pages par fili√®re
                getFiliereNomsForCurrentSession().forEach(filiereNom => {
                    const sessionsFiliere = seances.filter(s => s.filiere === filiereNom);
                    if (sessionsFiliere.length > 0) {
                        pagesAgenerer.push({
                            titre: `Emploi du Temps - Fili√®re ${filiereNom}`,
                            seances: sessionsFiliere
                        });
                    }
                });


                // MODIFI√â: La boucle inclut maintenant TOUS les enseignants
                LISTE_ENSEIGNANTS.forEach(enseignant => {
                    const sessionsEnseignant = seances.filter(s => s.enseignantsArray.includes(enseignant));
                    // On ne v√©rifie plus si sessionsEnseignant.length > 0 ici
                    
                    // Calcul des intervenants (reste identique, g√®re le cas o√π sessionsEnseignant est vide)
                    const matieresEnseignees = [...new Set(sessionsEnseignant.map(s => s.matiere))];
                    const intervenantsParMatiere = {};
                    matieresEnseignees.forEach(matiere => {
                        const intervenantsParType = {}; 
                        seances.filter(s => s.matiere === matiere).forEach(seancePourMatiere => {
                            const type = seancePourMatiere.type;
                            if (!intervenantsParType[type]) {
                                intervenantsParType[type] = new Set();
                            }
                            seancePourMatiere.enseignantsArray.forEach(ens => intervenantsParType[type].add(ens));
                        });
                        const intervenantsData = {};
                        for (const type in intervenantsParType) {
                            intervenantsData[type] = [...intervenantsParType[type]].sort();
                        }
                        if (Object.keys(intervenantsData).length > 0) {
                            intervenantsParMatiere[matiere] = intervenantsData;
                        }
                    });

                    // Calcul du volume (reste identique, g√®re le cas o√π sessionsEnseignant est vide)
                    const volumeDetails = calculerDetailsVolume(enseignant, sessionsEnseignant, ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES);

                    // Ajout syst√©matique de la page pour l'enseignant
                    pagesAgenerer.push({
                        titre: `Emploi du Temps - ${enseignant}`,
                        seances: sessionsEnseignant, // Sera vide si aucune s√©ance
                        volume: volumeDetails,       // Sera {enseignement: 0, forfait: X, total: X} si aucune s√©ance
                        intervenants: intervenantsParMatiere // Sera {} si aucune s√©ance
                    });
                });
                // FIN DE LA MODIFICATION

                if (pagesAgenerer.length === 0 && LISTE_ENSEIGNANTS.length === 0) { // Ajout d'une condition pour le cas sans enseignants
                    logMessage('‚ö†Ô∏è Aucune s√©ance n\'est planifi√©e et aucun enseignant n\'est enregistr√©. Impossible de g√©n√©rer un rapport.', 'error');
                    hideSpinner(); // Assurez-vous que le spinner est cach√© en cas d'erreur
                    return;
                }

                pagesAgenerer.forEach((page, index) => {
                    genererPagePourEDT(page.titre, page.seances, page.volume, page.intervenants);
                    if (index < pagesAgenerer.length - 1) {
                        doc.addPage();
                    }
                });
                
                doc.save(`Rapport_EDT_Complet_${headerInfo.annee.replace('/', '-')}_${headerInfo.session}.pdf`);
                logMessage('‚úÖ Fichier PDF du rapport complet g√©n√©r√© et t√©l√©charg√© (incluant tous les enseignants).', 'success');
            } finally {
                setTimeout(hideSpinner, 500);
            }
        }

        function exporterEDTZipExcelsStylises() {
             if (typeof XLSX === 'undefined' || typeof JSZip === 'undefined') {
                logMessage("‚ùå ERREUR: Les librairies JSZip ou XLSX ne sont pas charg√©es.", 'error');
                return;
            }
            if (seances.length === 0) {
                logMessage('‚ö†Ô∏è Aucun emploi du temps √† exporter. La table est vide.', 'error');
                return;
            }

            showSpinner();
            try {
                logMessage('üîÑ G√©n√©ration du fichier Excel multi-feuilles en cours...', 'initial');

                const wb = XLSX.utils.book_new();
                const headerInfo = {
                    annee: document.getElementById('inputAnneeUniversitaire').value,
                    session: document.getElementById('selectSession').value,
                    departement: document.getElementById('selectDepartement').value
                };
                const titrePrincipal = `${headerInfo.departement} - ${headerInfo.annee} - ${headerInfo.session}`;

                const creerFeuilleExcel = (title, seancesFiltrees) => {
                    const ws_data = [];
                    const merges = [];

                    ws_data.push([titrePrincipal]);
                    ws_data.push([`Emploi du Temps - ${title}`]);
                    ws_data.push([]); 

                    const creneauxTries = getSortedCreneauxKeys();
                    const headerContent = [];
                    const colWidths = [{ wch: 15 }];

                    creneauxTries.forEach(c => {
                        headerContent.push(`${c} - ${LISTE_CRENEAUX[c].fin}`);
                        colWidths.push({ wch: 30 });
                        if (c === '10h15') {
                            headerContent.push('');
                            colWidths.push({ wch: 3 });
                        }
                    });
                    const headerRow = ['Jour/Heure', ...headerContent];
                    ws_data.push(headerRow);
                    
                    LISTE_JOURS.forEach((jour, r_idx) => {
                        const row = [jour];
                        creneauxTries.forEach((creneau, c_idx) => {
                            const seancesCell = seancesFiltrees.filter(s => s.jour === jour && s.creneau === creneau);
                            const cellText = seancesCell.map(s => {
                                return `${s.matiere} (${s.type})\n${s.filiere} - ${s.groupe}\n${s.enseignant}\nSalle: ${s.salle}`;
                            }).join('\n\n');
                            row.push(cellText);
                            
                            const seanceTP = seancesCell.find(s => s.type === 'TP');
                            if(seanceTP && CRENEAUX_COUPLES_SUIVANT[creneau]) {
                                let merge_start_col = c_idx + 1;
                                const separatorIndex = creneauxTries.indexOf('10h15');
                                if (c_idx > separatorIndex) {
                                    merge_start_col += 1;
                                }
                                merges.push({ s: { r: r_idx + 3, c: merge_start_col }, e: { r: r_idx + 3, c: merge_start_col + 1 } });
                            }
                            if (creneau === '10h15') {
                                row.push('');
                            }
                        });
                        ws_data.push(row);
                    });
                    
                    const ws = XLSX.utils.aoa_to_sheet(ws_data);
                    ws['!merges'] = merges;
                    ws['!cols'] = colWidths;
                    ws['!rows'] = [{ hpt: 20 }, { hpt: 20 }, { hpt: 10 }];
                    for(let i=0; i < LISTE_JOURS.length; i++) { 
                        ws['!rows'].push({ hpt: 80 }); 
                    }
                    
                    return ws;
                };

                wb.SheetNames.push("Global");
                wb.Sheets["Global"] = creerFeuilleExcel("Global (Toutes fili√®res)", seances);
                
                // CORRECTION APPLIQU√âE ICI
                // On it√®re sur LISTE_FILIERES, qui contient des objets {nom: ..., session: ...}
                LISTE_FILIERES.forEach(filiereObj => {
                    // On utilise la propri√©t√© .nom pour le nom de la feuille et le filtrage
                    const filiereNom = filiereObj.nom; 
                    const sheetName = filiereNom.replace(/[^a-zA-Z0-9]/g, '').substring(0, 31);
                    const seancesFiltrees = seances.filter(s => s.filiere === filiereNom);
                    
                    if (seancesFiltrees.length > 0) {
                        wb.SheetNames.push(sheetName);
                        // On passe le nom (filiereNom) √† la fonction de cr√©ation de feuille
                        wb.Sheets[sheetName] = creerFeuilleExcel(filiereNom, seancesFiltrees);
                    }
                });
                // FIN DE LA CORRECTION

                LISTE_ENSEIGNANTS.forEach(enseignant => {
                    const sheetName = enseignant.replace(/[^a-zA-Z0-9]/g, '').substring(0, 31);
                    const seancesFiltrees = seances.filter(s => s.enseignantsArray.includes(enseignant));
                    if (seancesFiltrees.length > 0) {
                        wb.SheetNames.push(sheetName);
                        wb.Sheets[sheetName] = creerFeuilleExcel(`Enseignant - ${enseignant}`, seancesFiltrees);
                    }
                });

                const excelBuffer = XLSX.write(wb, { bookType: 'xlsx', type: 'array' });
                telechargerFichier(excelBuffer, `EDT_${headerInfo.annee.replace('/', '-')}_${headerInfo.session}.xlsx`, 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet');
                logMessage('‚úÖ Fichier Excel multi-feuilles g√©n√©r√© et t√©l√©charg√©.', 'success');
            
            } catch (error) { // <-- BLOC AJOUT√â
                logMessage(`‚ùå Erreur critique lors de la g√©n√©ration Excel: ${error.message}`, 'error');
                console.error("D√©tail de l'erreur Excel:", error);
            
            } finally {
                setTimeout(hideSpinner, 500);
            }
        }

        // MODIFI√â: La fonction d'exportation de la vue actuelle a √©t√© enti√®rement r√©√©crite pour une meilleure mise en page.
        function exportCurrentViewToPDF() {
            if (typeof jspdf === 'undefined' || typeof jspdf.jsPDF === 'undefined') {
                logMessage("‚ùå ERREUR: La librairie jsPDF n'est pas charg√©e.", 'error');
                return;
            }
            
            // --- √âTAPE 1: R√©cup√©rer les s√©ances √† afficher (logique identique √† l'affichage) ---
            const searchMatiere = document.getElementById('searchMatiere').value.toLowerCase().trim();
            const searchEnseignant = document.getElementById('searchEnseignant').value.toLowerCase().trim();
            const searchSalle = document.getElementById('searchSalle').value.toLowerCase().trim();
            const hasActiveSearch = searchMatiere || searchEnseignant || searchSalle;
            const filtreVue = document.getElementById('selectEDTView').value;
            let seancesAffichees = seances;

            if (filtreVue === 'enseignant_selectionne') {
                const enseignant1 = document.getElementById('inputEnseignant1').value;
                const enseignant2 = document.getElementById('inputEnseignant2').value;
                const teacher = enseignant2 && enseignant2 !== '' ? enseignant2 : enseignant1;
                seancesAffichees = teacher ? seances.filter(s => s.enseignantsArray.includes(teacher)) : [];
            } else if (filtreVue !== 'global') {
                seancesAffichees = seances.filter(s => s.filiere === filtreVue);
            }

            if (hasActiveSearch) {
                seancesAffichees = seancesAffichees.filter(s => {
                    const matchesMatiere = !searchMatiere || (s.matiere || '').toLowerCase().includes(searchMatiere);
                    const matchesEnseignant = !searchEnseignant || (s.enseignant || '').toLowerCase().includes(searchEnseignant);
                    const matchesSalle = !searchSalle || (s.salle || '').toLowerCase().includes(searchSalle);
                    return matchesMatiere && matchesEnseignant && matchesSalle;
                });
            }

            if (seancesAffichees.length === 0) {
                 logMessage('‚ö†Ô∏è Aucun emploi du temps √† exporter dans la vue actuelle.', 'error');
                 return;
            }

            showSpinner();
            try {
                logMessage('üîÑ G√©n√©ration du PDF de la vue actuelle en cours...', 'initial');

                const { jsPDF } = window.jspdf;
                const doc = new jsPDF({
                    orientation: 'landscape',
                    unit: 'pt',
                    format: 'a3'
                });

                const headerInfo = {
                    annee: document.getElementById('inputAnneeUniversitaire').value,
                    session: document.getElementById('selectSession').value,
                    departement: document.getElementById('selectDepartement').value
                };
                
                const selectEDTView = document.getElementById('selectEDTView');
                const viewTitleText = selectEDTView.options[selectEDTView.selectedIndex].text;
                const mainTitle = `Emploi du Temps - ${viewTitleText}`;

                // --- Ent√™te du document PDF ---
                doc.setFontSize(18);
                doc.setFont('helvetica', 'bold');
                doc.setTextColor('#004d99');
                doc.text("Facult√© des Sciences - El Jadida", doc.internal.pageSize.getWidth() / 2, 40, { align: 'center' });
                doc.setDrawColor('#e6f2ff');
                doc.line(40, 50, doc.internal.pageSize.getWidth() - 40, 50);

                doc.setFontSize(14);
                doc.setFont('helvetica', 'normal');
                doc.setTextColor('#333');
                doc.text(mainTitle, doc.internal.pageSize.getWidth() / 2, 70, { align: 'center' });
                
                doc.setFontSize(10);
                const subTitle = `${headerInfo.departement} | Ann√©e: ${headerInfo.annee} | Session: ${headerInfo.session}`;
                doc.setTextColor('#666');
                doc.text(subTitle, doc.internal.pageSize.getWidth() / 2, 85, { align: 'center' });
                
                const activeFilters = [];
                if (searchMatiere) activeFilters.push(`Mati√®re: '${searchMatiere}'`);
                if (searchEnseignant) activeFilters.push(`Enseignant: '${searchEnseignant}'`);
                if (searchSalle) activeFilters.push(`Salle: '${searchSalle}'`);

                let tableStartY = 110;
                if (activeFilters.length > 0) {
                    const filterText = `Filtres actifs : ${activeFilters.join(' / ')}`;
                    doc.setFontSize(9);
                    doc.setFont('helvetica', 'italic');
                    doc.setTextColor('#888');
                    doc.text(filterText, doc.internal.pageSize.getWidth() / 2, 100, { align: 'center' });
                    tableStartY = 120;
                }

                const sortedCreneaux = getSortedCreneauxKeys();
                // MODIFI√â: Ajout de la colonne de s√©paration dans l'en-t√™te
                const headContent = [];
                sortedCreneaux.forEach(c => {
                    headContent.push(`${c}\n${LISTE_CRENEAUX[c].fin}`);
                    if (c === '10h15') {
                        headContent.push(''); 
                    }
                });
                const head = [['Jour/Heure', ...headContent]];
                
                const body = [];
                LISTE_JOURS.forEach(jour => {
                    const rowContent = [jour];
                    sortedCreneaux.forEach(creneau => {
                        const seancesCell = seancesAffichees.filter(s => s.jour === jour && s.creneau === creneau);
                        rowContent.push(seancesCell);
                        // MODIFI√â: Ajout d'une cellule vide pour la s√©paration
                        if (creneau === '10h15') {
                            rowContent.push('');
                        }
                    });
                    body.push(rowContent);
                });

                // --- NOUVEAU STYLE (identique √† l'affichage) ---
                const COLORS = {
                    Cours: { bg: [255, 221, 221], border: [204, 0, 0] }, // #ffdddd, #cc0000
                    TD:    { bg: [221, 255, 221], border: [0, 153, 0] },   // #ddffdd, #009900
                    TP:    { bg: [221, 221, 255], border: [0, 0, 204] }    // #ddddff, #0000cc
                };

                // MODIFI√â: Ajout du style pour la colonne de s√©paration et uniformisation
                const separatorIndex = getSeparatorColumnIndex();
                const columnStyles = {};

                const totalWidth = doc.internal.pageSize.getWidth() - 80; // Largeur A3 paysage - marges G/D de 40pt
                const jourColWidth = 80;
                const separatorColWidth = 10;
                const numCreneauxCols = sortedCreneaux.length;
                
                // Calculer la largeur restante pour les cr√©neaux et diviser √©quitablement
                const creneauxTotalWidth = totalWidth - jourColWidth - separatorColWidth;
                const creneauColWidth = creneauxTotalWidth / numCreneauxCols;

                // Appliquer les largeurs calcul√©es
                columnStyles[0] = { cellWidth: jourColWidth, fontStyle: 'bold', halign: 'center', valign: 'middle', fillColor: [230, 242, 255], fontSize: 11 };

                const numberOfColumns = head[0].length;
                for (let i = 1; i < numberOfColumns; i++) {
                    if (i === separatorIndex) {
                        columnStyles[i] = { cellWidth: separatorColWidth, fillColor: [233, 236, 239] };
                    } else {
                        // Toutes les autres colonnes (cr√©neaux) ont la m√™me largeur calcul√©e
                        columnStyles[i] = { cellWidth: creneauColWidth };
                    }
                }


                doc.autoTable({
                    head: head,
                    body: body,
                    startY: tableStartY,
                    theme: 'grid',
                    styles: {
                        font: 'helvetica',
                        fontSize: 8,
                        cellPadding: 2,
                        valign: 'top',
                        lineWidth: 0.5,
                        lineColor: [221, 221, 221],
                        minCellHeight: 90 
                    },
                    headStyles: {
                        fillColor: [0, 115, 230],
                        textColor: 255,
                        fontSize: 11,
                        fontStyle: 'bold',
                        halign: 'center',
                        valign: 'middle',
                        cellPadding: 8
                    },
                    columnStyles: columnStyles, // MODIFI√â: Application des styles de colonne
                    didDrawCell: function(data) {
                        if (data.section !== 'body' || !Array.isArray(data.cell.raw) || data.column.index === 0 || data.column.index === separatorIndex) {
                            return;
                        }
                        
                        const seancesDansCellule = data.cell.raw;
                        if (seancesDansCellule.length === 0) return;

                        const cell = data.cell;
                        const cellPadding = 4;
                        const y = cell.y + cellPadding / 2;
                        const usableHeight = cell.height - cellPadding;
                        const heightPerSeance = seancesDansCellule.length > 0 ? usableHeight / seancesDansCellule.length : usableHeight;

                        seancesDansCellule.forEach((seance, index) => {
                            const startY = y + (index * heightPerSeance);
                            const colorInfo = COLORS[seance.type] || { bg: [240, 240, 240], border: [150, 150, 150] };

                            // Fond color√© de la s√©ance
                            doc.setFillColor(...colorInfo.bg);
                            doc.rect(cell.x + 1, startY, cell.width - 2, heightPerSeance - 1, 'F');
                            
                            // Bordure gauche color√©e
                            doc.setDrawColor(...colorInfo.border);
                            doc.setLineWidth(5);
                            doc.line(cell.x, startY, cell.x, startY + heightPerSeance - 1);

                            // --- MODIFI√â: Logique de taille de police adaptative ET centrage vertical ---
                            const textX = cell.x + cell.width / 2;
                            const textWidth = cell.width - 12;

                            let titleFontSize = 7.5;
                            let detailFontSize = 6.5;
                            const minTitleFontSize = 5;
                            const minDetailFontSize = 4.5;
                            const lineHeightFactor = 1.15; // Un peu plus serr√©

                            const calculateRequiredHeight = (currentTitleSize, currentDetailSize) => {
                                doc.setFont('helvetica', 'bold');
                                doc.setFontSize(currentTitleSize);
                                const titleLines = doc.splitTextToSize(`${seance.matiere} (${seance.type})`, textWidth);
                                
                                doc.setFont('helvetica', 'normal');
                                doc.setFontSize(currentDetailSize);
                                const detailLinesContent = [`${seance.filiere} - ${seance.groupe}`, seance.enseignant || 'N/A', `Salle: ${seance.salle}`];
                                let detailLinesCount = 0;
                                detailLinesContent.forEach(line => {
                                    if (line) detailLinesCount += doc.splitTextToSize(line, textWidth).length;
                                });

                                return (titleLines.length * currentTitleSize * lineHeightFactor) + (detailLinesCount * currentDetailSize * lineHeightFactor);
                            };

                            const availableHeight = heightPerSeance - 4; // padding vertical
                            let requiredHeight = calculateRequiredHeight(titleFontSize, detailFontSize);

                            while (requiredHeight > availableHeight && titleFontSize > minTitleFontSize) {
                                titleFontSize = Math.max(minTitleFontSize, titleFontSize - 0.25);
                                detailFontSize = Math.max(minDetailFontSize, detailFontSize - 0.25);
                                requiredHeight = calculateRequiredHeight(titleFontSize, detailFontSize);
                            }

                            // --- Dessin du texte avec la taille de police calcul√©e ---
                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(titleFontSize);
                            const titleLines = doc.splitTextToSize(`${seance.matiere} (${seance.type})`, textWidth);
                            
                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(detailFontSize);
                            const detailLinesContent = [`${seance.filiere} - ${seance.groupe}`, seance.enseignant || 'N/A', `Salle: ${seance.salle}`];
                            const detailSplitLines = [];
                            detailLinesContent.forEach(line => {
                                if (line) detailSplitLines.push(...doc.splitTextToSize(line, textWidth));
                            });
                            
                            const finalTitleHeight = titleLines.length * titleFontSize * lineHeightFactor;
                            const finalDetailHeight = detailSplitLines.length * detailFontSize * lineHeightFactor;
                            const totalTextHeight = finalTitleHeight + finalDetailHeight;
                            
                            let textY = startY + (heightPerSeance - totalTextHeight) / 2 + (titleFontSize); // Centrage vertical

                            doc.setFont('helvetica', 'bold');
                            doc.setFontSize(titleFontSize);
                            doc.setTextColor(33, 33, 33);
                            doc.text(titleLines, textX, textY, { align: 'center' });
                            textY += finalTitleHeight;

                            doc.setFont('helvetica', 'normal');
                            doc.setFontSize(detailFontSize);
                            doc.setTextColor(85, 85, 85);
                            doc.text(detailSplitLines, textX, textY, { align: 'center' });
                        });
                    },
                    didDrawPage: function(data) {
                        const pageCount = doc.internal.getNumberOfPages();
                        doc.setFontSize(8);
                        doc.setTextColor('#888');
                        const date = new Date().toLocaleDateString('fr-FR', { day: '2-digit', month: '2-digit', year: 'numeric' });
                        doc.text(`G√©n√©r√© le ${date}`, data.settings.margin.left, doc.internal.pageSize.getHeight() - 15);
                        doc.text(`Page ${pageCount}`, doc.internal.pageSize.getWidth() - data.settings.margin.right, doc.internal.pageSize.getHeight() - 15, { align: 'right' });
                    }
                });

                const safeFilename = viewTitleText.replace(/[^a-z0-9]/gi, '_').toLowerCase();
                doc.save(`EDT_Vue_${safeFilename}.pdf`);
                logMessage('‚úÖ PDF de la vue actuelle g√©n√©r√© avec le style de l\'affichage.', 'success');
            } finally {
                setTimeout(hideSpinner, 500);
            }
        }

        function genererNotificationManquants(filtreVue) {
            if (filtreVue === 'global' || filtreVue === 'enseignant_selectionne' || !filtreVue) {
                return '';
            }

            const plannedGroupsSets = calculerGroupesPlanifi√©s(seances); // Get Sets
            const matieresDeLaFiliere = LISTE_MATIERES.filter(m => MATIERE_GROUPES_INFO[m]?.filiere === filtreVue);
            
            if (matieresDeLaFiliere.length === 0) {
                return '';
            }

            const messagesManquants = []; // This will hold { matiere, type, manquant: [groupName1, groupName2] }
            const regroupesParMatiere = {}; // Object to group messages for final display

            // --- RE-INSERTED DETAILED CALCULATION LOGIC ---
            matieresDeLaFiliere.forEach(matiere => {
                const info = MATIERE_GROUPES_INFO[matiere];
                if (!info) return; // Skip if no info for this matiere

                const requiredEntitiesForMatiere = { Cours: new Set(), TD: new Set(), TP: new Set() };
                const sections = info.sections_cours || 0;
                const tdGroups = info.td_groups || 0;
                const tpGroups = info.tp_groups || 0;

                // Build the set of required unique entities (e.g., "S3 P - Section A", "S3 P - Section A - G1")
                for (let s = 0; s < sections; s++) {
                    const sectionName = `Section ${String.fromCharCode(65 + s)}`;
                    const coursEntity = `${filtreVue} - ${sectionName}`;
                    requiredEntitiesForMatiere.Cours.add(coursEntity);
                    for (let g = 1; g <= tdGroups; g++) {
                        requiredEntitiesForMatiere.TD.add(`${coursEntity} - G${g}`);
                    }
                    for (let g = 1; g <= tpGroups; g++) {
                        requiredEntitiesForMatiere.TP.add(`${coursEntity} - G${g}`);
                    }
                }

                // Compare required with planned (using Sets)
                const plannedForMatiere = plannedGroupsSets[matiere] || { Cours: new Set(), TD: new Set(), TP: new Set() };

                ['Cours', 'TD', 'TP'].forEach(type => {
                    const manquants = [];
                    requiredEntitiesForMatiere[type].forEach(entity => {
                        if (!plannedForMatiere[type].has(entity)) {
                            // Extract readable group/section name
                            const parts = entity.split(' - ');
                            // For Cours: "Section A", For TD/TP: "Section A G1"
                            manquants.push(parts.slice(1).join(' ')); 
                        }
                    });

                    if (manquants.length > 0) {
                         // Populate regroupesParMatiere directly here
                        if (!regroupesParMatiere[matiere]) {
                            regroupesParMatiere[matiere] = [];
                        }
                        regroupesParMatiere[matiere].push({
                            type: type,
                            manquant: manquants.sort(), // Store the list of missing group names
                            matiere: matiere // Add matiere here for easier access later
                        });
                    }
                });
            });
            // --- END OF RE-INSERTED LOGIC ---

            // Check if any missing groups were found AFTER the calculation
            if (Object.keys(regroupesParMatiere).length > 0) {
                // Generate HTML only if there are missing groups
                let html = `
                    <div class="p-4 mb-4 text-sm text-yellow-800 rounded-lg bg-yellow-50 border border-yellow-300" role="alert">
                        <div class="flex items-center">
                            <svg class="flex-shrink-0 inline w-4 h-4 me-3" aria-hidden="true" xmlns="http://www.w3.org/2000/svg" fill="currentColor" viewBox="0 0 20 20">
                                <path d="M10 .5a9.5 9.5 0 1 0 9.5 9.5A9.51 9.51 0 0 0 10 .5ZM9.5 4a1.5 1.5 0 1 1 0 3 1.5 1.5 0 0 1 0-3ZM12 15H8a1 1 0 0 1 0-2h1v-3H8a1 1 0 0 1 0-2h2a1 1 0 0 1 1 1v4h1a1 1 0 0 1 0 2Z"/>
                            </svg>
                            <span class="sr-only">Info</span>
                            <h3 class="text-lg font-medium">Groupes non planifi√©s pour la fili√®re ${filtreVue}:</h3>
                        </div>
                        <!-- MODIFI√â: Utilisation de flex flex-wrap pour aligner les blocs de mati√®res -->
                        <div class="mt-2 flex flex-wrap gap-x-6 gap-y-3"> 
                `;

                // MODIFI√â: Nouvelle structure pour l'affichage compact
                for (const matiere in regroupesParMatiere) {
                    // Conteneur pour une mati√®re (reste un flex item)
                    html += `<div class="p-2 rounded bg-yellow-100 border border-yellow-200">`; 
                    // Header: Mati√®re - Fili√®re
                    html += `<strong class="text-base text-yellow-900 mr-2">${matiere} - ${filtreVue}:</strong>`; 
                    
                    // Conteneur inline pour les d√©tails (Cours, TD, TP)
                    html += `<span class="inline-flex flex-wrap gap-x-3 gap-y-1">`; 
                    
                    regroupesParMatiere[matiere].forEach(detail => {
                        // Structure interne (relative + details/summary + absolute div)
                        html += `<div class="relative"> 
                                    <details class="text-sm">
                                        <summary class="cursor-pointer font-semibold hover:text-yellow-950 bg-yellow-200 px-2 py-1 rounded inline-block" title="Cliquez pour voir les groupes manquants">
                                            ${detail.type}(${detail.manquant.length})
                                        </summary>
                                        <div class="absolute left-0 mt-1 p-2 bg-white rounded border border-yellow-300 shadow-lg z-10 min-w-[200px]" style="max-width: 300px;"> 
                                            <span class="text-xs font-mono block whitespace-normal break-words">${detail.manquant.join(', ')}</span>
                                        </div>
                                    </details>
                                 </div>`;
                    });

                    html += `</span></div>`; // Fin de inline-flex et du div de la mati√®re
                }

                html += '</div></div>'; // Fin de flex-wrap et de la div principale de notification
                return html;
            }

            return ''; // Return empty string if no missing groups were found after calculation
        }

        function actualiserAffichage() {
            const table = document.getElementById('edtTable');
            const hTPBody = document.getElementById('hTPBody');
            
            const searchMatiere = document.getElementById('searchMatiere').value.toLowerCase().trim();
            const searchEnseignant = document.getElementById('searchEnseignant').value.toLowerCase().trim();
            const searchSalle = document.getElementById('searchSalle').value.toLowerCase().trim();
            const searchSectionGroupe = document.getElementById('searchSectionGroupe').value.toLowerCase().trim(); // NOUVEAU
            const hasActiveSearch = searchMatiere || searchEnseignant || searchSalle || searchSectionGroupe; // MODIFI√â

            const filtreVue = document.getElementById('selectEDTView').value;
            let seancesAffichees = seances;

            const notificationArea = document.getElementById('edt-notification-area');
            if (notificationArea) {
                notificationArea.innerHTML = genererNotificationManquants(filtreVue);
            }

            if (filtreVue === 'enseignant_selectionne') {
                const enseignant1 = document.getElementById('inputEnseignant1').value;
                const enseignant2 = document.getElementById('inputEnseignant2').value;
                const teacher = enseignant2 && enseignant2 !== '' ? enseignant2 : enseignant1;

                if (teacher) {
                    seancesAffichees = seances.filter(s => s.enseignantsArray.includes(teacher));
                } else {
                    seancesAffichees = []; 
                    logMessage("‚ÑπÔ∏è S√©lectionnez un enseignant dans le formulaire pour afficher son emploi du temps.", 'initial');
                }

            } else if (filtreVue !== 'global') {
                seancesAffichees = seances.filter(s => s.filiere === filtreVue);
            }
            
            if (hasActiveSearch) {
                seancesAffichees = seancesAffichees.filter(s => {
                    const matchesMatiere = !searchMatiere || (s.matiere || '').toLowerCase().includes(searchMatiere);
                    const matchesEnseignant = !searchEnseignant || (s.enseignant || '').toLowerCase().includes(searchEnseignant);
                    const matchesSalle = !searchSalle || (s.salle || '').toLowerCase().includes(searchSalle);
                    // NOUVELLE CONDITION DE FILTRE
                    const matchesSectionGroupe = !searchSectionGroupe || (s.groupe || '').toLowerCase().includes(searchSectionGroupe);
                    return matchesMatiere && matchesEnseignant && matchesSalle && matchesSectionGroupe; // MODIFI√â
                });
            }
            
            table.innerHTML = ''; 

            let header = '<tr><th>Jour/Heure</th>';
            const sortedCreneaux = getSortedCreneauxKeys();
            sortedCreneaux.forEach(c => {
                header += `<th>${c} - ${LISTE_CRENEAUX[c].fin}</th>`;
                if (c === '10h15') {
                    header += '<th class="separator-column"></th>';
                }
            });
            table.innerHTML += header + '</tr>';

            LISTE_JOURS.forEach(jour => {
                let row = `<tr><td class="jour-header">${jour}</td>`; 

                sortedCreneaux.forEach(creneau => {
                    const seancesCell = seancesAffichees.filter(s => s.jour === jour && s.creneau === creneau);
                    
                    let cellContent = `<td data-jour="${jour}" data-creneau="${creneau}" 
                                           ondragover="handleDragOver(event)" 
                                           ondragleave="handleDragLeave(event)" 
                                           ondrop="handleDrop(event)">
                                           <button class="add-seance-in-cell-btn" 
                                                   onclick="attribuerSeanceDirectement('${jour}', '${creneau}')" 
                                                   title="Attribuer la s√©ance configur√©e ici">+</button>`;

                    if (seancesCell.length > 0) {
                        seancesCell.forEach(seance => {
                            const filiereDisplay = seance.filiere ? `<span class="filiere-section">${seance.filiere}</span>` : '';
                            const groupeDisplay = seance.groupe && seance.groupe !== 'N/A' ? `<span class="groupe-section">${seance.groupe}</span><br>` : '';
                            
                            const enseignantsDisplay = seance.enseignant ? `<span class="enseignants">${seance.enseignant}</span><br>` : '';
                            const highlightClass = hasActiveSearch ? 'highlight-search' : '';
                            // NOUVEAU: Ajout de la classe si la s√©ance n'est pas attribu√©e
                            const nonAttribueeClass = (seance.enseignantsArray.length === 0 || seance.enseignant === '√Ä attribuer') ? 'seance-non-attribuee' : ''; 

                            cellContent += `
                                <div class="seance ${seance.type} ${highlightClass} ${nonAttribueeClass}" data-id="${seance.id}">
                                    <button class="delete-btn" onclick="supprimerSeance(${seance.id})">x</button>
                                    <div class="seance-data" draggable="true" ondragstart="handleDragStart(event, ${seance.id})" ondragend="handleDragEnd(event)" onclick="ouvrirFormulairePourModifier(${seance.id})">
                                        <strong>${seance.matiere} (${seance.type})</strong><br>
                                        ${filiereDisplay}
                                        ${groupeDisplay}
                                        ${enseignantsDisplay}
                                        <small>${seance.salle}</small>
                                    </div>
                                </div>
                            `;
                        });
                    }
                    
                    cellContent += '</td>';
                    row += cellContent;
                    if (creneau === '10h15') {
                        row += '<td class="separator-column"></td>';
                    }
                });

                table.innerHTML += row + '</tr>';
            });

            const volumehTP = calculerVolumeHoraire();
            hTPBody.innerHTML = '';

            // MODIFI√â: Affiche tous les enseignants, m√™me ceux avec 0 hTP, puis trie par volume.
            const volumeList = [];
            LISTE_ENSEIGNANTS.forEach(enseignant => {
                volumeList.push({ name: enseignant, volume: volumehTP[enseignant] || 0 });
            });

            volumeList.sort((a, b) => b.volume - a.volume);

            const globalMetrics = calculateGlobalVolumeMetrics();
            let VHM = globalMetrics.globalVHM;
            const tolerance = 20;

            // Pour la session d'automne, le VHM de r√©f√©rence pour l'affichage est divis√© par 2
            const currentSession = document.getElementById('selectSession').value;
            if (currentSession === "Session d'automne") {
                VHM = Math.round(VHM / 2);
            }

            volumeList.forEach(item => {
                const percentage = VHM > 0 ? (item.volume / VHM) * 100 : 0;
                const displayPercentage = Math.min(percentage, 100);

                let barColorClass = 'bg-orange-400';
                if (item.volume > VHM + tolerance) {
                    barColorClass = 'bg-red-500';
                } else if (item.volume >= VHM - tolerance) {
                    barColorClass = 'bg-green-500';
                }

                const progressBarHTML = `
                    <div class="progress-bar-container">
                        <div class="progress-bar ${barColorClass}" style="width: ${displayPercentage}%;"></div>
                        <div class="progress-bar-text">${item.volume} / ${VHM} hTP</div>
                    </div>
                `;

                const row = document.createElement('tr');
                row.innerHTML = `<td>${item.name}</td><td>${item.volume} hTP</td><td>${progressBarHTML}</td>`;
                hTPBody.appendChild(row);
            });
                
            const attributedGroups = calculerGroupesAttribu√©s(seances);
            updateGroupesAttribu√©sDisplay(attributedGroups);
            
            updateMatiereManagementFields(); 
            updateVolumeInfoForSelectedEnseignants();

            // NOUVELLE LIGNE √Ä AJOUTER CI-DESSOUS
            genererTableauSalles();
            sauvegarderTravail(); 
        }
        
        function attribuerSeanceDirectement(jour, creneau) {
            if (!validerFormulaire().isValid) {
                return;
            }

            const data = {
                filiere: document.getElementById('inputFiliere').value,
                matiere: document.getElementById('inputMatiere').value,
                type: document.getElementById('inputType').value,
                enseignant1: document.getElementById('inputEnseignant1').value,
                enseignant2: document.getElementById('inputEnseignant2').value,
                salle: document.getElementById('inputSalle').value,
                section: document.getElementById('inputSection').value,
                groupeTDTP: document.getElementById('inputGroupeTDTP').value
            };

            const success = ajouterSeance(
                jour, creneau, data.filiere, data.matiere, data.type,
                data.enseignant1, data.enseignant2, data.salle, data.section, data.groupeTDTP
            );

            if (success) {
                actualiserAffichage();
            }
        }

        function validerSalle(typeSeance, salle) {
            const typeSalle = SALLES_INFO[salle] || 'Inconnu';

            if (typeSeance === 'Cours') {
                return typeSalle === 'Amphi' || typeSalle === 'Standard';
            } else if (typeSeance === 'TP') {
                return salle.toUpperCase().startsWith('STP'); 
            } else if (typeSeance === 'TD') {
                return typeSalle === 'Standard'; 
            }
            return true;
        }
        
        // MODIFI√â: Fonction de v√©rification des conflits (plus robuste et compl√®te)
        function verifierConflits(session, seancesAExclureIds = []) {
            let conflicts = [];
            const seancesAComparer = seances.filter(s => !seancesAExclureIds.includes(s.id));
            
            const creneauxAChecker = [session.creneau];
            if (session.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[session.creneau]) {
                creneauxAChecker.push(CRENEAUX_COUPLES_SUIVANT[session.creneau]);
            }

            // V√©rification Enseignants
            for (const teacher of session.enseignantsArray) {
                if (teacher && !isTeacherAvailable(teacher, session.jour, session.creneau, session.type, seancesAExclureIds)) {
                     conflicts.push(`‚ùå CONFLIT ENSEIGNANT: **${teacher}** est d√©j√† occup√©(e) sur ce cr√©neau.`);
                }
            }

            // V√©rification Salle et Groupe
            for (const creneau of creneauxAChecker) {
                for (const s of seancesAComparer) {
                    if (s.jour !== session.jour) continue;

                    const sOccupeCeCreneau = (s.creneau === creneau) || (s.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[s.creneau] === creneau);
                
                if (sOccupeCeCreneau) {
                    
                    // --- CORRECTION DU BUG ---
                    // L'ancienne logique (if session.salle && s.salle ...) √©chouait si l'une des salles √©tait "" (vide).
                    // La nouvelle logique v√©rifie :
                    // 1. Si la nouvelle s√©ance (session) a une salle sp√©cifique (pas vide).
                    // 2. ET si la salle de la s√©ance existante (s) est la M√äME.
                    if (session.salle !== "" && s.salle === session.salle) {
                        conflicts.push(`‚ùå CONFLIT SALLE: La salle **${session.salle}** est d√©j√† utilis√©e √† ${creneau} par ${s.matiere} (${s.groupe}).`);
                    }
                    // --- FIN DE LA CORRECTION ---
                    
                    if (s.uniqueStudentEntity === session.uniqueStudentEntity) {
                            conflicts.push(`‚ùå CONFLIT GROUPE: Le groupe **${session.uniqueStudentEntity}** est d√©j√† occup√© √† ${creneau}.`);
                        }
                    }
                }
            }

            // V√©rification de section (un Cours ne peut pas √™tre en m√™me temps qu'un TD/TP pour la m√™me section)
            const chevauchementSection = seancesAComparer.find(s => {
                if (s.jour === session.jour && s.creneau === session.creneau && s.filiere === session.filiere && s.section === session.section) {
                    if (session.type === 'Cours' && (s.type === 'TD' || s.type === 'TP')) {
                        return true;
                    }
                    if ((session.type === 'TD' || session.type === 'TP') && s.type === 'Cours') { return true; }
                }
                return false;
            });
            if (chevauchementSection) {
                conflicts.push(`‚ùå CONFLIT SECTION: Un **${chevauchementSection.type}** est d√©j√† programm√© pour la section **${session.section}**. Impossible de programmer un ${session.type} en parall√®le.`);
            }
            
            // V√©rification de doublon (le m√™me groupe ne peut pas avoir deux fois le m√™me TD/TP de la m√™me mati√®re)
            if (session.type === 'TD' || session.type === 'TP') {
                const seanceIdentiqueExistante = seancesAComparer.find(s =>
                    s.matiere === session.matiere &&
                    s.type === session.type &&
                    s.uniqueStudentEntity === session.uniqueStudentEntity
                );
                if (seanceIdentiqueExistante) {
                    conflicts.push(`‚ùå CONFLIT DE DOUBLON: Le groupe **${session.uniqueStudentEntity}** a d√©j√† une s√©ance de **${session.type}** pour la mati√®re **${session.matiere}**.`);
                }
            }
            if (session.type === 'Cours') {
                const seanceIdentiqueExistante = seancesAComparer.find(s =>
                    s.matiere === session.matiere &&
                    s.type === session.type &&
                    s.uniqueStudentEntity === session.uniqueStudentEntity
                );
                if (seanceIdentiqueExistante) {
                    conflicts.push(`‚ùå CONFLIT DE DOUBLON: La **${session.section}** a d√©j√† un **Cours** pour la mati√®re **${session.matiere}**.`);
                }
            }
            return [...new Set(conflicts)];
        }

        function ajouterSeance(jour, creneau, filiere, matiere, type, enseignant1, enseignant2, salle, section, groupeTDTP, seancesAExclureIds = []) {
            
            // MODIFI√â: V√©rifier si deux enseignants sont requis et si deux sont fournis
            const matiereInfo = MATIERE_GROUPES_INFO[matiere];
            const requireTwoTeachers = type === 'TP' && matiereInfo && matiereInfo.nbEnseignantsTP === 2;
            const providedTeacher1 = enseignant1 && enseignant1 !== '';
            const providedTeacher2 = enseignant2 && enseignant2 !== '';
            // NOUVEAU: Calculer le nombre total d'enseignants fournis
            const totalProvidedTeachers = (providedTeacher1 ? 1 : 0) + (providedTeacher2 ? 1 : 0);

            // CORRECTION: D√©clencher l'erreur SEULEMENT si 1 enseignant est fourni alors que 2 sont requis.
            // Permet de sauvegarder avec 0 enseignant s√©lectionn√© ("Aucun").
            if (requireTwoTeachers && totalProvidedTeachers === 1) {
                 showCustomDialog({ 
                    title: 'Enseignant Manquant', 
                    // Message l√©g√®rement ajust√©
                    htmlMessage: `Cette s√©ance de TP pour **${matiere}** requiert <strong>deux</strong> enseignants. Veuillez en s√©lectionner un deuxi√®me ou retirer le premier enseignant.` 
                 });
                 return false; // Bloquer l'ajout/modification
            }

            const sessionTeachers = [enseignant1, enseignant2].filter(name => name && name !== ''); // Garder uniquement les noms valides
            
            // ... reste de la fonction inchang√©e ...
            const isTPCoupled = type === 'TP';
            
            const uniqueStudentEntity = (type === 'TD' || type === 'TP') 
                ? `${filiere} - ${section} - ${groupeTDTP}` 
                : `${filiere} - ${section}`;
            
            const groupeForDisplay = (type === 'TD' || type === 'TP') ? `${section} - ${groupeTDTP}` : section;

            const hTP_Affecte_Main = getHtpForMatiere(matiere, type);
            // MODIFI√â: S'assurer que le texte "√Ä attribuer" est utilis√© si aucun enseignant n'est fourni
            const displayEnseignants = sessionTeachers.length > 0 ? sessionTeachers.join(' / ') : '√Ä attribuer';

            const sessionsToAdd = [];
            
            const baseSession = {
                jour: jour, creneau: creneau, matiere: matiere, type: type, 
                filiere: filiere, groupe: groupeForDisplay, section: section,
                uniqueStudentEntity: uniqueStudentEntity, enseignant: displayEnseignants,
                enseignantsArray: sessionTeachers, salle: salle, 
                dureeAffichee: isTPCoupled ? 3.0 : 1.5, hTP_Affecte: hTP_Affecte_Main
            };
            sessionsToAdd.push(baseSession);

            if (isTPCoupled) {
                const nextCreneau = CRENEAUX_COUPLES_SUIVANT[creneau];
                if (!nextCreneau) {
                    showCustomDialog({ title: 'Erreur de Couplage TP', htmlMessage: `Le cr√©neau de d√©but ${creneau} ne peut pas √™tre coupl√©.` });
                    return false;
                }
                sessionsToAdd.push({ ...baseSession, creneau: nextCreneau, hTP_Affecte: 0 });
            }

            let allConflicts = [];
            for (const session of sessionsToAdd) {
                const conflicts = verifierConflits(session, seancesAExclureIds);
                allConflicts.push(...conflicts);
            }

            //if (!validerSalle(type, salle)) {
            //    allConflicts.push(`‚ùå CONFLIT SALLE TYPE: Un (${type}) n'est pas compatible avec cette salle.`);
            //}
            // Pour les TP nous n'imposons pas de salle ; pour les autres types (Cours, TD) on v√©rifie la compatibilit√© du type de salle
                if (type !== 'TP' && !validerSalle(type, salle)) {
                allConflicts.push(`‚ùå CONFLIT SALLE TYPE: Un (${type}) n'est pas compatible avec cette salle.`);
                }

            if (allConflicts.length > 0) {
                const uniqueConflicts = [...new Set(allConflicts)];
                const errorMessage = '<ul>' + uniqueConflicts.map(c => `<li>${c}</li>`).join('') + '</ul>';
                showCustomDialog({ title: 'Conflit d\'Attribution', htmlMessage: errorMessage });
                return false;
            }
            
            for (const session of sessionsToAdd) {
                session.id = nextSessionId++; 
                seances.push(session);
            }
            
            if(isTPCoupled) logMessage(`‚ÑπÔ∏è Cr√©neau TP coupl√© (3h) ajout√©.`, 'initial');
            logMessage(`‚úÖ S√©ance(s) attribu√©e(s): ${jour}, ${creneau} pour **Fili√®re ${filiere}**.`, 'success');
            return true;
        }
         // --- NOUVEAU: Fonction pour g√©n√©rer le tableau de disponibilit√© des salles ---
        function genererTableauSalles() {
            const container = document.getElementById('salles-edt-container');
            if (!container) return; // Ne rien faire si le conteneur n'existe pas

            // R√©cup√©rer toutes les salles et cr√©neaux tri√©s
            const allRooms = Object.keys(SALLES_INFO).sort();
            const sortedCreneaux = getSortedCreneauxKeys();
            
            let tableHTML = '<table class="salles-edt-table">';
            
            // --- En-t√™te du tableau (Heures) ---
            let headerHTML = '<th>Jour/Heure</th>';
            sortedCreneaux.forEach(c => {
                headerHTML += `<th>${c} - ${LISTE_CRENEAUX[c].fin}</th>`;
                if (c === '10h15') { // (Assurez-vous que '10h15' est votre cr√©neau avant la pause)
                    headerHTML += '<th class="separator-column"></th>';
                }
            });
            tableHTML += `<thead><tr>${headerHTML}</tr></thead><tbody>`;

            // --- Corps du tableau (Jours et Salles) ---
            LISTE_JOURS.forEach(jour => {
                tableHTML += `<tr><td class="jour-header">${jour}</td>`; // Colonne du Jour

                sortedCreneaux.forEach(creneau => {
                    const occupiedRooms = new Set();
                    
                    // Analyser toutes les s√©ances de la session en cours
                    seances.forEach(s => {
                        if (s.jour !== jour || !s.salle || s.salle === '') return; // Pas ce jour ou pas de salle

                        // 1. Occupation directe (la s√©ance commence √† ce cr√©neau)
                        if (s.creneau === creneau) {
                            occupiedRooms.add(s.salle);
                        }
                        
                        // 2. Occupation par TP coupl√© (un TP a commenc√© AVANT et occupe ce cr√©neau)
                        // Ex: Un TP √† 8h30 (s.creneau) occupe aussi 10h15 (creneau)
                        if (s.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[s.creneau] === creneau) {
                            occupiedRooms.add(s.salle);
                        }
                    });
                    
                    const occupiedRoomsArray = Array.from(occupiedRooms).sort();
                    const freeRooms = allRooms.filter(r => !occupiedRooms.has(r));
                    
                    // --- Construction de la cellule ---
                    tableHTML += `<td data-jour="${jour}" data-creneau="${creneau}">`;
                    
                    // Afficher les salles occup√©es
                    if (occupiedRoomsArray.length > 0) {
                        tableHTML += '<div class="salles-list salles-occupees">';
                        tableHTML += `<strong>Occup√©es (${occupiedRoomsArray.length}):</strong><ul>`;
                        occupiedRoomsArray.forEach(room => {
                            tableHTML += `<li>${room}</li>`;
                        });
                        tableHTML += '</ul></div>';
                    }
                    
                    // Afficher les salles libres
                    if (freeRooms.length > 0) {
                        tableHTML += '<div class="salles-list salles-libres">';
                        tableHTML += `<strong>Libres (${freeRooms.length}):</strong><ul>`;
                        // Affiche les salles libres
                        freeRooms.forEach(room => {
                            tableHTML += `<li>${room}</li>`;
                        });
                        tableHTML += '</ul></div>';
                    }
                    
                    tableHTML += '</td>';
                    // Fin Construction de la cellule

                    // Colonne de s√©paration
                    if (creneau === '10h15') {
                        tableHTML += '<td class="separator-column"></td>';
                    }
                });
                tableHTML += '</tr>';
            });
            
            tableHTML += '</tbody></table>';
            container.innerHTML = tableHTML; // Injecter le tableau dans le panneau
        }
        // --- Fin de la nouvelle fonction ---
        // --- 5. Initialisation et √âv√©nements ---
        
        function selectCell(cellElement) {
            // NOUVEAU: D√©s√©lectionner toute s√©ance active si on s√©lectionne une cellule
            if (currentlySelectedSeance) {
                currentlySelectedSeance.classList.remove('seance-selectionnee');
                currentlySelectedSeance = null;
            }

            if (currentlySelectedCell) {
                currentlySelectedCell.classList.remove('cellule-selectionnee');
            }
            cellElement.classList.add('cellule-selectionnee');
            currentlySelectedCell = cellElement;
        }

        function ouvrirFormulairePourModifier(sessionId) {
            const seance = seances.find(s => s.id === sessionId);
            if (!seance) {
                logMessage(`Erreur: Impossible de trouver la s√©ance ID ${sessionId}`, 'error');
                return;
            }

            // NOUVEAU: G√©rer la s√©lection visuelle de la s√©ance
            const seanceElement = document.querySelector(`.seance[data-id='${sessionId}']`);
            if (seanceElement) {
                if (currentlySelectedSeance) {
                    currentlySelectedSeance.classList.remove('seance-selectionnee');
                }
                if (currentlySelectedCell) {
                    currentlySelectedCell.classList.remove('cellule-selectionnee');
                    currentlySelectedCell = null;
                }
                seanceElement.classList.add('seance-selectionnee');
                currentlySelectedSeance = seanceElement;
            }

            currentlyEditingSessionId = sessionId;
            
            // MODIFI√â: Logique d'affichage des boutons
            document.getElementById('btnSubmitForm').textContent = '‚úÖ Appliquer les Modifications';
            document.getElementById('btnSubmitForm').style.display = 'block'; // Afficher le bouton de modification
            document.getElementById('btnInfoModeCreation').style.display = 'none'; // Cacher le bouton de cr√©ation
            document.getElementById('edit-buttons-container').style.display = 'grid'; // Afficher les autres boutons d'√©dition

            document.getElementById('inputJour').value = seance.jour;
            document.getElementById('inputCreneau').value = seance.creneau;
            document.getElementById('inputType').value = seance.type;

            updateFormVisibility(seance.type);

            document.getElementById('inputFiliere').value = seance.filiere;
            updateMatiereOptions(seance.filiere);
            document.getElementById('inputMatiere').value = seance.matiere;
            
            updateSectionsSelect();
            updateGroupesSelect();
            
            const groupeParts = seance.groupe.split(' - ');
            document.getElementById('inputSection').value = groupeParts[0];
            if (groupeParts.length > 1) {
                document.getElementById('inputGroupeTDTP').value = groupeParts[1];
            }

            document.getElementById('inputSalle').value = seance.salle;
            document.getElementById('inputEnseignant1').value = seance.enseignantsArray[0] || '';
            document.getElementById('inputEnseignant2').value = seance.enseignantsArray[1] || '';
            
            updateEnseignantDetailPanels();
            updateSalleInfo();
            updateCreneauFin(seance.creneau, seance.type);
            updateEnseignantSelects();
            
            const form = document.getElementById('attributionForm');
            form.scrollIntoView({ behavior: 'smooth', block: 'center' });
            form.style.transition = 'none';
            form.style.boxShadow = '0 0 15px 5px rgba(240, 173, 78, 0.6)';
            setTimeout(() => {
                form.style.transition = 'box-shadow 0.5s ease-in-out';
                form.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
            }, 1500);

            logMessage(`üìù Modification de la s√©ance de ${seance.matiere} (${seance.jour} ${seance.creneau}).`, 'initial');
        }

        function annulerModification() {
            currentlyEditingSessionId = null;
            const form = document.getElementById('attributionForm');
            form.reset();
            clearFormErrors(); // Nettoie les erreurs de validation visuelles

            // MODIFI√â: Logique d'affichage des boutons
            document.getElementById('btnSubmitForm').style.display = 'none'; // Cacher le bouton de modification
            document.getElementById('btnInfoModeCreation').style.display = 'block'; // Afficher le bouton de cr√©ation
            document.getElementById('edit-buttons-container').style.display = 'none'; // Cacher les autres boutons d'√©dition

            if (currentlySelectedCell) {
                currentlySelectedCell.classList.remove('cellule-selectionnee');
                currentlySelectedCell = null;
            }
            // NOUVEAU: D√©s√©lectionner aussi la s√©ance
            if (currentlySelectedSeance) {
                currentlySelectedSeance.classList.remove('seance-selectionnee');
                currentlySelectedSeance = null;
            }

            const initialType = document.getElementById('inputType').value;
            updateFormVisibility(initialType);
            updateEnseignantDetailPanels();

            if (activeFiliereConstraint && Array.from(document.getElementById('inputFiliere').options).some(opt => opt.value === activeFiliereConstraint)) {
                document.getElementById('inputFiliere').value = activeFiliereConstraint;
            }
            updateMatiereOptions(activeFiliereConstraint);

            logMessage('Modification annul√©e.', 'initial');
        }

        function deleteSelectedSeanceHandler() {
            if (currentlyEditingSessionId === null) {
                logMessage('‚ö†Ô∏è Aucune s√©ance n\'est s√©lectionn√©e pour la suppression.', 'error');
                return;
            }

            const seance = seances.find(s => s.id === currentlyEditingSessionId);
            if (!seance) {
                logMessage(`Erreur: Impossible de trouver la s√©ance ID ${currentlyEditingSessionId}`, 'error');
                annulerModification();
                return;
            }

            showCustomDialog({
                title: 'Confirmer la Suppression',
                htmlMessage: `√ätes-vous s√ªr de vouloir supprimer la s√©ance de **${seance.matiere}** (${seance.jour} ${seance.creneau}) ?`,
                confirmText: 'Oui, Supprimer',
                onConfirm: () => {
                    supprimerSeance(currentlyEditingSessionId);
                    annulerModification();
                }
            });
        }

        function ouvrirFormulairePourCreneau(jour, creneau) {
            annulerModification();
            const form = document.getElementById('attributionForm');
            
            document.getElementById('inputJour').value = jour;
            document.getElementById('inputCreneau').value = creneau;
            
            const type = document.getElementById('inputType').value;
            updateCreneauFin(creneau, type);
            
            form.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            form.style.transition = 'none';
            form.style.boxShadow = '0 0 15px 5px rgba(0, 115, 230, 0.5)';
            
            setTimeout(() => {
                form.style.transition = 'box-shadow 0.5s ease-in-out';
                form.style.boxShadow = '0 4px 8px rgba(0,0,0,0.1)';
            }, 1500);

            logMessage(`üìù Formulaire pr√©-rempli pour ${jour} √† ${creneau}.`, 'initial');
        }

        function showCustomDialog({ title, htmlMessage, confirmText, cancelText, onConfirm, onCancel }) {
            const modal = document.getElementById('dialogModal');
            modal.querySelector('#dialogTitle').textContent = title;
            modal.querySelector('#dialogBody').innerHTML = htmlMessage;

            const confirmBtn = modal.querySelector('#dialogConfirmBtn');
            const cancelBtn = modal.querySelector('#dialogCancelBtn');

            const newConfirmBtn = confirmBtn.cloneNode(true);
            confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
            const newCancelBtn = cancelBtn.cloneNode(true);
            cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);


            if (onConfirm) {
                newConfirmBtn.style.display = 'inline-block';
                newCancelBtn.textContent = cancelText || 'Annuler';
                newConfirmBtn.textContent = confirmText || 'Confirmer';

                newConfirmBtn.addEventListener('click', () => {
                    onConfirm();
                    hideCustomDialog();
                });
            } else {
                newConfirmBtn.style.display = 'none';
                newCancelBtn.textContent = 'Fermer';
            }
            
            newCancelBtn.addEventListener('click', () => {
                if (onCancel) {
                    onCancel();
                }
                hideCustomDialog();
            });
            
            modal.style.display = 'flex';
        }

        function hideCustomDialog() {
            document.getElementById('dialogModal').style.display = 'none';
        }

        function initialiserDeletionForms() {
            const selectEnseignant = document.getElementById('selectEnseignantToDelete');
            const selectSalle = document.getElementById('selectSalleToDelete');
            const selectFiliere = document.getElementById('selectFiliereToDelete');

            selectEnseignant.innerHTML = '<option value="">-- Choisir --</option>' + LISTE_ENSEIGNANTS.map(item => `<option value="${item}">${item}</option>`).join('');
            selectSalle.innerHTML = '<option value="">-- Choisir --</option>' + Object.keys(SALLES_INFO).sort().map(item => `<option value="${item}">${item}</option>`).join('');
            // MODIFI√â: Affiche toutes les fili√®res pour la suppression, sans filtrer par session
            selectFiliere.innerHTML = '<option value="">-- Choisir --</option>' + LISTE_FILIERES.map(f => `<option value="${f.nom}">${f.nom}</option>`).join('');
        }

        function deleteEnseignantHandler() {
            const select = document.getElementById('selectEnseignantToDelete');
            const name = select.value;

            if (!name) {
                logMessage('‚ö†Ô∏è Veuillez s√©lectionner un enseignant √† supprimer.', 'error');
                return;
            }

            const seancesAffectees = seances.filter(s => s.enseignantsArray.includes(name));
            let confirmationMessage = `√ätes-vous s√ªr de vouloir supprimer l'enseignant **${name}** ?`;

            if (seancesAffectees.length > 0) {
                confirmationMessage += ` <br><strong style="color:red;">Cette action supprimera √©galement ${seancesAffectees.length} s√©ance(s) attribu√©e(s) √† cet enseignant.</strong>`;
            }

            showCustomDialog({
                title: 'Confirmer la Suppression',
                htmlMessage: confirmationMessage,
                confirmText: 'Supprimer',
                onConfirm: () => {
                    LISTE_ENSEIGNANTS = LISTE_ENSEIGNANTS.filter(ens => ens !== name);
                    delete ENSEIGNANT_SOUHAITS[name];
                    delete ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES[name];

                    if (seancesAffectees.length > 0) {
                        seances = seances.filter(s => !s.enseignantsArray.includes(name));
                    }
                    
                    logMessage(`üóëÔ∏è Enseignant **${name}** et ses d√©pendances ont √©t√© supprim√©s.`, 'success');
                    
                    initialiserTout();
                }
            });
        }

        function deleteSalleHandler() {
            const select = document.getElementById('selectSalleToDelete');
            const name = select.value;

            if (!name) {
                logMessage('‚ö†Ô∏è Veuillez s√©lectionner une salle √† supprimer.', 'error');
                return;
            }

            const seancesAffectees = seances.filter(s => s.salle === name);
            let confirmationMessage = `√ätes-vous s√ªr de vouloir supprimer la salle **${name}** ?`;

            if (seancesAffectees.length > 0) {
                confirmationMessage += ` <br><strong style="color:red;">Cette action supprimera √©galement ${seancesAffectees.length} s√©ance(s) attribu√©e(s) √† cette salle.</strong>`;
            }
             showCustomDialog({
                title: 'Confirmer la Suppression',
                htmlMessage: confirmationMessage,
                confirmText: 'Supprimer',
                onConfirm: () => {
                    delete SALLES_INFO[name];
                    if (seancesAffectees.length > 0) {
                        seances = seances.filter(s => s.salle !== name);
                    }
                    logMessage(`üóëÔ∏è Salle **${name}** et ses s√©ances associ√©es ont √©t√© supprim√©es.`, 'success');
                    initialiserTout();
                    populateAutoSalleSelects();
                }
            });
        }
        
        function deleteFiliereHandler() {
            const select = document.getElementById('selectFiliereToDelete');
            const name = select.value;

            if (!name) {
                logMessage('‚ö†Ô∏è Veuillez s√©lectionner une fili√®re √† supprimer.', 'error');
                return;
            }

            const seancesAffectees = seances.filter(s => s.filiere === name);
            let confirmationMessage = `√ätes-vous s√ªr de vouloir supprimer la fili√®re **${name}** ?`;

            if (seancesAffectees.length > 0) {
                confirmationMessage += ` <br><strong style="color:red;">Cette action supprimera √©galement ${seancesAffectees.length} s√©ance(s) attribu√©e(s) √† cette fili√®re.</strong>`;
            }
            
            showCustomDialog({
                title: 'Confirmer la Suppression',
                htmlMessage: confirmationMessage,
                confirmText: 'Supprimer',
                onConfirm: () => {
                    // MODIFI√â: La suppression filtre maintenant sur la propri√©t√© 'nom' de l'objet fili√®re
                    LISTE_FILIERES = LISTE_FILIERES.filter(f => f.nom !== name);
                     if (seancesAffectees.length > 0) {
                        seances = seances.filter(s => s.filiere !== name);
                    }
                    logMessage(`üóëÔ∏è Fili√®re **${name}** et ses s√©ances associ√©es ont √©t√© supprim√©es.`, 'success');
                    initialiserTout();
                }
            });
        }
        
        function setupTabs() {
            document.querySelectorAll('.tab-btn').forEach(button => {
                button.addEventListener('click', () => {
                    const tabId = button.dataset.tab;
                    
                    document.querySelectorAll('.tab-btn').forEach(btn => btn.classList.remove('active'));
                    document.querySelectorAll('.tab-pane').forEach(pane => pane.classList.remove('active'));
                    
                    button.classList.add('active');
                    document.getElementById(`tab-${tabId}`).classList.add('active');
                });
            });
        }

        // NOUVEAU: Fonction pour initialiser et g√©rer le panneau d'association fili√®re/session
        function initialiserFiliereSessionManagement() {
            tempFiliereSessionChanges = {}; // MODIFI√â: R√©initialiser les changements temporaires
            const container = document.getElementById('filiereSessionList');
            container.innerHTML = ''; // Vide le conteneur

            // On trie par nom de fili√®re pour un affichage coh√©rent
            const filieresTriees = [...LISTE_FILIERES].sort((a, b) => a.nom.localeCompare(b.nom));

            filieresTriees.forEach(filiere => {
                const itemDiv = document.createElement('div');
                itemDiv.style.display = 'flex';
                itemDiv.style.justifyContent = 'space-between';
                itemDiv.style.alignItems = 'center';
                itemDiv.style.padding = '8px';
                itemDiv.style.backgroundColor = '#fff';
                itemDiv.style.border = '1px solid #ccc';
                itemDiv.style.borderRadius = '4px';

                const nameSpan = document.createElement('span');
                nameSpan.textContent = filiere.nom;
                nameSpan.style.fontWeight = 'bold';

                const select = document.createElement('select');
                select.dataset.filiereNom = filiere.nom; // Ajout d'un data-attribute pour l'identification
                select.innerHTML = `
                    <option value="Automne" ${filiere.session === 'Automne' ? 'selected' : ''}>Automne</option>
                    <option value="Printemps" ${filiere.session === 'Printemps' ? 'selected' : ''}>Printemps</option>
                `;
                select.style.padding = '5px';
                select.style.borderRadius = '4px';
                select.style.border = '1px solid #ccc';

                itemDiv.appendChild(nameSpan);
                itemDiv.appendChild(select);
                container.appendChild(itemDiv);
            });
        }

        function initialiserCreneauxManagement() {
            const listDiv = document.getElementById('creneauxList');
            listDiv.innerHTML = '';
            const sortedKeys = getSortedCreneauxKeys();
            
            let html = '<div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 10px;">';
            sortedKeys.forEach(key => {
                html += `
                    <div style="background: #fff; padding: 8px; border-radius: 4px; border: 1px solid #ccc; display: flex; justify-content: space-between; align-items: center;">
                        <span><strong>${key}</strong> - ${LISTE_CRENEAUX[key].fin}</span>
                        <button class="delete-btn" style="position: static; font-size: 1em;" onclick="deleteCreneauHandler('${key}')">x</button>
                    </div>
                `;
            });
            html += '</div>';
            listDiv.innerHTML = html;
        }

        function addCreneauHandler() {
            const startInput = document.getElementById('inputNewCreneauStart');
            const endInput = document.getElementById('inputNewCreneauEnd');
            const startTime = startInput.value;
            const endTime = endInput.value;

            if (!startTime || !endTime) {
                logMessage("‚ö†Ô∏è Les heures de d√©but et de fin sont obligatoires.", 'error');
                return;
            }
            
            const startObj = new Date(`1970-01-01T${startTime}:00`);
            const endObj = new Date(`1970-01-01T${endTime}:00`);

            if (startObj >= endObj) {
                logMessage("‚ö†Ô∏è L'heure de d√©but doit √™tre avant l'heure de fin.", 'error');
                return;
            }

            const key = startTime.replace(':', 'h');

            if (LISTE_CRENEAUX.hasOwnProperty(key)) {
                logMessage(`‚ö†Ô∏è Le cr√©neau de **${key}** existe d√©j√†.`, 'error');
                return;
            }
            
            const durationMs = endObj - startObj;
            const durationHours = durationMs / (1000 * 60 * 60);

            LISTE_CRENEAUX[key] = {
                fin: endTime,
                duree: parseFloat(durationHours.toFixed(2))
            };

            logMessage(`üïí Nouveau cr√©neau **${key} - ${endTime}** ajout√©.`, 'success');
            
            startInput.value = '';
            endInput.value = '';

            initialiserTout();
        }

        function deleteCreneauHandler(key) {
             if (!LISTE_CRENEAUX.hasOwnProperty(key)) return;

            const isUsed = seances.some(s => s.creneau === key);

            if (isUsed) {
                showCustomDialog({
                    title: 'Confirmer la Suppression',
                    htmlMessage: `‚ö†Ô∏è Le cr√©neau **${key}** est utilis√©. Supprimer ce cr√©neau supprimera aussi **toutes les s√©ances associ√©es**. Voulez-vous continuer ?`,
                    confirmText: 'Supprimer Tout',
                    onConfirm: () => {
                        seances = seances.filter(s => s.creneau !== key);
                        logMessage(`üóëÔ∏è Les s√©ances associ√©es au cr√©neau **${key}** ont √©t√© supprim√©es.`, 'warning');
                        deleteCreneauConfirmed(key);
                    }
                });
            } else {
                deleteCreneauConfirmed(key);
            }
        }

        function deleteCreneauConfirmed(key) {
            delete LISTE_CRENEAUX[key];
            logMessage(`üóëÔ∏è Cr√©neau **${key}** supprim√©.`, 'success');
            initialiserTout();
        }

        function resetEDTHandler() {
            showCustomDialog({
                title: 'Confirmer la R√©initialisation',
                htmlMessage: '√ätes-vous s√ªr de vouloir supprimer **toutes les s√©ances** de l\'emploi du temps pour la session actuelle ? Cette action est irr√©versible.',
                confirmText: 'Oui, Vider l\'EDT',
                onConfirm: () => {
                    seances = [];
                    nextSessionId = 1;
                    logMessage('üóëÔ∏è Emploi du temps de la session r√©initialis√©. Toutes les s√©ances ont √©t√© supprim√©es.', 'success');
                    actualiserAffichage();
                }
            });
        }

        function resetProjectHandler() {
            showCustomDialog({
                title: '‚ö†Ô∏è CONFIRMATION REQUISE',
                htmlMessage: 'Vous √™tes sur le point de **supprimer la totalit√© du projet** (s√©ances des deux sessions, enseignants, salles, mati√®res, fili√®res, etc.) et de restaurer les param√®tres par d√©faut. <br><br><strong>Cette action est D√âFINITIVE et ne peut pas √™tre annul√©e.</strong> √ätes-vous absolument s√ªr ?',
                confirmText: 'Oui, tout effacer',
                onConfirm: () => {
                    localStorage.clear();
                    
                    seances = [];
                    nextSessionId = 1;
                    LISTE_ENSEIGNANTS = [...DEFAULT_ENSEIGNANTS].sort();
                    SALLES_INFO = {...DEFAULT_SALLES_INFO};
                    LISTE_FILIERES = [...DEFAULT_FILIERES].sort();
                    MATIERE_GROUPES_INFO = {...DEFAULT_MATIERE_GROUPES_INFO};
                    LISTE_MATIERES = Object.keys(MATIERE_GROUPES_INFO).sort();
                    ENSEIGNANT_SOUHAITS = {};
                    ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES = {};
                    LISTE_CRENEAUX = JSON.parse(JSON.stringify(DEFAULT_CRENEAUX));
                    
                    logMessage('üí• Projet complet r√©initialis√© aux valeurs par d√©faut.', 'success');
                    
                    initialiserTout();
                }
            });
        }
        
        function handleCellHoverConflict(event) {
            const cell = event.target.closest('td[data-jour]');
            if (!cell || cell.querySelector('.seance-data')) return;

            const type = document.getElementById('inputType').value;
            const filiere = document.getElementById('inputFiliere').value;
            const section = document.getElementById('inputSection').value;
            const groupeTDTP = document.getElementById('inputGroupeTDTP').value;
            const enseignant1 = document.getElementById('inputEnseignant1').value;
            const enseignant2 = document.getElementById('inputEnseignant2').value;
            const salle = document.getElementById('inputSalle').value;
            const matiere = document.getElementById('inputMatiere').value;

            const sessionTeachers = [enseignant1, enseignant2].filter(Boolean);
            if (sessionTeachers.length === 0 && !filiere && !salle && !matiere) {
                return;
            }

            const jour = cell.dataset.jour;
            const creneau = cell.dataset.creneau;
            
            if (type === 'TP' && !CRENEAUX_COUPLES_SUIVANT[creneau]) {
                cell.classList.add('cellule-conflit');
                cell.title = 'Impossible de placer un TP de 3h ici.';
                return;
            }

            const uniqueStudentEntity = (type === 'TD' || type === 'TP')
                ? `${filiere} - ${section} - ${groupeTDTP}`
                : `${filiere} - ${section}`;

            const sessionHypothetique = {
                jour: jour,
                creneau: creneau,
                filiere: filiere,
                section: section,
                uniqueStudentEntity: uniqueStudentEntity,
                enseignantsArray: sessionTeachers,
                salle: salle,
                type: type,
                matiere: matiere
            };

            const seancesAExclureIds = currentlyEditingSessionId !== null ? [currentlyEditingSessionId] : [];
            let conflicts = verifierConflits(sessionHypothetique, seancesAExclureIds);
            
            if (type === 'TP') {
                const nextCreneau = CRENEAUX_COUPLES_SUIVANT[creneau];
                if(nextCreneau) {
                    const coupledSessionHypothetique = {...sessionHypothetique, creneau: nextCreneau};
                    const coupledConflicts = verifierConflits(coupledSessionHypothetique, seancesAExclureIds);
                    conflicts.push(...coupledConflicts);
                    conflicts = [...new Set(conflicts)];
                }
            }

            if (conflicts.length > 0) {
                cell.classList.add('cellule-conflit');
                cell.title = 'Conflits d√©tect√©s:\n' + conflicts.map(c => c.replace(/<[^>]*>?/gm, '')).join('\n');
            }
        }

        function handleCellMouseLeave(event) {
            const cell = event.target.closest('td[data-jour]');
            if (!cell) return;
            cell.classList.remove('cellule-conflit');
            cell.title = '';
        }

        function handleDragStart(event, sessionId) {
            draggedSessionId = sessionId;
            event.dataTransfer.setData('text/plain', sessionId);
            event.dataTransfer.effectAllowed = 'move';
            setTimeout(() => {
                event.target.style.opacity = '0.5';
            }, 0);
        }

        function handleDragEnd(event) {
            event.target.style.opacity = '1';
            draggedSessionId = null;
            document.querySelectorAll('#edtTable td').forEach(cell => {
                cell.classList.remove('drop-target-active', 'cellule-conflit');
                cell.title = '';
            });
        }

        function handleDragOver(event) {
            event.preventDefault();
            const targetCell = event.target.closest('td');

            if (!targetCell || !targetCell.dataset.jour || !draggedSessionId) {
                return;
            }
            
            const seanceToMove = seances.find(s => s.id === draggedSessionId);
            if (!seanceToMove) return;

            if (seanceToMove.type === 'TP') {
                targetCell.classList.add('cellule-conflit');
                targetCell.title = "Le glisser-d√©poser des TP n'est pas pris en charge.";
                return;
            }

            const newJour = targetCell.dataset.jour;
            const newCreneau = targetCell.dataset.creneau;
            
            if (seanceToMove.jour === newJour && seanceToMove.creneau === newCreneau) {
                targetCell.classList.remove('cellule-conflit');
                targetCell.classList.add('drop-target-active');
                targetCell.title = '';
                return;
            }

            const sessionHypothetique = { ...seanceToMove, jour: newJour, creneau: newCreneau };
            const conflicts = verifierConflits(sessionHypothetique, [draggedSessionId]);
            
            if (conflicts.length > 0) {
                targetCell.classList.remove('drop-target-active');
                targetCell.classList.add('cellule-conflit');
                targetCell.title = 'Conflits d√©tect√©s:\n' + conflicts.map(c => c.replace(/<[^>]*>?/gm, '')).join('\n');
            } else {
                targetCell.classList.remove('cellule-conflit');
                targetCell.classList.add('drop-target-active');
                targetCell.title = 'D√©poser ici';
            }
        }

        function handleDragLeave(event) {
            const targetCell = event.target.closest('td');
            if (targetCell) {
                targetCell.classList.remove('drop-target-active');
                targetCell.classList.remove('cellule-conflit');
                targetCell.title = '';
            }
        }

        function handleDrop(event) {
            event.preventDefault();
            const targetCell = event.target.closest('td[data-jour]');
            // Clear visual feedback regardless of drop validity
            document.querySelectorAll('.drop-target-active, .cellule-conflit').forEach(cell => {
                cell.classList.remove('drop-target-active', 'cellule-conflit');
                cell.title = '';
            });
            // Also remove highlight from the dragged element itself if the drop is invalid/cancelled
            const draggedElementSource = document.querySelector(`.seance[data-id='${draggedSessionId}'] .seance-data`);
            if (draggedElementSource) {
                 draggedElementSource.style.opacity = '1';
            }


            if (!targetCell) {
                // Drop outside a valid cell
                draggedSessionId = null; // Reset dragged session ID
                return;
            }

            const sessionId = draggedSessionId;
            draggedSessionId = null; // Reset dragged session ID immediately after retrieving it

            if (sessionId === null) return;

            const newJour = targetCell.dataset.jour;
            const newCreneau = targetCell.dataset.creneau;

            const seanceToMove = seances.find(s => s.id === sessionId);
            if (!seanceToMove) return;

            // Prevent drag-and-drop for TP sessions
            if (seanceToMove.type === 'TP') {
                showCustomDialog({ title: 'D√©placement Impossible', htmlMessage: "Le glisser-d√©poser des s√©ances de TP n'est pas pris en charge pour le moment pour garantir la coh√©rence des cr√©neaux coupl√©s." });
                return;
            }

            // Prevent dropping onto the same cell
            if (seanceToMove.jour === newJour && seanceToMove.creneau === newCreneau) {
                return;
            }

            // --- NOUVELLE LOGIQUE DE GESTION DES CONFLITS ---
            const sessionHypothetique = { ...seanceToMove, jour: newJour, creneau: newCreneau };
            // Check conflicts excluding the session being moved
            const conflicts = verifierConflits(sessionHypothetique, [sessionId]);

            // Check specifically for room conflict
            const roomConflictPrefix = '‚ùå CONFLIT SALLE:';
            const roomConflicts = conflicts.filter(c => c.startsWith(roomConflictPrefix));
            const otherConflicts = conflicts.filter(c => !c.startsWith(roomConflictPrefix));

            if (otherConflicts.length > 0) {
                // If there are conflicts other than the room, show standard error and cancel move
                const errorMessage = '<ul>' + conflicts.map(c => `<li>${c}</li>`).join('') + '</ul>';
                showCustomDialog({ title: 'D√©placement Impossible', htmlMessage: `Le d√©placement cr√©e un conflit : <br>${errorMessage}` });
                // No actual move happens, visual state already reset at the start
            } else if (roomConflicts.length > 0) {
                // Only room conflict(s) exist, try to find an alternative room
                const freeRooms = getFreeRoomsForSlot(newJour, newCreneau, seanceToMove.type, sessionId);

                if (freeRooms.length > 0) {
                    // --- NOUVELLE LOGIQUE DE PRIORISATION ---
                    // 1. R√©cup√©rer les salles pr√©f√©r√©es pour cette fili√®re/type
                    const preferredRooms = getRoomsForTypeForFiliere(seanceToMove.type, seanceToMove.filiere);
                    
                    // 2. Trouver l'intersection entre les salles libres et les salles pr√©f√©r√©es
                    const preferredFreeRooms = freeRooms.filter(room => preferredRooms.includes(room));

                    // 3. Choisir la salle √† sugg√©rer
                    let suggestedRoom;
                    if (preferredFreeRooms.length > 0) {
                        suggestedRoom = preferredFreeRooms[0]; // Priorit√© aux salles configur√©es
                         logMessage(`‚ÑπÔ∏è Conflit salle: Salle pr√©f√©r√©e libre trouv√©e (${suggestedRoom}) pour ${seanceToMove.filiere}/${seanceToMove.type}.`, 'initial');
                    } else {
                        suggestedRoom = freeRooms[0]; // Fallback: premi√®re salle libre trouv√©e
                         logMessage(`‚ÑπÔ∏è Conflit salle: Aucune salle pr√©f√©r√©e libre. Suggestion: ${suggestedRoom}.`, 'initial');
                    }
                    // --- FIN NOUVELLE LOGIQUE ---

                    showCustomDialog({
                        title: 'Conflit de Salle D√©tect√©',
                        htmlMessage: `La salle <strong>${seanceToMove.salle}</strong> est d√©j√† occup√©e sur ce cr√©neau.<br><br>Voulez-vous d√©placer la s√©ance et utiliser la salle libre <strong>${suggestedRoom}</strong> √† la place ?`,
                        confirmText: `Oui, d√©placer vers ${suggestedRoom}`,
                        onConfirm: () => {
                            // User accepted: Move session and change room
                            seanceToMove.jour = newJour;
                            seanceToMove.creneau = newCreneau;
                            seanceToMove.salle = suggestedRoom; // Update the room
                            logMessage(`‚úÖ S√©ance de **${seanceToMove.matiere}** d√©plac√©e vers ${newJour} ${newCreneau} (Salle chang√©e en ${suggestedRoom}).`, 'success');
                            actualiserAffichage(); // Refresh the entire timetable display
                            sauvegarderTravail();
                        },
                        onCancel: () => {
                            logMessage('‚ÑπÔ∏è D√©placement annul√© par l\'utilisateur.', 'initial');
                            // No actual move happens, visual state already reset
                        }
                    });
                } else {
                    // Room conflict exists, but no free rooms found
                    const errorMessage = `<ul>${roomConflicts.map(c => `<li>${c}</li>`).join('')}<li>Aucune autre salle compatible n'est libre sur ce cr√©neau.</li></ul>`;
                    showCustomDialog({ title: 'D√©placement Impossible', htmlMessage: `Le d√©placement cr√©e un conflit de salle et aucune alternative n'a √©t√© trouv√©e : <br>${errorMessage}` });
                    // No actual move happens, visual state already reset
                }
            } else {
                // No conflicts found, perform the move directly
                seanceToMove.jour = newJour;
                seanceToMove.creneau = newCreneau;
                logMessage(`‚úÖ S√©ance de **${seanceToMove.matiere}** d√©plac√©e vers ${newJour} ${newCreneau}.`, 'success');
                actualiserAffichage(); // Refresh the entire timetable display
                sauvegarderTravail();
            }
            // --- FIN DE LA NOUVELLE LOGIQUE ---
        }
        /* --------- D√©but : Helpers multi-salles par fili√®re (√† coller avant initialiserTout()) --------- */

// Structure m√©moire : { "Filiere Nom": { Cours: ['S1','S2'], TD: [...], TP: [...] } }
let AUTO_SALLE_CHOICES_PAR_FILIERE = {};

// Round-robin counters, r√©initialis√©s au d√©but d'une g√©n√©ration automatique
let autoSalleCounters = {}; // ex: { 'S3 P|TD': 0, 'S3 P|Cours': 1 }

function populateAutoSalleSelects() {
    const selCours = document.getElementById('autoSalleCours');
    const selTD = document.getElementById('autoSalleTD');
    if (!selCours || !selTD) return;

    const salles = Object.keys(SALLES_INFO || {}).sort((a,b) => a.localeCompare(b));

    selCours.innerHTML = '';
    selTD.innerHTML = '';

    salles.forEach(name => {
        const type = SALLES_INFO[name] || '';
        const label = name + (type ? ` (${type})` : '');

        const oC = document.createElement('option'); oC.value = name; oC.textContent = label;
        const oTD = document.createElement('option'); oTD.value = name; oTD.textContent = label;

        selCours.appendChild(oC);
        selTD.appendChild(oTD);
    });
}

function loadAutoSalleSelectionsForFiliere(filiereNom) {
    populateAutoSalleSelects();
    if (!filiereNom) return;
    const selCours = document.getElementById('autoSalleCours');
    const selTD = document.getElementById('autoSalleTD');
    const cfg = AUTO_SALLE_CHOICES_PAR_FILIERE[filiereNom] || { Cours: [], TD: [] };

    const setSelected = (sel, arr) => {
        Array.from(sel.options).forEach(opt => opt.selected = arr.includes(opt.value));
    };
    setSelected(selCours, cfg.Cours || []);
    setSelected(selTD, cfg.TD || []);
}

function saveAutoSalleSelectionsForCurrentFiliere() {
    const filiere = document.getElementById('inputFiliere').value;
    if (!filiere) {
        logMessage("‚ö†Ô∏è S√©lectionnez d'abord une fili√®re dans le formulaire pour enregistrer les salles.", 'warning');
        return;
    }
    const getSelValues = id => {
        const s = document.getElementById(id);
        if (!s) return [];
        return Array.from(s.selectedOptions).map(o => o.value);
    };
    const saved = {
        Cours: getSelValues('autoSalleCours'),
        TD: getSelValues('autoSalleTD')
    };
    AUTO_SALLE_CHOICES_PAR_FILIERE[filiere] = saved;

    // Optionnel : persistance
    try { localStorage.setItem('edt_auto_salles_by_filiere', JSON.stringify(AUTO_SALLE_CHOICES_PAR_FILIERE)); } catch(_) {}

    logMessage(`‚úÖ Salles enregistr√©es pour la fili√®re "${filiere}".`, 'success');
}

function clearAutoSalleForCurrentFiliere() {
    const filiere = document.getElementById('inputFiliere').value;
    if (!filiere) return;
    delete AUTO_SALLE_CHOICES_PAR_FILIERE[filiere];
    try { localStorage.setItem('edt_auto_salles_by_filiere', JSON.stringify(AUTO_SALLE_CHOICES_PAR_FILIERE)); } catch(_) {}
    loadAutoSalleSelectionsForFiliere(filiere);
    logMessage(`‚ÑπÔ∏è Configuration de salles automatique effac√©e pour la fili√®re "${filiere}".`, 'initial');
}

// Retourne tableau de salles configur√©es pour type/filiere, ou fallback intelligent
function getRoomsForTypeForFiliere(type, filiere) {
    const cfg = AUTO_SALLE_CHOICES_PAR_FILIERE[filiere];
    if (cfg && Array.isArray(cfg[type]) && cfg[type].length > 0) return cfg[type].slice();

    // fallback : heuristique selon SALLES_INFO
    const fallback = [];
    for (const [name, t] of Object.entries(SALLES_INFO || {})) {
        const ut = (t || '').toUpperCase();
        if (type === 'TP') {
            if (ut.startsWith('STP')) fallback.push(name);
        } else if (type === 'TD') {
            if (!t || t === 'Standard') fallback.push(name);
        } else { // Cours
            if (t === 'Amphi' || t === 'Standard') fallback.push(name);
        }
    }
    return fallback.length ? fallback : Object.keys(SALLES_INFO || {});
}

// Round-robin selection (utiliser groupIndex si disponible)
function pickRoomRoundRobin(type, filiere, groupIndex) {
    const key = `${filiere}|${type}`;
    if (!autoSalleCounters[key]) autoSalleCounters[key] = 0;
    const rooms = getRoomsForTypeForFiliere(type, filiere);
    if (!rooms || rooms.length === 0) return '';
    const idx = (groupIndex !== undefined && groupIndex !== null) ? (groupIndex % rooms.length) : (autoSalleCounters[key] % rooms.length);
    autoSalleCounters[key] = (autoSalleCounters[key] + 1) % rooms.length;
    return rooms[idx];
}
// === AJOUT : Helpers pour v√©rifier disponibilit√© r√©elle des salles et picker en tenant compte de seancesLocal ===

/**
 * isRoomAvailable(room, jour, creneau, seancesLocal, requirePairedFree)
 * - v√©rifie si `room` est libre pour (jour, creneau) en tenant compte :
 *   - occupation directe (m√™me cr√©neau de d√©part)
 *   - TP coupl√©s (s√©ance TP occupe 2 cr√©neaux)
 *   - sym√©trie (s√©ance dont la seconde partie est le cr√©neau test√©)
 * - if requirePairedFree === true : v√©rifie aussi la partie coupl√©e (utile pour TP)
 * - renvoie '' si aucune salle disponible
 */
// --- MODIFICATION: Correction de la logique de v√©rification de disponibilit√© ---
function isRoomAvailable(room, jour, creneau, seancesLocal, requirePairedFree = false) {
    if (!room) return false;
    
    // Helper interne pour v√©rifier un unique cr√©neau
    const checkSlot = (slot) => {
        if (!slot) return true; // Si le slot est null (ex: pas de 'paired'), il est "disponible"
        for (const s of seancesLocal) {
            if (!s || s.jour !== jour || s.salle !== room) continue;

            // 1. Conflit direct: une s√©ance 's' existante commence DANS ce cr√©neau 'slot'.
            if (s.creneau === slot) return false; 

            // 2. Conflit indirect (TP): une s√©ance 's' est un TP, a commenc√© AVANT ce 'slot',
            //    et sa deuxi√®me partie est ce 'slot'.
            if (s.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[s.creneau] === slot) return false;
        }
        return true; // Ce cr√©neau ('slot') est libre pour cette salle/jour.
    };

    // V√©rifie le cr√©neau principal demand√©
    if (!checkSlot(creneau)) return false;

    // Si c'est un TP (requirePairedFree = true), on doit AUSSI v√©rifier le cr√©neau coupl√©.
    if (requirePairedFree) {
        const paired = CRENEAUX_COUPLES_SUIVANT[creneau] || null;
        if (!checkSlot(paired)) return false; // V√©rifie si le 2e cr√©neau est aussi libre
    }
    
    return true; // Le(s) cr√©neau(x) n√©cessaire(s) sont libres.
}
// --- FIN DE LA MODIFICATION ---

function pickAvailableRoom(type, filiere, jour, creneau, seancesLocal, groupIndex) {
    const key = `${filiere}|${type}`;
    if (!autoSalleCounters[key]) autoSalleCounters[key] = 0;

    let rooms = getRoomsForTypeForFiliere(type, filiere) || [];
    if (!rooms || rooms.length === 0) rooms = Object.keys(SALLES_INFO || {});

    if (!rooms || rooms.length === 0) return '';

    const paired = CRENEAUX_COUPLES_SUIVANT[creneau] || null;

    let beginIdx = 0;
    if (typeof groupIndex === 'number') {
        beginIdx = groupIndex % rooms.length;
    } else {
        beginIdx = autoSalleCounters[key] % rooms.length;
    }

    for (let offset = 0; offset < rooms.length; offset++) {
        const idx = (beginIdx + offset) % rooms.length;
        const room = rooms[idx];

        const requirePairedFree = (type === 'TP' && !!paired);
        if (isRoomAvailable(room, jour, creneau, seancesLocal, requirePairedFree)) {
            autoSalleCounters[key] = (idx + 1) % rooms.length;
            return room;
        }
    }

    return '';
}
function initialiserAutoAssignRoomSelectorsIntegration() {
    // charger persistance si existante
    try {
        AUTO_SALLE_CHOICES_PAR_FILIERE = JSON.parse(localStorage.getItem('edt_auto_salles_by_filiere') || '{}');
    } catch(_) { AUTO_SALLE_CHOICES_PAR_FILIERE = {}; }

    populateAutoSalleSelects();
    const inputF = document.getElementById('inputFiliere');
    if (inputF) {
        inputF.addEventListener('change', () => {
            loadAutoSalleSelectionsForFiliere(inputF.value);
        });
    }
    const saveBtn = document.getElementById('btnSaveAutoSalleForFiliere');
    if (saveBtn) saveBtn.addEventListener('click', saveAutoSalleSelectionsForCurrentFiliere);
    const clearBtn = document.getElementById('btnClearAutoSalleForFiliere');
    if (clearBtn) clearBtn.addEventListener('click', clearAutoSalleForCurrentFiliere);
}

/* --------- Fin : Helpers multi-salles --------- */
        function initialiserTout() {
    initialiserFormulaire();
    initialiserMatiereManagementForm(); 
    initialiserDeletionForms();
    initialiserVueEDT();
    initialiserCreneauxManagement();
    initialiserAutoAssignRoomSelectorsIntegration(); // <-- AJOUT√â ICI
    initialiserFiliereSessionManagement();
    actualiserAffichage();
    updateInfoBar();
}

        // --- Planification Automatique des Cr√©neaux ---

function planificationAutomatiqueDesCreneaux() {
    // Optionnel: demander confirmation si des s√©ances existent d√©j√†
    if (seances.length > 0) {
        showCustomDialog({
            title: "Mise √† jour automatique",
            htmlMessage: "L'emploi du temps n'est pas vide.<br>Cette action va <strong>uniquement ajouter les s√©ances manquantes</strong> (Cours, TD, TP) qui n'ont pas encore √©t√© planifi√©es, sans affecter les s√©ances existantes.<br><br>Voulez-vous continuer ?",
            confirmText: "Oui, compl√©ter l'EDT",
            onConfirm: () => {
                _planificationAutomatiqueDesCreneaux_core();
            }
        });
    } else {
        _planificationAutomatiqueDesCreneaux_core();
    }
}

// Fonctions utilitaires pour choisir une salle Amphi ou Standard
function getSallePourCours() {
    for (const [nom, type] of Object.entries(SALLES_INFO)) {
        if (type === 'Amphi') return nom;
    }
    return Object.keys(SALLES_INFO)[0] || '';
}
function getSallePourTD() {
    for (const [nom, type] of Object.entries(SALLES_INFO)) {
        if (type === 'Standard') return nom;
    }
    return Object.keys(SALLES_INFO)[0] || '';
}

// --- MODIFICATION: Boucle it√©rative pour la planification ---
// L'ancienne fonction _planificationAutomatiqueDesCreneaux_core a √©t√© renomm√©e en _runAutoPlanningPass
// et est maintenant appel√©e en boucle par la nouvelle fonction _planificationAutomatiqueDesCreneaux_core.

function _planificationAutomatiqueDesCreneaux_core() {
    showSpinner();
    logMessage("üîÑ Lancement de la planification automatique it√©rative...", 'initial');
    
    const MAX_ITERATIONS = 100; // MODIFI√â: Augment√© de 20 √† 100
    let totalSessionsAdded = 0;
    let currentIteration = 0;
    let sessionsAddedInLastPass = 0;

    // Utiliser setTimeout pour d√©bloquer le thread UI et afficher le spinner
    setTimeout(() => {
        do {
            currentIteration++;
            logMessage(`--- D√©but de l'it√©ration ${currentIteration} / ${MAX_ITERATIONS} ---`, 'initial');
            
            // Appelle la fonction de passe unique (l'ancienne logique _core)
            sessionsAddedInLastPass = _runAutoPlanningPass(currentIteration); 
            
            logMessage(`--- Fin de l'it√©ration ${currentIteration}: ${sessionsAddedInLastPass} s√©ance(s) ajout√©e(s).`, 'initial');
            totalSessionsAdded += sessionsAddedInLastPass;

        } while (
            sessionsAddedInLastPass > 0 &&  // Continue s'il y a eu du progr√®s
            currentIteration < MAX_ITERATIONS // Et qu'on n'a pas d√©pass√© la limite
        );

        // Une fois la boucle termin√©e
        hideSpinner();
        if (currentIteration >= MAX_ITERATIONS && sessionsAddedInLastPass > 0) {
            logMessage(`‚ö†Ô∏è Planification auto: Limite de ${MAX_ITERATIONS} it√©rations atteinte. Il manque peut-√™tre encore des s√©ances.`, 'warning');
        }
        
        logMessage(`‚úÖ Planification automatique termin√©e. ${totalSessionsAdded} nouvelle(s) s√©ance(s) ajout√©e(s) au total.`, "success");

        actualiserAffichage(); // Met √† jour l'affichage final et sauvegarde
    }, 50); // 50ms delay to allow UI to update
}


// Planification automatique compl√®te avec salles cours/TD et TP sur 2 cr√©neaux matin/apr√®s-midi
// (Ceci EST l'ancienne fonction _planificationAutomatiqueDesCreneaux_core, renomm√©e)
function _runAutoPlanningPass(currentIteration = 1) {
    let sessionsAddedCount = 0; // NOUVEAU: Compteur pour cette passe
    let nextSessionIdLocal = nextSessionId;
    autoSalleCounters = {};
    const jours = LISTE_JOURS;
    const creneaux = getSortedCreneauxKeys();

    // copie locale des s√©ances pour tester les disponibilit√©s pendant la g√©n√©ration
    const seancesLocal = seances.slice();

    const logWarn = (msg) => {
        // Logue seulement les avertissements lors de la premi√®re passe pour √©viter le spam
        if (currentIteration === 1) {
            logMessage(`‚ö†Ô∏è Planification auto: ${msg}`, 'warning');
        }
    };

    // --- MODIFICATION : Remplacement des helpers sp√©cifiques par un helper g√©n√©rique ---
    // V√©rifie si une s√©ance existe d√©j√† pour une fili√®re/section donn√©e √† un jour/cr√©neau donn√©
    const isSlotOccupiedForSection = (filiere, sectionName, jour, creneau) => {
        return seancesLocal.some(s =>
            s.jour === jour &&
            s.creneau === creneau &&
            s.filiere === filiere &&
            s.section === sectionName
        );
    };
    // --- FIN MODIFICATION ---

    // V√©rifie s'il existe d√©j√† un TP de la m√™me mati√®re qui occupe ce m√™me "temps"
    const tpExistsSameMatiereAt = (jour, creneauToCheck, matiere) => {
        return seancesLocal.some(s => {
            if (s.jour !== jour) return false;
            if (s.type !== 'TP') return false;
            if (s.matiere !== matiere) return false;
            // M√™me cr√©neau de d√©part
            if (s.creneau === creneauToCheck) return true;
            // Si une s√©ance existante est TP et sa seconde partie est le cr√©neauToCheck
            if (CRENEAUX_COUPLES_SUIVANT[s.creneau] === creneauToCheck) return true;
            // Si le cr√©neauToCheck est le d√©but d'un TP et la s√©ance existante est la seconde partie (sym√©trique)
            if (CRENEAUX_COUPLES_SUIVANT[creneauToCheck] === s.creneau) return true;
            return false;
        });
    };

    // Helper : indique si un cr√©neau est "apr√®s-midi"
    function isAfternoonCreneau(creneau, creneauxList) {
        const separator = '10h15';
        const idxSeparator = creneauxList.indexOf(separator);
        if (idxSeparator === -1) return creneauxList.indexOf(creneau) > 1; // Fallback heuristic
        return creneauxList.indexOf(creneau) > idxSeparator;
    }

    // Tri des jours par charge croissante
    function getDayPriorityList(seancesLocalRef, filiere = null, sectionName = null) {
        const counts = {};
        LISTE_JOURS.forEach(d => counts[d] = 0);
        seancesLocalRef.forEach(s => {
            if (filiere && s.filiere !== filiere) return;
            if (sectionName && s.section !== sectionName) return;
            if (!counts.hasOwnProperty(s.jour)) counts[s.jour] = 0;
            counts[s.jour]++;
        });
        return LISTE_JOURS.slice().sort((a, b) => {
            const ca = counts[a] || 0;
            const cb = counts[b] || 0;
            if (ca === cb) return LISTE_JOURS.indexOf(a) - LISTE_JOURS.indexOf(b);
            return ca - cb;
        });
    }

    // --- MODIFICATION : Utilisation de isSlotOccupiedForSection dans findSlotForCourse ---
    const findSlotForCourse = (filiere, sectionName) => {
        const joursOrdres = getDayPriorityList(seancesLocal, filiere, sectionName);
        for (let j = 0; j < joursOrdres.length; j++) {
            const jour = joursOrdres[j];
            for (const c of creneaux) {
                // Ne pas planifier le samedi apr√®s-midi
                if (jour === 'Samedi' && isAfternoonCreneau(c, creneaux)) continue;
                // V√©rifier si le cr√©neau est d√©j√† occup√© pour cette section/fili√®re
                if (isSlotOccupiedForSection(filiere, sectionName, jour, c)) continue;
                // Si on arrive ici, le cr√©neau est libre pour le cours
                return { jour, creneau: c };
            }
        }
        return null; // Aucun cr√©neau trouv√©
    };
    // --- FIN MODIFICATION ---


    // --- MODIFICATION : Utilisation de isSlotOccupiedForSection dans findSlotForGroupTDTP ---
    const findSlotForGroupTDTP = (filiere, sectionName, groupName, type, matiere) => {
        const uniqueGroup = `${filiere} - ${sectionName} - ${groupName}`;
        const uniqueSection = `${filiere} - ${sectionName}`; // NOUVEAU: Pour v√©rifier les Cours
        const joursOrdres = getDayPriorityList(seancesLocal, filiere, sectionName);

        for (let j = 0; j < joursOrdres.length; j++) {
            const jour = joursOrdres[j];
            const candidats = [];

            for (const c of creneaux) {
                // Si TP, n'utiliser que les cr√©neaux d√©but couplables
                if (type === 'TP' && !CRENEAUX_COUPLES_SUIVANT.hasOwnProperty(c)) continue;

                // Interdire samedi apr√®s-midi
                if (jour === 'Samedi' && isAfternoonCreneau(c, creneaux)) continue;

                // --- MODIFICATION: V√©rification des conflits plus fine ---
                // La v√©rification
                // if (isSlotOccupiedForSection(filiere, sectionName, jour, c)) continue;
                // a √©t√© remplac√©e par les deux v√©rifications suivantes pour permettre les TD/TP concurrents

                // 1. V√©rifier si ce GROUPE SP√âCIFIQUE (uniqueGroup) est d√©j√† occup√© (par un TD ou TP)
                const groupBusy = seancesLocal.some(s =>
                    s.jour === jour && s.creneau === c && s.uniqueStudentEntity === uniqueGroup
                );
                if (groupBusy) continue;

                // 2. V√©rifier si la SECTION ENTI√àRE est occup√©e par un COURS
                const sectionInCourse = seancesLocal.some(s =>
                    s.jour === jour && s.creneau === c && s.type === 'Cours' && s.uniqueStudentEntity === uniqueSection
                );
                if (sectionInCourse) continue;
                // --- FIN DE LA MODIFICATION ---

                // Gestion sp√©cifique TP (v√©rifier aussi le cr√©neau coupl√©)
                if (type === 'TP') {
                    const paired = CRENEAUX_COUPLES_SUIVANT[c]; // Garanti d'exister par le check pr√©c√©dent
                    // V√©rifier si le cr√©neau coupl√© est aussi libre (ni groupe occup√©, ni section en cours)
                    const pairedGroupBusy = seancesLocal.some(s =>
                        s.jour === jour && s.creneau === paired && s.uniqueStudentEntity === uniqueGroup
                    );
                    if (pairedGroupBusy) continue;

                    const pairedSectionInCourse = seancesLocal.some(s =>
                        s.jour === jour && s.creneau === paired && s.type === 'Cours' && s.uniqueStudentEntity === uniqueSection
                    );
                    if (pairedSectionInCourse) continue;
                    
                    // V√©rifier s'il n'y a pas d√©j√† un TP de la m√™me mati√®re √† cet endroit (d√©but ou fin)
                    if (tpExistsSameMatiereAt(jour, paired, matiere) || tpExistsSameMatiereAt(jour, c, matiere)) continue;
                    // Si on arrive ici, le cr√©neau et son couple sont valides pour ce TP
                    candidats.push({ creneau: c, score: 0 }); // Pas de scoring pour TP pour l'instant
                    continue; // On passe au cr√©neau suivant une fois un candidat TP ajout√©
                }

                // --- Cas TD : scoring favorisant cr√©neaux adjacents ---
                let score = 0;
                const idx = creneaux.indexOf(c);
                const isAfternoon = isAfternoonCreneau(c, creneaux);
                const prevIdx = idx - 1;
                const nextIdx = idx + 1;
                const isSameBlock = (i) => (i >= 0 && i < creneaux.length) ? (isAfternoonCreneau(creneaux[i], creneaux) === isAfternoon) : false;

                // NOUVEAU: Helper interne pour le scoring (remplace isSlotOccupiedForSection)
                const isSlotFreeForGroup = (j, cr) => {
                    const gBusy = seancesLocal.some(s => 
                        s.jour === j && s.creneau === cr && s.uniqueStudentEntity === uniqueGroup);
                    const sInCourse = seancesLocal.some(s => 
                        s.jour === j && s.creneau === cr && s.type === 'Cours' && s.uniqueStudentEntity === uniqueSection);
                    return !gBusy && !sInCourse;
                };

                 // Bonus si cr√©neau adjacent libre pour m√™me groupe (permet deux TD successifs)
                if (isSameBlock(prevIdx)) {
                    const prevC = creneaux[prevIdx];
                    // MODIFI√â: On v√©rifie que le cr√©neau pr√©c√©dent est libre pour ce GROUPE
                    if (isSlotFreeForGroup(jour, prevC)) {
                         score += 140; // prime forte
                    }
                }
                if (isSameBlock(nextIdx)) {
                    const nextC = creneaux[nextIdx];
                    // MODIFI√â: On v√©rifie que le cr√©neau suivant est libre pour ce GROUPE
                     if (isSlotFreeForGroup(jour, nextC)) {
                         score += 140;
                    }
                }

                // Bonus si un TD existant du m√™me groupe est adjacent (regrouper)
                const hasAdjacentExistingTD = seancesLocal.some(s =>
                    s.jour === jour &&
                    s.type === 'TD' &&
                    s.uniqueStudentEntity === uniqueGroup &&
                    Math.abs(creneaux.indexOf(s.creneau) - idx) === 1 &&
                    isSameBlock(creneaux.indexOf(s.creneau))
                );
                if (hasAdjacentExistingTD) score += 500; // MODIFI√â: Augment√© de 70 √† 500 pour prioriser fortement le regroupement

                candidats.push({ creneau: c, score });
            } // fin boucle creneaux

            // Choisir le meilleur candidat pour ce jour
            if (candidats.length > 0) {
                candidats.sort((a, b) => b.score - a.score);
                return { jour, creneau: candidats[0].creneau };
            }
        } // fin jours
        return null; // Aucun cr√©neau trouv√©
    };
    // --- FIN MODIFICATION ---

    // Fonction de post-traitement pour alterner les TDs (pas de changement n√©cessaire ici)
    function enforceAlternatingTDs() {
        const sortedCreneaux = getSortedCreneauxKeys();
        const combos = new Map();
        seancesLocal.forEach(s => {
            if (!s.section) return;
            const key = `${s.filiere}|||${s.section}`;
            if (!combos.has(key)) combos.set(key, new Set());
            const parts = (s.uniqueStudentEntity || '').split(' - ');
            const groupPart = parts.length >= 3 ? parts[2] : (s.groupe || '');
            if (groupPart) combos.get(key).add(groupPart);
        });

        function canMoveSeanceTo(se, newJour, newCreneau) {
            const hypo = { ...se, jour: newJour, creneau: newCreneau };
            // Utilise verifierConflits pour une v√©rification compl√®te avant d√©placement
            const conflicts = verifierConflits(hypo, [se.id]);
            return conflicts.length === 0;
        }

        for (const [comboKey, groupsSet] of combos.entries()) {
            const [filiere, sectionName] = comboKey.split('|||');
            const groups = Array.from(groupsSet);

            for (const jour of LISTE_JOURS) {
                for (let i = 0; i < sortedCreneaux.length - 1; i++) {
                    const c1 = sortedCreneaux[i];
                    const c2 = sortedCreneaux[i + 1];

                    if (isAfternoonCreneau(c1, sortedCreneaux) !== isAfternoonCreneau(c2, sortedCreneaux)) continue;
                    if (jour === 'Samedi' && isAfternoonCreneau(c2, sortedCreneaux)) continue;

                    for (let a = 0; a < groups.length; a++) {
                        for (let b = a + 1; b < groups.length; b++) {
                            const g1 = groups[a];
                            const g2 = groups[b];
                            const unique1 = `${filiere} - ${sectionName} - ${g1}`;
                            const unique2 = `${filiere} - ${sectionName} - ${g2}`;

                            const s1 = seancesLocal.find(s => s.uniqueStudentEntity === unique1 && s.jour === jour && s.creneau === c1 && s.type === 'TD');
                            const s2 = seancesLocal.find(s => s.uniqueStudentEntity === unique2 && s.jour === jour && s.creneau === c1 && s.type === 'TD');

                            if (!s1 || !s2 || s1.matiere === s2.matiere) continue;

                            const s1b = seancesLocal.find(s => s.uniqueStudentEntity === unique1 && s.matiere === s2.matiere && s.type === 'TD' && !(s.jour === jour && s.creneau === c1));
                            const s2b = seancesLocal.find(s => s.uniqueStudentEntity === unique2 && s.matiere === s1.matiere && s.type === 'TD' && !(s.jour === jour && s.creneau === c1));

                            if (!s1b || !s2b) continue;

                            // V√©rifie si c2 est libre pour les DEUX groupes avant de tester les d√©placements
                            // MODIFI√â: V√©rification plus fine que isSlotOccupiedForSection
                            // 1. V√©rifier si G1 est occup√© en c2
                            const s1b_conflict = seancesLocal.find(s => s.uniqueStudentEntity === unique1 && s.jour === jour && s.creneau === c2);
                            if (s1b_conflict && s1b_conflict.id !== s1b.id) continue;

                            // 2. V√©rifier si G2 est occup√© en c2
                            const s2b_conflict = seancesLocal.find(s => s.uniqueStudentEntity === unique2 && s.jour === jour && s.creneau === c2);
                            if (s2b_conflict && s2b_conflict.id !== s2b.id) continue;

                            // 3. V√©rifier si la section a un COURS en c2
                            const course_conflict = seancesLocal.find(s => s.uniqueStudentEntity === `${filiere} - ${sectionName}` && s.type === 'Cours' && s.jour === jour && s.creneau === c2);
                            if (course_conflict) continue;
                            // FIN MODIFICATION
                            
                            if (!canMoveSeanceTo(s1b, jour, c2) || !canMoveSeanceTo(s2b, jour, c2)) continue;

                            const applyMove = (seanceObj, newJour, newCreneau) => {
                                const localIdx = seancesLocal.findIndex(s => s.id === seanceObj.id);
                                if (localIdx !== -1) {
                                    seancesLocal[localIdx].jour = newJour;
                                    seancesLocal[localIdx].creneau = newCreneau;
                                }
                                const globalIdx = seances.findIndex(s => s.id === seanceObj.id);
                                if (globalIdx !== -1) {
                                    seances[globalIdx].jour = newJour;
                                    seances[globalIdx].creneau = newCreneau;
                                }
                            };

                            applyMove(s1b, jour, c2);
                            applyMove(s2b, jour, c2);

                            logMessage(`üîÅ Alternance cr√©√©e: ${g1}<->${g2} sur ${jour} (${c1}/${c2}) - mati√®res ${s1.matiere}/${s2.matiere}`, 'initial');
                        }
                    }
                }
            }
        }
    }


    // Parcours des mati√®res et cr√©ation des s√©ances (logique principale)
    // --- MODIFICATION: Filtrer les mati√®res en fonction de la vue s√©lectionn√©e ---
    const allMatieresForSession = getMatieresForCurrentSession();
    const selectedFiliereFiltre = document.getElementById('selectEDTView').value;
    let matieresAProcesser = [];

    if (selectedFiliereFiltre && selectedFiliereFiltre !== 'global' && selectedFiliereFiltre !== 'enseignant_selectionne') {
        // Une fili√®re sp√©cifique est s√©lectionn√©e
        matieresAProcesser = allMatieresForSession.filter(matiere => {
            const info = MATIERE_GROUPES_INFO[matiere];
            return info && info.filiere === selectedFiliereFiltre;
        });
        if (currentIteration === 1) { // Logue seulement √† la premi√®re passe
            logMessage(`‚ÑπÔ∏è G√©n√©ration auto cibl√©e pour la fili√®re: <strong>${selectedFiliereFiltre}</strong>`, 'initial');
        }
    } else {
        // Vue "Globale" ou "Enseignant", on prend tout
        matieresAProcesser = allMatieresForSession;
        if (currentIteration === 1) { // Logue seulement √† la premi√®re passe
            logMessage(`‚ÑπÔ∏è G√©n√©ration auto pour <strong>toutes les fili√®res</strong> de la session.`, 'initial');
        }
    }
    
    matieresAProcesser.forEach(matiere => {
    // --- FIN DE LA MODIFICATION ---
        const info = MATIERE_GROUPES_INFO[matiere];
        if (!info || !info.filiere) {
             if (currentIteration === 1) { // Logue seulement √† la premi√®re passe
                 if (!info) logWarn(`Info manquante pour mati√®re ${matiere}, ignor√©e.`);
                 else logWarn(`Mati√®re ${matiere} non attach√©e √† une fili√®re, ignor√©e.`);
             }
             return; // Ignore les mati√®res sans info ou sans fili√®re
        }
        const filiere = info.filiere;
        const sections = info.sections_cours || 0;
        const tdGroups = info.td_groups || 0;
        const tpGroups = info.tp_groups || 0;

        // Cours
        for (let s = 0; s < sections; s++) {
            const sectionName = `Section ${String.fromCharCode(65 + s)}`;
            
            // --- MODIFICATION AJOUT√âE ---
            // V√©rifie si un cours pour cette mati√®re/fili√®re/section existe d√©j√†
            const uniqueStudentEntityCours = `${filiere} - ${sectionName}`;
            const coursExiste = seancesLocal.some(seance => 
                seance.matiere === matiere && 
                seance.type === 'Cours' && 
                seance.uniqueStudentEntity === uniqueStudentEntityCours
            );
            if (coursExiste) {
                continue; // Si le cours existe, on passe √† la section suivante
            }
            // --- FIN DE LA MODIFICATION ---
            
            const slot = findSlotForCourse(filiere, sectionName);
            if (!slot) {
                logWarn(`Impossible de placer Cours ${matiere} - ${filiere} ${sectionName}.`);
                continue;
            }
            const { jour, creneau } = slot;
            // --- MODIFICATION: Correction du fallback aveugle ---
            // L'ancienne logique (|| getSallePourCours()) prenait S1 m√™me si S1 √©tait occup√©e.
            const sallePourCours = pickAvailableRoom('Cours', filiere, jour, creneau, seancesLocal, s);
             if (!sallePourCours) { 
                 logWarn(`Aucune salle disponible (configur√©e ou fallback) pour Cours ${matiere} - ${filiere} ${sectionName}. S√©ance non cr√©√©e.`); 
                 continue; 
             }
            // --- FIN MODIFICATION ---

            const baseSession = { id: nextSessionIdLocal++, jour, creneau, matiere, type: 'Cours', filiere, groupe: sectionName, section: sectionName, uniqueStudentEntity: uniqueStudentEntityCours, enseignant: '', enseignantsArray: [], salle: sallePourCours, dureeAffichee: 1.5, hTP_Affecte: getHtpForMatiere(matiere, 'Cours') };
            seancesLocal.push(baseSession);
            seances.push(baseSession);
            sessionsAddedCount++; // NOUVEAU: Incr√©menter le compteur
        }

        // TD
        for (let s = 0; s < sections; s++) {
            const sectionName = `Section ${String.fromCharCode(65 + s)}`;
            for (let g = 1; g <= tdGroups; g++) {
                const groupName = `G${g}`;
                
                // --- MODIFICATION AJOUT√âE ---
                // V√©rifie si un TD pour cette mati√®re/fili√®re/section/groupe existe d√©j√†
                const uniqueStudentEntityTD = `${filiere} - ${sectionName} - ${groupName}`;
                const tdExiste = seancesLocal.some(seance => 
                    seance.matiere === matiere && 
                    seance.type === 'TD' && 
                    seance.uniqueStudentEntity === uniqueStudentEntityTD
                );
                if (tdExiste) {
                    continue; // Si le TD existe, on passe au groupe suivant
                }
                // --- FIN DE LA MODIFICATION ---
                
                const slot = findSlotForGroupTDTP(filiere, sectionName, groupName, 'TD', matiere);
                if (!slot) {
                    logWarn(`Impossible de placer TD ${matiere} - ${filiere} ${sectionName} ${groupName}.`);
                    continue;
                }
                const { jour, creneau } = slot;
                const uniqueStudentEntity = `${filiere} - ${sectionName} - ${groupName}`;
                // --- MODIFICATION: Correction du fallback aveugle ---
                // L'ancienne logique (|| getSallePourTD()) prenait S1 m√™me si S1 √©tait occup√©e.
                const sallePourTD = pickAvailableRoom('TD', filiere, jour, creneau, seancesLocal, g - 1);
                 if (!sallePourTD) { 
                     logWarn(`Aucune salle disponible (configur√©e ou fallback) pour TD ${matiere} - ${filiere} ${sectionName} ${groupName}. S√©ance non cr√©√©e.`); 
                 continue; 
             }
            // --- FIN MODIFICATION ---

                const sessionObj = { id: nextSessionIdLocal++, jour, creneau, matiere, type: 'TD', filiere, groupe: `${sectionName} - ${groupName}`, section: sectionName, uniqueStudentEntity: uniqueStudentEntity, enseignant: '', enseignantsArray: [], salle: sallePourTD, dureeAffichee: 1.5, hTP_Affecte: getHtpForMatiere(matiere, 'TD') };
                seancesLocal.push(sessionObj);
                seances.push(sessionObj);
                sessionsAddedCount++; // NOUVEAU: Incr√©menter le compteur
            }
        }

        // TP
        for (let s = 0; s < sections; s++) {
            const sectionName = `Section ${String.fromCharCode(65 + s)}`;
            for (let g = 1; g <= tpGroups; g++) {
                const groupName = `G${g}`;
                
                // --- MODIFICATION AJOUT√âE ---
                // V√©rifie si un TP pour cette mati√®re/fili√®re/section/groupe existe d√©j√†
                const uniqueStudentEntityTP = `${filiere} - ${sectionName} - ${groupName}`;
                const tpExiste = seancesLocal.some(seance => 
                    seance.matiere === matiere && 
                    seance.type === 'TP' && 
                    seance.uniqueStudentEntity === uniqueStudentEntityTP
                );
                if (tpExiste) {
                    continue; // Si le TP existe, on passe au groupe suivant
                }
                // --- FIN DE LA MODIFICATION ---
                
                const slot = findSlotForGroupTDTP(filiere, sectionName, groupName, 'TP', matiere);
                if (!slot) {
                    logWarn(`Impossible de placer TP ${matiere} - ${filiere} ${sectionName} ${groupName}.`);
                    continue;
                }
                const { jour, creneau } = slot;
                const paired = CRENEAUX_COUPLES_SUIVANT[creneau]; // Garanti d'exister par findSlot
                const uniqueStudentEntity = `${filiere} - ${sectionName} - ${groupName}`;

                // Pas de salle pour TP
                const sessionTP1 = { id: nextSessionIdLocal++, jour, creneau: creneau, matiere, type: 'TP', filiere, groupe: `${sectionName} - ${groupName}`, section: sectionName, uniqueStudentEntity: uniqueStudentEntity, enseignant: '', enseignantsArray: [], salle: '', dureeAffichee: 1.5, hTP_Affecte: getHtpForMatiere(matiere, 'TP') };
                seancesLocal.push(sessionTP1);
                seances.push(sessionTP1);
                sessionsAddedCount++; // NOUVEAU: Incr√©menter le compteur (une seule fois pour le couple)

                const sessionTP2 = { id: nextSessionIdLocal++, jour, creneau: paired, matiere, type: 'TP', filiere, groupe: `${sectionName} - ${groupName}`, section: sectionName, uniqueStudentEntity: uniqueStudentEntity, enseignant: '', enseignantsArray: [], salle: '', dureeAffichee: 1.5, hTP_Affecte: 0 };
                seancesLocal.push(sessionTP2);
                seances.push(sessionTP2);
            }
        }
    });

    // Appliquer le post-traitement pour l'alternance des TD
    // --- MODIFICATION: D√©sactiv√© pour privil√©gier le regroupement (pairing) ---
    // enforceAlternatingTDs();
    // --- FIN DE LA MODIFICATION ---

    nextSessionId = nextSessionIdLocal; // Mettre √† jour l'ID global
    // MODIFI√â: Retrait de l'actualisation et du log, g√©r√© par le wrapper
    // actualiserAffichage(); // Met √† jour l'affichage et sauvegarde
    // logMessage("‚úÖ Planification automatique des cr√©neaux termin√©e.", "success");
    return sessionsAddedCount; // NOUVEAU: Retourner le nombre d'ajouts
}

// --- Fin Planification Automatique ---

            /* getFreeRoomsForSlot: retourne un tableau des salles compatibles et libres pour le (jour,creneau,type).
   excludeSessionId : si fourni, on ignore la s√©ance avec cet id (utile en √©dition).
*/
// --- MODIFICATION : Simplification et correction de la logique de getFreeRoomsForSlot ---
function isRoomOccupiedAt(roomName, jour, creneauToCheck, excludeSessionId = null) {
    if (!roomName || !jour || !creneauToCheck) return false;

    for (const s of seances) {
        // Ignorer la s√©ance en cours d'√©dition
        if (excludeSessionId && s.id === excludeSessionId) continue;
        // Ignorer les s√©ances d'autres jours ou sans salle
        if (s.jour !== jour || !s.salle) continue;
        // Ignorer si la salle n'est pas celle qu'on v√©rifie
        if (s.salle !== roomName) continue;

        // 1. Occupation directe : La s√©ance commence √† ce cr√©neau
        if (s.creneau === creneauToCheck) {
            return true;
        }

        // 2. Occupation par TP coupl√© : Une s√©ance TP a commenc√© avant et sa 2√®me partie est ce cr√©neau
        if (s.type === 'TP' && CRENEAUX_COUPLES_SUIVANT[s.creneau] === creneauToCheck) {
            return true;
        }
    }
    // Si aucune condition d'occupation n'est remplie, la salle est libre √† ce cr√©neau
    return false;
}

function getFreeRoomsForSlot(jour, creneau, type, excludeSessionId = null) {
    if (!jour || !creneau) return [];

    const allRooms = Object.keys(SALLES_INFO || {});
    const pairedCreneau = (type === 'TP') ? CRENEAUX_COUPLES_SUIVANT[creneau] : null;

    const freeRooms = allRooms.filter(room => {
        // 1. V√©rifier la compatibilit√© du type de salle
        if (!validerSalle(type, room)) {
            return false;
        }

        // 2. V√©rifier si la salle est libre sur le cr√©neau de d√©but
        if (isRoomOccupiedAt(room, jour, creneau, excludeSessionId)) {
            return false;
        }

        // 3. Si c'est un TP et qu'il y a un cr√©neau coupl√©, v√©rifier aussi ce cr√©neau
        if (pairedCreneau && isRoomOccupiedAt(room, jour, pairedCreneau, excludeSessionId)) {
            return false;
        }

        // Si toutes les v√©rifications passent, la salle est libre et compatible
        return true;
    });

    freeRooms.sort((a, b) => a.localeCompare(b));
    return freeRooms;
}
// --- FIN DE LA MODIFICATION ---

// Met √† jour le <select id="inputSalleLibre"> en fonction du jour/cr√©neau/type actuels
function updateFreeRoomsDropdown() {
    const sel = document.getElementById('inputSalleLibre');
    const info = document.getElementById('inputSalleLibreInfo');
    if (!sel || !info) return;

    const jour = (document.getElementById('inputJour') || {}).value || '';
    const creneau = (document.getElementById('inputCreneau') || {}).value || '';
    const type = (document.getElementById('inputType') || {}).value || '';
    const excludeId = (typeof currentlyEditingSessionId !== 'undefined' && currentlyEditingSessionId !== null) ? currentlyEditingSessionId : null;

    sel.innerHTML = '<option value="">-- Choisir une salle libre --</option>';

    if (!jour || !creneau) {
        info.textContent = 'S√©lectionnez jour et cr√©neau pour voir les salles libres.';
        return;
    }

    // Utilise la fonction corrig√©e
    const freeRooms = getFreeRoomsForSlot(jour, creneau, type, excludeId);

    if (!freeRooms || freeRooms.length === 0) {
        info.textContent = 'Aucune salle libre compatible d√©tect√©e pour ce cr√©neau.';
        return;
    }

    freeRooms.forEach(r => {
        const opt = document.createElement('option');
        opt.value = r;
        opt.textContent = r + (SALLES_INFO[r] ? ` (${SALLES_INFO[r]})` : '');
        sel.appendChild(opt);
    });

    info.textContent = `${freeRooms.length} salle(s) libre(s) compatible(s).`;
}

// Debounce helper (l√©ger)
function debounce(fn, wait = 180) {
    let t;
    return function(...args) {
        clearTimeout(t);
        t = setTimeout(() => fn.apply(this, args), wait);
    };
}
const debouncedUpdateFreeRoomsDropdown = debounce(updateFreeRoomsDropdown, 120);

// Handler "Utiliser" (copie la salle choisie dans inputSalle et met √† jour l'affichage)
function useSelectedFreeSalle() {
    const sel = document.getElementById('inputSalleLibre');
    if (!sel) return;
    const chosen = sel.value;
    if (!chosen) {
        logMessage('‚ö†Ô∏è Veuillez s√©lectionner d\'abord une salle libre.', 'warning');
        return;
    }
    const inputSalle = document.getElementById('inputSalle');
    if (inputSalle) inputSalle.value = chosen;
    updateSalleInfo();
    logMessage(`‚úÖ Salle choisie : ${chosen}`, 'success');
}

document.addEventListener('DOMContentLoaded', function() {
            chargerTravail(); 
            initialiserTout();
            setupTabs(); 
            
            inputMatiere.addEventListener('change', () => { 
                // ... existing code inside listener ...
                updateEnseignantVisibility(document.getElementById('inputType').value); // MODIFI√â: Mettre √† jour la visibilit√© Ens2 au changement de mati√®re aussi
            }); 

            inputFiliere.addEventListener('change', () => {
                activeFiliereConstraint = inputFiliere.value;
                updateMatiereOptions(activeFiliereConstraint);
                updateEnseignantSelects();
            });
            
            inputSection.addEventListener('change', updateGroupesSelect);

            // NOUVELLE LIGNE AJOUT√âE: L'√©couteur manquant pour le changement de Type
            document.getElementById('inputType').addEventListener('change', (e) => updateFormVisibility(e.target.value));

            inputCreneau.addEventListener('change', (e) => updateCreneauFin(e.target.value, inputType.value));
            inputSalle.addEventListener('change', updateSalleInfo);
            inputEnseignant1.addEventListener('change', updateEnseignantDetailPanels);
            inputEnseignant2.addEventListener('change', updateEnseignantDetailPanels);
            annulerModification();

            document.getElementById('btnCancelEdit').addEventListener('click', annulerModification);
            document.getElementById('btnDeleteSelected').addEventListener('click', deleteSelectedSeanceHandler);

            document.getElementById('attributionForm').addEventListener('submit', function(e) {
                e.preventDefault();

                // Si ce n'est pas en mode √©dition, l'√©v√©nement submit ne doit rien faire
                if (currentlyEditingSessionId === null) {
                    return;
                }

                if (!validerFormulaire().isValid) {
                    return; // La validation a √©chou√©, les erreurs sont d√©j√† affich√©es
                }

                // CORRECTION: L'objet data √©tait vide. Il faut le peupler avec les valeurs du formulaire.
                const data = {
                    jour: document.getElementById('inputJour').value,
                    creneau: document.getElementById('inputCreneau').value,
                    filiere: document.getElementById('inputFiliere').value,
                    matiere: document.getElementById('inputMatiere').value,
                    type: document.getElementById('inputType').value,
                    enseignant1: document.getElementById('inputEnseignant1').value,
                    enseignant2: document.getElementById('inputEnseignant2').value,
                    salle: document.getElementById('inputSalle').value,
                    section: document.getElementById('inputSection').value,
                    groupeTDTP: document.getElementById('inputGroupeTDTP').value
                };

                const seancesBackup = JSON.parse(JSON.stringify(seances));
                const idToEdit = currentlyEditingSessionId;

                // MODIFI√â: On supprime d'abord l'ancienne s√©ance (et son couple potentiel) AVANT d'essayer d'ajouter la nouvelle.
                // La fonction supprimerSeance a √©t√© modifi√©e pour une d√©tection plus robuste du couple.
                const initialLengthBeforeDelete = seances.length;
                supprimerSeance(idToEdit); // This modifies the global `seances` array and handles coupling
                const deletedSuccessfully = seances.length < initialLengthBeforeDelete;

                if (!deletedSuccessfully) {
                    logMessage(`‚ö†Ô∏è Erreur lors de la suppression pr√©liminaire de la s√©ance ${idToEdit}. Modification annul√©e.`, 'error');
                    seances = seancesBackup; // Restore if deletion failed
                    actualiserAffichage();
                    return;
                }

                // L'ajout g√®re maintenant la validation du nombre d'enseignants TP.
                // On passe [idToEdit] pour que verifierConflits exclue formellement l'ID, bien que la s√©ance soit d√©j√† retir√©e.
                const ajoutReussi = ajouterSeance(data.jour, data.creneau, data.filiere, data.matiere, data.type, data.enseignant1, data.enseignant2, data.salle, data.section, data.groupeTDTP, [idToEdit]);

                if (ajoutReussi) {
                   logMessage(`‚úÖ S√©ance ID ${idToEdit} modifi√©e avec succ√®s.`, 'success');
                   annulerModification(); // <-- AJOUT√â: R√©initialiser le formulaire apr√®s succ√®s
                   // actualiserAffichage(); // Est appel√© √† la fin de toute fa√ßon
                } else {
                    logMessage(`‚ùå √âchec de la modification de la s√©ance ID ${idToEdit} (probablement un conflit). Restauration de l'√©tat pr√©c√©dent.`, 'error');
                    seances = seancesBackup; // Restore if adding failed
                    // actualiserAffichage(); // Est appel√© √† la fin de toute fa√ßon
                }
                 actualiserAffichage(); // Mettre √† jour l'affichage dans tous les cas (succ√®s ou √©chec+restauration)
            });
            
            document.getElementById('inputAnneeUniversitaire').addEventListener('change', sauvegarderTravail);
            document.getElementById('selectDepartement').addEventListener('change', sauvegarderTravail);
            
            const selectSession = document.getElementById('selectSession');
            let sessionPrecedentePourSauvegarde = selectSession.value;

            function handleSessionChange() {
                chargerTravail();
                initialiserTout();
            }

            selectSession.addEventListener('focus', function() {
                sessionPrecedentePourSauvegarde = this.value;
            });

            selectSession.addEventListener('change', function() {
                const nouvelleSession = this.value;
                const sessionPrecedente = sessionPrecedentePourSauvegarde;
                
                const cleSeancesPrecedentes = `edt_physique_seances_${sessionPrecedente.replace(/\s+/g, '_')}`;
                const cleNextIdPrecedent = `edt_physique_nextId_${sessionPrecedente.replace(/\s+/g, '_')}`;
                localStorage.setItem(cleSeancesPrecedentes, JSON.stringify(seances));
                localStorage.setItem(cleNextIdPrecedent, nextSessionId);
                logMessage(`‚úÖ Travail pour la session "${sessionPrecedente}" sauvegard√©.`, 'initial');

                if (sessionPrecedente === "Session d'automne" && nouvelleSession === "Session de printemps") {
                    
                    const seancesAutomne = seances;
                    const volumesAutomneActuels = {};
                    LISTE_ENSEIGNANTS.forEach(ens => {
                        // MODIFI√â: On reporte le volume TOTAL (enseignement + forfaitaire)
                        volumesAutomneActuels[ens] = calculerDetailsVolume(ens, seancesAutomne, ENSEIGNANT_VOLUMES_SUPPLEMENTAIRES).total;
                    });

                    showCustomDialog({
                        title: 'Passer √† la Session de Printemps ?',
                        htmlMessage: `L'emploi du temps va √™tre <strong>r√©initialis√©</strong> pour la session de printemps. <br><br>Le volume horaire de la session d'automne sera conserv√© et ajout√© √† celui du printemps. Continuer ?`,
                        confirmText: 'Oui, continuer',
                        onConfirm: () => {
                            VOLUMES_AUTOMNE = volumesAutomneActuels;
                            localStorage.setItem('edt_physique_volumes_automne', JSON.stringify(VOLUMES_AUTOMNE));
                            logMessage("üìä Volumes de la session d'automne sauvegard√©s.", 'initial');
                            
                            localStorage.setItem("edt_physique_seances_Session_de_printemps", "[]");
                            localStorage.setItem("edt_physique_nextId_Session_de_printemps", "1");
                            
                            localStorage.setItem('edt_header_session', nouvelleSession);
                            handleSessionChange();
                        },
                        onCancel: () => {
                            this.value = sessionPrecedente;
                        }
                    });
                } 
                else if (nouvelleSession === "Session d'automne") {
                    showCustomDialog({
                        title: "Avertissement - Session d'Automne",
                        htmlMessage: `Vous allez basculer sur la session d'automne. <strong>Attention, tout l'emploi du temps de cette session sera effac√© pour un nouveau d√©part.</strong><br><br>Voulez-vous continuer ?`,
                        confirmText: 'Oui, effacer et continuer',
                        onConfirm: () => {
                            localStorage.setItem("edt_physique_seances_Session_d'automne", "[]");
                            localStorage.setItem("edt_physique_nextId_Session_d'automne", "1");
                            logMessage("üóëÔ∏è Emploi du temps de la session d'automne r√©initialis√©.", 'warning');
                            
                            localStorage.setItem('edt_header_session', nouvelleSession);
                            handleSessionChange();
                        },
                        onCancel: () => {
                            this.value = sessionPrecedente;
                        }
                    });
                } else {
                    localStorage.setItem('edt_header_session', nouvelleSession);
                    handleSessionChange();
                }
            });


            document.getElementById('btnAddEnseignant').addEventListener('click', addEnseignantHandler);
            document.getElementById('btnAddSalle').addEventListener('click', addSalleHandler);
            document.getElementById('btnAddFiliere').addEventListener('click', addFiliereHandler); 
            document.getElementById('btnAddMatiere').addEventListener('click', addMatiereHandler);
            document.getElementById('btnInitMatieres').addEventListener('click', initDefaultMatieresHandler); 

            selectMatiereToManage.addEventListener('change', updateMatiereManagementFields);
            document.getElementById('btnUpdateMatiereSettings').addEventListener('click', updateMatiereSettingsHandler);
            document.getElementById('btnDeleteMatiere').addEventListener('click', deleteMatiereHandler);
            document.getElementById('btnDeleteEnseignant').addEventListener('click', deleteEnseignantHandler);
            document.getElementById('btnDeleteSalle').addEventListener('click', deleteSalleHandler);
            document.getElementById('btnDeleteFiliere').addEventListener('click', deleteFiliereHandler);

            document.getElementById('btnResetEDT').addEventListener('click', resetEDTHandler);
            document.getElementById('btnResetProject').addEventListener('click', resetProjectHandler);

            document.getElementById('btnClearLog').addEventListener('click', clearLogHandler);
            document.getElementById('btnLoadSouhaits').addEventListener('click', () => document.getElementById('inputSouhaitsFile').click());
            document.getElementById('inputSouhaitsFile').addEventListener('change', chargerSouhaitsExcel);

            document.getElementById('btnAddVolumeSupplementaire').addEventListener('click', ajouterVolumeSupplementaire);
            document.getElementById('volumeSupplementaireType').addEventListener('change', function() {
                document.getElementById('volumeSupplementaireDescriptionAutre').style.display = this.value === 'Autre' ? 'block' : 'none';
            });
            
            document.getElementById('btnAfficherEdtEnseignant').addEventListener('click', afficherEDTEnseignantSelectionne);
            
            document.getElementById('selectEDTView').addEventListener('change', () => {
                actualiserAffichage();
                const filtreVue = document.getElementById('selectEDTView').value;
                if (filtreVue !== 'global' && filtreVue !== 'enseignant_selectionne') {
                    activeFiliereConstraint = filtreVue;
                    const inputFiliere = document.getElementById('inputFiliere');
                    if (Array.from(inputFiliere.options).some(opt => opt.value === activeFiliereConstraint)) {
                        inputFiliere.value = activeFiliereConstraint;
                    }
                    updateMatiereOptions(activeFiliereConstraint);
                } else {
                     activeFiliereConstraint = null;
                    updateMatiereOptions(null);
                }
            });

            document.getElementById('btnAddCreneau').addEventListener('click', addCreneauHandler);

            const modal = document.getElementById('dialogModal');
            document.getElementById('closeDialogBtn').addEventListener('click', hideCustomDialog);
            document.getElementById('dialogCancelBtn').addEventListener('click', hideCustomDialog);
            modal.addEventListener('click', (e) => { if(e.target === modal) hideCustomDialog(); });

            document.getElementById('saveBtn').addEventListener('click', sauvegarderTravail);
            document.getElementById('exportProjetBtn').addEventListener('click', exportProjet);
            document.getElementById('importProjetBtn').addEventListener('click', () => document.getElementById('importProjetInput').click());
            document.getElementById('importProjetInput').addEventListener('change', importProjet);

            document.getElementById('exportEnseignantBtn').addEventListener('click', exporterEDTParEnseignant);
            document.getElementById('exportMultiSheetBtn').addEventListener('click', exporterEDTZipExcelsStylises);
            document.getElementById('exportGlobalPdfBtn').addEventListener('click', exporterEDTGlobalPDF);
            // NOUVEAU: Listener pour l'export de la vue actuelle en PDF
            document.getElementById('exportCurrentViewPdfBtn').addEventListener('click', exportCurrentViewToPDF);

            // MODIFI√â: √âcouteur pour stocker les changements de session de fili√®re temporairement
            document.getElementById('filiereSessionList').addEventListener('change', (event) => {
                if (event.target.tagName === 'SELECT') {
                    const filiereNom = event.target.dataset.filiereNom;
                    const nouvelleSession = event.target.value;
                    tempFiliereSessionChanges[filiereNom] = nouvelleSession;
                }
            });

            // NOUVEAU: √âcouteur pour le bouton d'application des changements de session de fili√®re
            document.getElementById('btnApplyFiliereSessionChanges').addEventListener('click', () => {
                let changesCount = 0;
                for (const filiereNom in tempFiliereSessionChanges) {
                    const filiereToUpdate = LISTE_FILIERES.find(f => f.nom === filiereNom);
                    const nouvelleSession = tempFiliereSessionChanges[filiereNom];

                    if (filiereToUpdate && filiereToUpdate.session !== nouvelleSession) {
                        filiereToUpdate.session = nouvelleSession;
                        changesCount++;
                    }
                }

                if (changesCount > 0) {
                    logMessage(`‚úÖ ${changesCount} association(s) fili√®re/session ont √©t√© mises √† jour.`, 'success');
                    initialiserTout(); // Rafra√Æchit toute l'application et sauvegarde
                } else {
                    logMessage("‚ÑπÔ∏è Aucune modification √† appliquer.", 'initial');
                }

                tempFiliereSessionChanges = {}; // Vider les changements temporaires
            });

            document.getElementById('searchMatiere').addEventListener('input', actualiserAffichage);
            document.getElementById('searchEnseignant').addEventListener('input', actualiserAffichage);
            document.getElementById('searchSalle').addEventListener('input', actualiserAffichage);
            document.getElementById('searchSectionGroupe').addEventListener('input', actualiserAffichage); // NOUVEAU
            document.getElementById('btnClearFilters').addEventListener('click', () => {
                document.getElementById('searchMatiere').value = '';
                document.getElementById('searchEnseignant').value = '';
                document.getElementById('searchSalle').value = '';
                document.getElementById('searchSectionGroupe').value = ''; // NOUVEAU
                actualiserAffichage();
            });

            const edtTable = document.getElementById('edtTable');
            edtTable.addEventListener('mouseover', handleCellHoverConflict);
            edtTable.addEventListener('mouseout', handleCellMouseLeave);

            window.supprimerSeance = supprimerSeance; 
            window.supprimerVolumeSupplementaire = supprimerVolumeSupplementaire;
            window.ouvrirFormulairePourModifier = ouvrirFormulairePourModifier;
            window.selectCell = selectCell;
            window.deleteCreneauHandler = deleteCreneauHandler;
            window.attribuerSeanceDirectement = attribuerSeanceDirectement;
            
            window.handleDragStart = handleDragStart;
            window.handleDragEnd = handleDragEnd;
            window.handleDragOver = handleDragOver;
            window.handleDragLeave = handleDragLeave;
            window.handleDrop = handleDrop;

            // NOUVEAU: Listener pour le bouton d'attribution auto
            document.getElementById('btnAutoAssign').addEventListener('click', assignTeachersAutomatically);
            
            // NOUVEAU: Listener pour le bouton de suggestion d'enseignant
            document.getElementById('btnSuggestTeacher').addEventListener('click', suggestTeacher);
            
            // NOUVEAU: Listener pour le bouton de suggestion d'enseignant 2
            document.getElementById('btnSuggestTeacher2').addEventListener('click', suggestTeacher2);
            // === INS√âRER DANS DOMContentLoaded : liaisons pour Salles libres ===
const btnUse = document.getElementById('btnUseFreeSalle');
if (btnUse) btnUse.addEventListener('click', useSelectedFreeSalle);

const btnRefresh = document.getElementById('btnRefreshFreeSalle');
if (btnRefresh) btnRefresh.addEventListener('click', updateFreeRoomsDropdown);

// Attacher les √©couteurs de changement aux champs qui influencent la disponibilit√©
['inputJour', 'inputCreneau', 'inputType'].forEach(id => {
    const el = document.getElementById(id);
    if (el) el.addEventListener('change', debouncedUpdateFreeRoomsDropdown);
});

// Initialiser le dropdown au chargement (afin qu'il s'affiche si formulaire pr√©-rempli)
updateFreeRoomsDropdown();
        });
    </script>
	<script src="js/ai_integration.js"></script>
</body>
</html>